/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.1
 * Features enabled: core
 * Features disabled: race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
            "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":17,"./schedule":18,"./util":21}],2:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],3:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":15}],4:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() && !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":21}],5:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":10,"./util":21}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));

var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));

var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    var self = this;
    setTimeout(function() {
        self._notifyUnhandledRejection();
    }, 1);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField & 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined && promiseCreated !== null &&
        wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined()) return;
        if ((promise._bitField & 65535) === 0) return;

        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = "at " + lineMatches[1] +
                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                }
            }

            if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                            creatorLine = "\n" + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = "a promise was created in a " + name +
            "handler " + handlerLine + "but was not returned from it, " +
            "see http://goo.gl/rRqMUw" +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }

    if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{"./errors":9,"./util":21}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":10,"./util":21}],10:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    "tapCatch statement predicate: "
                    + "expecting an object but got " + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{"./catch_filter":5,"./util":21}],12:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", "async", code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":21}],13:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":21}],14:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":9,"./es5":10,"./util":21}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent("promiseCreated", this);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("Catch statement predicate: " +
                    "expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent("promiseChained", this, promise);
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" &&
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent("promiseFulfilled", this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent("promiseRejected", this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent("promiseResolved", this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent("promiseCancelled", this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &&
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = "3.5.1";
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{"./async":1,"./bind":2,"./cancel":4,"./catch_filter":5,"./context":6,"./debuggability":7,"./direct_resolve":8,"./errors":9,"./es5":10,"./finally":11,"./join":12,"./method":13,"./nodeback":14,"./promise_array":16,"./synchronous_inspection":19,"./thenables":20,"./util":21}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":21}],17:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],18:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === "function" &&
           typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement("div");
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":21}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField & 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField & 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],20:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, "_promise0");
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":21}],21:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error ||
        (obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string");
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":10}]},{},[3])(3)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
//Configure Bluebird Promises.
Promise.config({
  longStackTraces: false,
  warnings: {
    wForgottenReturn: false
  }
});

/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

_aureliaConfigureModuleLoader();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});

define('aurelia-binding',['exports', 'aurelia-logging', 'aurelia-pal', 'aurelia-task-queue', 'aurelia-metadata'], function (exports, _aureliaLogging, _aureliaPal, _aureliaTaskQueue, _aureliaMetadata) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getSetObserver = exports.BindingEngine = exports.NameExpression = exports.Listener = exports.ListenerExpression = exports.BindingBehaviorResource = exports.ValueConverterResource = exports.Call = exports.CallExpression = exports.Binding = exports.BindingExpression = exports.ObjectObservationAdapter = exports.ObserverLocator = exports.SVGAnalyzer = exports.presentationAttributes = exports.presentationElements = exports.elements = exports.ComputedExpression = exports.ClassObserver = exports.SelectValueObserver = exports.CheckedObserver = exports.ValueAttributeObserver = exports.StyleObserver = exports.DataAttributeObserver = exports.dataAttributeAccessor = exports.XLinkAttributeObserver = exports.SetterObserver = exports.PrimitiveObserver = exports.propertyAccessor = exports.DirtyCheckProperty = exports.DirtyChecker = exports.EventManager = exports.delegationStrategy = exports.getMapObserver = exports.ParserImplementation = exports.Parser = exports.Scanner = exports.Lexer = exports.Token = exports.bindingMode = exports.ExpressionCloner = exports.Unparser = exports.LiteralObject = exports.LiteralArray = exports.LiteralString = exports.LiteralPrimitive = exports.PrefixNot = exports.Binary = exports.CallFunction = exports.CallMember = exports.CallScope = exports.AccessKeyed = exports.AccessMember = exports.AccessScope = exports.AccessThis = exports.Conditional = exports.Assign = exports.ValueConverter = exports.BindingBehavior = exports.Chain = exports.Expression = exports.getArrayObserver = exports.CollectionLengthObserver = exports.ModifyCollectionObserver = exports.ExpressionObserver = exports.sourceContext = exports.targetContext = undefined;
  exports.camelCase = camelCase;
  exports.createOverrideContext = createOverrideContext;
  exports.getContextFor = getContextFor;
  exports.createScopeForTest = createScopeForTest;
  exports.connectable = connectable;
  exports.enqueueBindingConnect = enqueueBindingConnect;
  exports.subscriberCollection = subscriberCollection;
  exports.calcSplices = calcSplices;
  exports.mergeSplice = mergeSplice;
  exports.projectArraySplices = projectArraySplices;
  exports.getChangeRecords = getChangeRecords;
  exports.cloneExpression = cloneExpression;
  exports.hasDeclaredDependencies = hasDeclaredDependencies;
  exports.declarePropertyDependencies = declarePropertyDependencies;
  exports.computedFrom = computedFrom;
  exports.createComputedObserver = createComputedObserver;
  exports.valueConverter = valueConverter;
  exports.bindingBehavior = bindingBehavior;
  exports.observable = observable;
  exports.connectBindingToSignal = connectBindingToSignal;
  exports.signalBindings = signalBindings;

  var LogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  

  var _dec, _dec2, _class, _dec3, _class2, _dec4, _class3, _dec5, _class5, _dec6, _class7, _dec7, _class8, _dec8, _class9, _dec9, _class10, _class12, _temp, _dec10, _class13, _class14, _temp2;

  var targetContext = exports.targetContext = 'Binding:target';
  var sourceContext = exports.sourceContext = 'Binding:source';

  var map = Object.create(null);

  function camelCase(name) {
    if (name in map) {
      return map[name];
    }
    var result = name.charAt(0).toLowerCase() + name.slice(1).replace(/[_.-](\w|$)/g, function (_, x) {
      return x.toUpperCase();
    });
    map[name] = result;
    return result;
  }

  function createOverrideContext(bindingContext, parentOverrideContext) {
    return {
      bindingContext: bindingContext,
      parentOverrideContext: parentOverrideContext || null
    };
  }

  function getContextFor(name, scope, ancestor) {
    var oc = scope.overrideContext;

    if (ancestor) {
      while (ancestor && oc) {
        ancestor--;
        oc = oc.parentOverrideContext;
      }
      if (ancestor || !oc) {
        return undefined;
      }
      return name in oc ? oc : oc.bindingContext;
    }

    while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
      oc = oc.parentOverrideContext;
    }
    if (oc) {
      return name in oc ? oc : oc.bindingContext;
    }

    return scope.bindingContext || scope.overrideContext;
  }

  function createScopeForTest(bindingContext, parentBindingContext) {
    if (parentBindingContext) {
      return {
        bindingContext: bindingContext,
        overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
      };
    }
    return {
      bindingContext: bindingContext,
      overrideContext: createOverrideContext(bindingContext)
    };
  }

  var slotNames = [];
  var versionSlotNames = [];

  for (var i = 0; i < 100; i++) {
    slotNames.push('_observer' + i);
    versionSlotNames.push('_observerVersion' + i);
  }

  function addObserver(observer) {
    var observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
    var i = observerSlots;
    while (i-- && this[slotNames[i]] !== observer) {}

    if (i === -1) {
      i = 0;
      while (this[slotNames[i]]) {
        i++;
      }
      this[slotNames[i]] = observer;
      observer.subscribe(sourceContext, this);

      if (i === observerSlots) {
        this._observerSlots = i + 1;
      }
    }

    if (this._version === undefined) {
      this._version = 0;
    }
    this[versionSlotNames[i]] = this._version;
  }

  function observeProperty(obj, propertyName) {
    var observer = this.observerLocator.getObserver(obj, propertyName);
    addObserver.call(this, observer);
  }

  function observeArray(array) {
    var observer = this.observerLocator.getArrayObserver(array);
    addObserver.call(this, observer);
  }

  function unobserve(all) {
    var i = this._observerSlots;
    while (i--) {
      if (all || this[versionSlotNames[i]] !== this._version) {
        var observer = this[slotNames[i]];
        this[slotNames[i]] = null;
        if (observer) {
          observer.unsubscribe(sourceContext, this);
        }
      }
    }
  }

  function connectable() {
    return function (target) {
      target.prototype.observeProperty = observeProperty;
      target.prototype.observeArray = observeArray;
      target.prototype.unobserve = unobserve;
      target.prototype.addObserver = addObserver;
    };
  }

  var queue = [];
  var queued = {};
  var nextId = 0;
  var minimumImmediate = 100;
  var frameBudget = 15;

  var isFlushRequested = false;
  var immediate = 0;

  function flush(animationFrameStart) {
    var length = queue.length;
    var i = 0;
    while (i < length) {
      var binding = queue[i];
      queued[binding.__connectQueueId] = false;
      binding.connect(true);
      i++;

      if (i % 100 === 0 && _aureliaPal.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
        break;
      }
    }
    queue.splice(0, i);

    if (queue.length) {
      _aureliaPal.PLATFORM.requestAnimationFrame(flush);
    } else {
      isFlushRequested = false;
      immediate = 0;
    }
  }

  function enqueueBindingConnect(binding) {
    if (immediate < minimumImmediate) {
      immediate++;
      binding.connect(false);
    } else {
      var id = binding.__connectQueueId;
      if (id === undefined) {
        id = nextId;
        nextId++;
        binding.__connectQueueId = id;
      }

      if (!queued[id]) {
        queue.push(binding);
        queued[id] = true;
      }
    }
    if (!isFlushRequested) {
      isFlushRequested = true;
      _aureliaPal.PLATFORM.requestAnimationFrame(flush);
    }
  }

  function addSubscriber(context, callable) {
    if (this.hasSubscriber(context, callable)) {
      return false;
    }
    if (!this._context0) {
      this._context0 = context;
      this._callable0 = callable;
      return true;
    }
    if (!this._context1) {
      this._context1 = context;
      this._callable1 = callable;
      return true;
    }
    if (!this._context2) {
      this._context2 = context;
      this._callable2 = callable;
      return true;
    }
    if (!this._contextsRest) {
      this._contextsRest = [context];
      this._callablesRest = [callable];
      return true;
    }
    this._contextsRest.push(context);
    this._callablesRest.push(callable);
    return true;
  }

  function removeSubscriber(context, callable) {
    if (this._context0 === context && this._callable0 === callable) {
      this._context0 = null;
      this._callable0 = null;
      return true;
    }
    if (this._context1 === context && this._callable1 === callable) {
      this._context1 = null;
      this._callable1 = null;
      return true;
    }
    if (this._context2 === context && this._callable2 === callable) {
      this._context2 = null;
      this._callable2 = null;
      return true;
    }
    var callables = this._callablesRest;
    if (callables === undefined || callables.length === 0) {
      return false;
    }
    var contexts = this._contextsRest;
    var i = 0;
    while (!(callables[i] === callable && contexts[i] === context) && callables.length > i) {
      i++;
    }
    if (i >= callables.length) {
      return false;
    }
    contexts.splice(i, 1);
    callables.splice(i, 1);
    return true;
  }

  var arrayPool1 = [];
  var arrayPool2 = [];
  var poolUtilization = [];

  function callSubscribers(newValue, oldValue) {
    var context0 = this._context0;
    var callable0 = this._callable0;
    var context1 = this._context1;
    var callable1 = this._callable1;
    var context2 = this._context2;
    var callable2 = this._callable2;
    var length = this._contextsRest ? this._contextsRest.length : 0;
    var contextsRest = void 0;
    var callablesRest = void 0;
    var poolIndex = void 0;
    var i = void 0;
    if (length) {
      poolIndex = poolUtilization.length;
      while (poolIndex-- && poolUtilization[poolIndex]) {}
      if (poolIndex < 0) {
        poolIndex = poolUtilization.length;
        contextsRest = [];
        callablesRest = [];
        poolUtilization.push(true);
        arrayPool1.push(contextsRest);
        arrayPool2.push(callablesRest);
      } else {
        poolUtilization[poolIndex] = true;
        contextsRest = arrayPool1[poolIndex];
        callablesRest = arrayPool2[poolIndex];
      }

      i = length;
      while (i--) {
        contextsRest[i] = this._contextsRest[i];
        callablesRest[i] = this._callablesRest[i];
      }
    }

    if (context0) {
      if (callable0) {
        callable0.call(context0, newValue, oldValue);
      } else {
        context0(newValue, oldValue);
      }
    }
    if (context1) {
      if (callable1) {
        callable1.call(context1, newValue, oldValue);
      } else {
        context1(newValue, oldValue);
      }
    }
    if (context2) {
      if (callable2) {
        callable2.call(context2, newValue, oldValue);
      } else {
        context2(newValue, oldValue);
      }
    }
    if (length) {
      for (i = 0; i < length; i++) {
        var callable = callablesRest[i];
        var context = contextsRest[i];
        if (callable) {
          callable.call(context, newValue, oldValue);
        } else {
          context(newValue, oldValue);
        }
        contextsRest[i] = null;
        callablesRest[i] = null;
      }
      poolUtilization[poolIndex] = false;
    }
  }

  function hasSubscribers() {
    return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
  }

  function hasSubscriber(context, callable) {
    var has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
    if (has) {
      return true;
    }
    var index = void 0;
    var contexts = this._contextsRest;
    if (!contexts || (index = contexts.length) === 0) {
      return false;
    }
    var callables = this._callablesRest;
    while (index--) {
      if (contexts[index] === context && callables[index] === callable) {
        return true;
      }
    }
    return false;
  }

  function subscriberCollection() {
    return function (target) {
      target.prototype.addSubscriber = addSubscriber;
      target.prototype.removeSubscriber = removeSubscriber;
      target.prototype.callSubscribers = callSubscribers;
      target.prototype.hasSubscribers = hasSubscribers;
      target.prototype.hasSubscriber = hasSubscriber;
    };
  }

  var ExpressionObserver = exports.ExpressionObserver = (_dec = connectable(), _dec2 = subscriberCollection(), _dec(_class = _dec2(_class = function () {
    function ExpressionObserver(scope, expression, observerLocator, lookupFunctions) {
      

      this.scope = scope;
      this.expression = expression;
      this.observerLocator = observerLocator;
      this.lookupFunctions = lookupFunctions;
    }

    ExpressionObserver.prototype.getValue = function getValue() {
      return this.expression.evaluate(this.scope, this.lookupFunctions);
    };

    ExpressionObserver.prototype.setValue = function setValue(newValue) {
      this.expression.assign(this.scope, newValue);
    };

    ExpressionObserver.prototype.subscribe = function subscribe(context, callable) {
      var _this = this;

      if (!this.hasSubscribers()) {
        this.oldValue = this.expression.evaluate(this.scope, this.lookupFunctions);
        this.expression.connect(this, this.scope);
      }
      this.addSubscriber(context, callable);
      if (arguments.length === 1 && context instanceof Function) {
        return {
          dispose: function dispose() {
            _this.unsubscribe(context, callable);
          }
        };
      }
    };

    ExpressionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.unobserve(true);
        this.oldValue = undefined;
      }
    };

    ExpressionObserver.prototype.call = function call() {
      var newValue = this.expression.evaluate(this.scope, this.lookupFunctions);
      var oldValue = this.oldValue;
      if (newValue !== oldValue) {
        this.oldValue = newValue;
        this.callSubscribers(newValue, oldValue);
      }
      this._version++;
      this.expression.connect(this, this.scope);
      this.unobserve(false);
    };

    return ExpressionObserver;
  }()) || _class) || _class);


  function isIndex(s) {
    return +s === s >>> 0;
  }

  function toNumber(s) {
    return +s;
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {
    calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);
      var north = void 0;
      var west = void 0;

      for (var _i = 0; _i < rowCount; ++_i) {
        distances[_i] = new Array(columnCount);
        distances[_i][0] = _i;
      }

      for (var j = 0; j < columnCount; ++j) {
        distances[0][j] = j;
      }

      for (var _i2 = 1; _i2 < rowCount; ++_i2) {
        for (var _j = 1; _j < columnCount; ++_j) {
          if (this.equals(current[currentStart + _j - 1], old[oldStart + _i2 - 1])) {
            distances[_i2][_j] = distances[_i2 - 1][_j - 1];
          } else {
            north = distances[_i2 - 1][_j] + 1;
            west = distances[_i2][_j - 1] + 1;
            distances[_i2][_j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i === 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j === 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min = void 0;
        if (west < north) {
          min = west < northWest ? west : northWest;
        } else {
          min = north < northWest ? north : northWest;
        }

        if (min === northWest) {
          if (northWest === current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min === west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart === 0 && oldStart === 0) {
        prefixCount = this.sharedPrefix(current, old, minLength);
      }

      if (currentEnd === current.length && oldEnd === old.length) {
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
      }

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
        return [];
      }

      if (currentStart === currentEnd) {
        var _splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd) {
          _splice.removed.push(old[oldStart++]);
        }

        return [_splice];
      } else if (oldStart === oldEnd) {
        return [newSplice(currentStart, [], currentEnd - currentStart)];
      }

      var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var _i3 = 0; _i3 < ops.length; ++_i3) {
        switch (ops[_i3]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice) {
              splice = newSplice(index, [], 0);
            }

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice) {
              splice = newSplice(index, [], 0);
            }

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice) {
              splice = newSplice(index, [], 0);
            }

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function sharedPrefix(current, old, searchLength) {
      for (var _i4 = 0; _i4 < searchLength; ++_i4) {
        if (!this.equals(current[_i4], old[_i4])) {
          return _i4;
        }
      }

      return searchLength;
    },

    sharedSuffix: function sharedSuffix(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2])) {
        count++;
      }

      return count;
    },

    calculateSplices: function calculateSplices(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
    },

    equals: function equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    if (end1 < start2 || end2 < start1) {
      return -1;
    }

    if (end1 === start2 || end2 === start1) {
      return 0;
    }

    if (start1 < start2) {
      if (end1 < end2) {
        return end1 - start2;
      }

      return end2 - start2;
    }

    if (end2 < end1) {
      return end2 - start1;
    }

    return end1 - start1;
  }

  function mergeSplice(splices, index, removed, addedCount) {
    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var _i5 = 0; _i5 < splices.length; _i5++) {
      var current = splices[_i5];
      current.index += insertionOffset;

      if (inserted) {
        continue;
      }

      var intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);

      if (intersectCount >= 0) {

        splices.splice(_i5, 1);
        _i5--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length + current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          inserted = true;
        } else {
          var currentRemoved = current.removed;

          if (splice.index < current.index) {
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, currentRemoved);
            currentRemoved = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(currentRemoved, append);
          }

          splice.removed = currentRemoved;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {

        inserted = true;

        splices.splice(_i5, 0, splice);
        _i5++;

        var offset = splice.addedCount - splice.removed.length;
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted) {
      splices.push(splice);
    }
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var _i6 = 0; _i6 < changeRecords.length; _i6++) {
      var record = changeRecords[_i6];
      switch (record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name)) {
            continue;
          }

          var index = toNumber(record.name);
          if (index < 0) {
            continue;
          }

          mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function (splice) {
      if (splice.addedCount === 1 && splice.removed.length === 1) {
        if (splice.removed[0] !== array[splice.index]) {
          splices.push(splice);
        }

        return;
      }

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

  function newRecord(type, object, key, oldValue) {
    return {
      type: type,
      object: object,
      key: key,
      oldValue: oldValue
    };
  }

  function getChangeRecords(map) {
    var entries = new Array(map.size);
    var keys = map.keys();
    var i = 0;
    var item = void 0;

    while (item = keys.next()) {
      if (item.done) {
        break;
      }

      entries[i] = newRecord('added', map, item.value);
      i++;
    }

    return entries;
  }

  var ModifyCollectionObserver = exports.ModifyCollectionObserver = (_dec3 = subscriberCollection(), _dec3(_class2 = function () {
    function ModifyCollectionObserver(taskQueue, collection) {
      

      this.taskQueue = taskQueue;
      this.queued = false;
      this.changeRecords = null;
      this.oldCollection = null;
      this.collection = collection;
      this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
    }

    ModifyCollectionObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };

    ModifyCollectionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };

    ModifyCollectionObserver.prototype.addChangeRecord = function addChangeRecord(changeRecord) {
      if (!this.hasSubscribers() && !this.lengthObserver) {
        return;
      }

      if (changeRecord.type === 'splice') {
        var index = changeRecord.index;
        var arrayLength = changeRecord.object.length;
        if (index > arrayLength) {
          index = arrayLength - changeRecord.addedCount;
        } else if (index < 0) {
          index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
        }
        if (index < 0) {
          index = 0;
        }
        changeRecord.index = index;
      }

      if (this.changeRecords === null) {
        this.changeRecords = [changeRecord];
      } else {
        this.changeRecords.push(changeRecord);
      }

      if (!this.queued) {
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }
    };

    ModifyCollectionObserver.prototype.flushChangeRecords = function flushChangeRecords() {
      if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
        this.call();
      }
    };

    ModifyCollectionObserver.prototype.reset = function reset(oldCollection) {
      this.oldCollection = oldCollection;

      if (this.hasSubscribers() && !this.queued) {
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }
    };

    ModifyCollectionObserver.prototype.getLengthObserver = function getLengthObserver() {
      return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
    };

    ModifyCollectionObserver.prototype.call = function call() {
      var changeRecords = this.changeRecords;
      var oldCollection = this.oldCollection;
      var records = void 0;

      this.queued = false;
      this.changeRecords = [];
      this.oldCollection = null;

      if (this.hasSubscribers()) {
        if (oldCollection) {
          if (this.collection instanceof Map || this.collection instanceof Set) {
            records = getChangeRecords(oldCollection);
          } else {
            records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
          }
        } else {
          if (this.collection instanceof Map || this.collection instanceof Set) {
            records = changeRecords;
          } else {
            records = projectArraySplices(this.collection, changeRecords);
          }
        }

        this.callSubscribers(records);
      }

      if (this.lengthObserver) {
        this.lengthObserver.call(this.collection[this.lengthPropertyName]);
      }
    };

    return ModifyCollectionObserver;
  }()) || _class2);
  var CollectionLengthObserver = exports.CollectionLengthObserver = (_dec4 = subscriberCollection(), _dec4(_class3 = function () {
    function CollectionLengthObserver(collection) {
      

      this.collection = collection;
      this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
      this.currentValue = collection[this.lengthPropertyName];
    }

    CollectionLengthObserver.prototype.getValue = function getValue() {
      return this.collection[this.lengthPropertyName];
    };

    CollectionLengthObserver.prototype.setValue = function setValue(newValue) {
      this.collection[this.lengthPropertyName] = newValue;
    };

    CollectionLengthObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };

    CollectionLengthObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };

    CollectionLengthObserver.prototype.call = function call(newValue) {
      var oldValue = this.currentValue;
      this.callSubscribers(newValue, oldValue);
      this.currentValue = newValue;
    };

    return CollectionLengthObserver;
  }()) || _class3);

  var pop = Array.prototype.pop;
  var push = Array.prototype.push;
  var reverse = Array.prototype.reverse;
  var shift = Array.prototype.shift;
  var sort = Array.prototype.sort;
  var splice = Array.prototype.splice;
  var unshift = Array.prototype.unshift;

  Array.prototype.pop = function () {
    var notEmpty = this.length > 0;
    var methodCallResult = pop.apply(this, arguments);
    if (notEmpty && this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'delete',
        object: this,
        name: this.length,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };

  Array.prototype.push = function () {
    var methodCallResult = push.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: this.length - arguments.length,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };

  Array.prototype.reverse = function () {
    var oldArray = void 0;
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.flushChangeRecords();
      oldArray = this.slice();
    }
    var methodCallResult = reverse.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.reset(oldArray);
    }
    return methodCallResult;
  };

  Array.prototype.shift = function () {
    var notEmpty = this.length > 0;
    var methodCallResult = shift.apply(this, arguments);
    if (notEmpty && this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'delete',
        object: this,
        name: 0,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };

  Array.prototype.sort = function () {
    var oldArray = void 0;
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.flushChangeRecords();
      oldArray = this.slice();
    }
    var methodCallResult = sort.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.reset(oldArray);
    }
    return methodCallResult;
  };

  Array.prototype.splice = function () {
    var methodCallResult = splice.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: +arguments[0],
        removed: methodCallResult,
        addedCount: arguments.length > 2 ? arguments.length - 2 : 0
      });
    }
    return methodCallResult;
  };

  Array.prototype.unshift = function () {
    var methodCallResult = unshift.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: 0,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };

  function _getArrayObserver(taskQueue, array) {
    return ModifyArrayObserver.for(taskQueue, array);
  }

  exports.getArrayObserver = _getArrayObserver;

  var ModifyArrayObserver = function (_ModifyCollectionObse) {
    _inherits(ModifyArrayObserver, _ModifyCollectionObse);

    function ModifyArrayObserver(taskQueue, array) {
      

      return _possibleConstructorReturn(this, _ModifyCollectionObse.call(this, taskQueue, array));
    }

    ModifyArrayObserver.for = function _for(taskQueue, array) {
      if (!('__array_observer__' in array)) {
        Reflect.defineProperty(array, '__array_observer__', {
          value: ModifyArrayObserver.create(taskQueue, array),
          enumerable: false, configurable: false
        });
      }
      return array.__array_observer__;
    };

    ModifyArrayObserver.create = function create(taskQueue, array) {
      return new ModifyArrayObserver(taskQueue, array);
    };

    return ModifyArrayObserver;
  }(ModifyCollectionObserver);

  var Expression = exports.Expression = function () {
    function Expression() {
      

      this.isChain = false;
      this.isAssignable = false;
    }

    Expression.prototype.evaluate = function evaluate(scope, lookupFunctions, args) {
      throw new Error('Binding expression "' + this + '" cannot be evaluated.');
    };

    Expression.prototype.assign = function assign(scope, value, lookupFunctions) {
      throw new Error('Binding expression "' + this + '" cannot be assigned to.');
    };

    Expression.prototype.toString = function toString() {
      return typeof FEATURE_NO_UNPARSER === 'undefined' ? _Unparser.unparse(this) : Function.prototype.toString.call(this);
    };

    return Expression;
  }();

  var Chain = exports.Chain = function (_Expression) {
    _inherits(Chain, _Expression);

    function Chain(expressions) {
      

      var _this3 = _possibleConstructorReturn(this, _Expression.call(this));

      _this3.expressions = expressions;
      _this3.isChain = true;
      return _this3;
    }

    Chain.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var result = void 0;
      var expressions = this.expressions;
      var last = void 0;

      for (var _i7 = 0, length = expressions.length; _i7 < length; ++_i7) {
        last = expressions[_i7].evaluate(scope, lookupFunctions);

        if (last !== null) {
          result = last;
        }
      }

      return result;
    };

    Chain.prototype.accept = function accept(visitor) {
      return visitor.visitChain(this);
    };

    return Chain;
  }(Expression);

  var BindingBehavior = exports.BindingBehavior = function (_Expression2) {
    _inherits(BindingBehavior, _Expression2);

    function BindingBehavior(expression, name, args) {
      

      var _this4 = _possibleConstructorReturn(this, _Expression2.call(this));

      _this4.expression = expression;
      _this4.name = name;
      _this4.args = args;
      return _this4;
    }

    BindingBehavior.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.expression.evaluate(scope, lookupFunctions);
    };

    BindingBehavior.prototype.assign = function assign(scope, value, lookupFunctions) {
      return this.expression.assign(scope, value, lookupFunctions);
    };

    BindingBehavior.prototype.accept = function accept(visitor) {
      return visitor.visitBindingBehavior(this);
    };

    BindingBehavior.prototype.connect = function connect(binding, scope) {
      this.expression.connect(binding, scope);
    };

    BindingBehavior.prototype.bind = function bind(binding, scope, lookupFunctions) {
      if (this.expression.expression && this.expression.bind) {
        this.expression.bind(binding, scope, lookupFunctions);
      }
      var behavior = lookupFunctions.bindingBehaviors(this.name);
      if (!behavior) {
        throw new Error('No BindingBehavior named "' + this.name + '" was found!');
      }
      var behaviorKey = 'behavior-' + this.name;
      if (binding[behaviorKey]) {
        throw new Error('A binding behavior named "' + this.name + '" has already been applied to "' + this.expression + '"');
      }
      binding[behaviorKey] = behavior;
      behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
    };

    BindingBehavior.prototype.unbind = function unbind(binding, scope) {
      var behaviorKey = 'behavior-' + this.name;
      binding[behaviorKey].unbind(binding, scope);
      binding[behaviorKey] = null;
      if (this.expression.expression && this.expression.unbind) {
        this.expression.unbind(binding, scope);
      }
    };

    return BindingBehavior;
  }(Expression);

  var ValueConverter = exports.ValueConverter = function (_Expression3) {
    _inherits(ValueConverter, _Expression3);

    function ValueConverter(expression, name, args, allArgs) {
      

      var _this5 = _possibleConstructorReturn(this, _Expression3.call(this));

      _this5.expression = expression;
      _this5.name = name;
      _this5.args = args;
      _this5.allArgs = allArgs;
      return _this5;
    }

    ValueConverter.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var converter = lookupFunctions.valueConverters(this.name);
      if (!converter) {
        throw new Error('No ValueConverter named "' + this.name + '" was found!');
      }

      if ('toView' in converter) {
        return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
      }

      return this.allArgs[0].evaluate(scope, lookupFunctions);
    };

    ValueConverter.prototype.assign = function assign(scope, value, lookupFunctions) {
      var converter = lookupFunctions.valueConverters(this.name);
      if (!converter) {
        throw new Error('No ValueConverter named "' + this.name + '" was found!');
      }

      if ('fromView' in converter) {
        value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
      }

      return this.allArgs[0].assign(scope, value, lookupFunctions);
    };

    ValueConverter.prototype.accept = function accept(visitor) {
      return visitor.visitValueConverter(this);
    };

    ValueConverter.prototype.connect = function connect(binding, scope) {
      var expressions = this.allArgs;
      var i = expressions.length;
      while (i--) {
        expressions[i].connect(binding, scope);
      }
      var converter = binding.lookupFunctions.valueConverters(this.name);
      if (!converter) {
        throw new Error('No ValueConverter named "' + this.name + '" was found!');
      }
      var signals = converter.signals;
      if (signals === undefined) {
        return;
      }
      i = signals.length;
      while (i--) {
        connectBindingToSignal(binding, signals[i]);
      }
    };

    return ValueConverter;
  }(Expression);

  var Assign = exports.Assign = function (_Expression4) {
    _inherits(Assign, _Expression4);

    function Assign(target, value) {
      

      var _this6 = _possibleConstructorReturn(this, _Expression4.call(this));

      _this6.target = target;
      _this6.value = value;
      _this6.isAssignable = true;
      return _this6;
    }

    Assign.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
    };

    Assign.prototype.accept = function accept(vistor) {
      vistor.visitAssign(this);
    };

    Assign.prototype.connect = function connect(binding, scope) {};

    Assign.prototype.assign = function assign(scope, value) {
      this.value.assign(scope, value);
      this.target.assign(scope, value);
    };

    return Assign;
  }(Expression);

  var Conditional = exports.Conditional = function (_Expression5) {
    _inherits(Conditional, _Expression5);

    function Conditional(condition, yes, no) {
      

      var _this7 = _possibleConstructorReturn(this, _Expression5.call(this));

      _this7.condition = condition;
      _this7.yes = yes;
      _this7.no = no;
      return _this7;
    }

    Conditional.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return !!this.condition.evaluate(scope, lookupFunctions) ? this.yes.evaluate(scope, lookupFunctions) : this.no.evaluate(scope, lookupFunctions);
    };

    Conditional.prototype.accept = function accept(visitor) {
      return visitor.visitConditional(this);
    };

    Conditional.prototype.connect = function connect(binding, scope) {
      this.condition.connect(binding, scope);
      if (this.condition.evaluate(scope)) {
        this.yes.connect(binding, scope);
      } else {
        this.no.connect(binding, scope);
      }
    };

    return Conditional;
  }(Expression);

  var AccessThis = exports.AccessThis = function (_Expression6) {
    _inherits(AccessThis, _Expression6);

    function AccessThis(ancestor) {
      

      var _this8 = _possibleConstructorReturn(this, _Expression6.call(this));

      _this8.ancestor = ancestor;
      return _this8;
    }

    AccessThis.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var oc = scope.overrideContext;
      var i = this.ancestor;
      while (i-- && oc) {
        oc = oc.parentOverrideContext;
      }
      return i < 1 && oc ? oc.bindingContext : undefined;
    };

    AccessThis.prototype.accept = function accept(visitor) {
      return visitor.visitAccessThis(this);
    };

    AccessThis.prototype.connect = function connect(binding, scope) {};

    return AccessThis;
  }(Expression);

  var AccessScope = exports.AccessScope = function (_Expression7) {
    _inherits(AccessScope, _Expression7);

    function AccessScope(name, ancestor) {
      

      var _this9 = _possibleConstructorReturn(this, _Expression7.call(this));

      _this9.name = name;
      _this9.ancestor = ancestor;
      _this9.isAssignable = true;
      return _this9;
    }

    AccessScope.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var context = getContextFor(this.name, scope, this.ancestor);
      return context[this.name];
    };

    AccessScope.prototype.assign = function assign(scope, value) {
      var context = getContextFor(this.name, scope, this.ancestor);
      return context ? context[this.name] = value : undefined;
    };

    AccessScope.prototype.accept = function accept(visitor) {
      return visitor.visitAccessScope(this);
    };

    AccessScope.prototype.connect = function connect(binding, scope) {
      var context = getContextFor(this.name, scope, this.ancestor);
      binding.observeProperty(context, this.name);
    };

    return AccessScope;
  }(Expression);

  var AccessMember = exports.AccessMember = function (_Expression8) {
    _inherits(AccessMember, _Expression8);

    function AccessMember(object, name) {
      

      var _this10 = _possibleConstructorReturn(this, _Expression8.call(this));

      _this10.object = object;
      _this10.name = name;
      _this10.isAssignable = true;
      return _this10;
    }

    AccessMember.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      return instance === null || instance === undefined ? instance : instance[this.name];
    };

    AccessMember.prototype.assign = function assign(scope, value) {
      var instance = this.object.evaluate(scope);

      if (instance === null || instance === undefined) {
        instance = {};
        this.object.assign(scope, instance);
      }

      instance[this.name] = value;
      return value;
    };

    AccessMember.prototype.accept = function accept(visitor) {
      return visitor.visitAccessMember(this);
    };

    AccessMember.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (obj) {
        binding.observeProperty(obj, this.name);
      }
    };

    return AccessMember;
  }(Expression);

  var AccessKeyed = exports.AccessKeyed = function (_Expression9) {
    _inherits(AccessKeyed, _Expression9);

    function AccessKeyed(object, key) {
      

      var _this11 = _possibleConstructorReturn(this, _Expression9.call(this));

      _this11.object = object;
      _this11.key = key;
      _this11.isAssignable = true;
      return _this11;
    }

    AccessKeyed.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      var lookup = this.key.evaluate(scope, lookupFunctions);
      return getKeyed(instance, lookup);
    };

    AccessKeyed.prototype.assign = function assign(scope, value) {
      var instance = this.object.evaluate(scope);
      var lookup = this.key.evaluate(scope);
      return setKeyed(instance, lookup, value);
    };

    AccessKeyed.prototype.accept = function accept(visitor) {
      return visitor.visitAccessKeyed(this);
    };

    AccessKeyed.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (obj instanceof Object) {
        this.key.connect(binding, scope);
        var key = this.key.evaluate(scope);

        if (key !== null && key !== undefined && !(Array.isArray(obj) && typeof key === 'number')) {
          binding.observeProperty(obj, key);
        }
      }
    };

    return AccessKeyed;
  }(Expression);

  var CallScope = exports.CallScope = function (_Expression10) {
    _inherits(CallScope, _Expression10);

    function CallScope(name, args, ancestor) {
      

      var _this12 = _possibleConstructorReturn(this, _Expression10.call(this));

      _this12.name = name;
      _this12.args = args;
      _this12.ancestor = ancestor;
      return _this12;
    }

    CallScope.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var args = evalList(scope, this.args, lookupFunctions);
      var context = getContextFor(this.name, scope, this.ancestor);
      var func = getFunction(context, this.name, mustEvaluate);
      if (func) {
        return func.apply(context, args);
      }
      return undefined;
    };

    CallScope.prototype.accept = function accept(visitor) {
      return visitor.visitCallScope(this);
    };

    CallScope.prototype.connect = function connect(binding, scope) {
      var args = this.args;
      var i = args.length;
      while (i--) {
        args[i].connect(binding, scope);
      }
    };

    return CallScope;
  }(Expression);

  var CallMember = exports.CallMember = function (_Expression11) {
    _inherits(CallMember, _Expression11);

    function CallMember(object, name, args) {
      

      var _this13 = _possibleConstructorReturn(this, _Expression11.call(this));

      _this13.object = object;
      _this13.name = name;
      _this13.args = args;
      return _this13;
    }

    CallMember.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      var args = evalList(scope, this.args, lookupFunctions);
      var func = getFunction(instance, this.name, mustEvaluate);
      if (func) {
        return func.apply(instance, args);
      }
      return undefined;
    };

    CallMember.prototype.accept = function accept(visitor) {
      return visitor.visitCallMember(this);
    };

    CallMember.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (getFunction(obj, this.name, false)) {
        var args = this.args;
        var _i8 = args.length;
        while (_i8--) {
          args[_i8].connect(binding, scope);
        }
      }
    };

    return CallMember;
  }(Expression);

  var CallFunction = exports.CallFunction = function (_Expression12) {
    _inherits(CallFunction, _Expression12);

    function CallFunction(func, args) {
      

      var _this14 = _possibleConstructorReturn(this, _Expression12.call(this));

      _this14.func = func;
      _this14.args = args;
      return _this14;
    }

    CallFunction.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var func = this.func.evaluate(scope, lookupFunctions);
      if (typeof func === 'function') {
        return func.apply(null, evalList(scope, this.args, lookupFunctions));
      }
      if (!mustEvaluate && (func === null || func === undefined)) {
        return undefined;
      }
      throw new Error(this.func + ' is not a function');
    };

    CallFunction.prototype.accept = function accept(visitor) {
      return visitor.visitCallFunction(this);
    };

    CallFunction.prototype.connect = function connect(binding, scope) {
      this.func.connect(binding, scope);
      var func = this.func.evaluate(scope);
      if (typeof func === 'function') {
        var args = this.args;
        var _i9 = args.length;
        while (_i9--) {
          args[_i9].connect(binding, scope);
        }
      }
    };

    return CallFunction;
  }(Expression);

  var Binary = exports.Binary = function (_Expression13) {
    _inherits(Binary, _Expression13);

    function Binary(operation, left, right) {
      

      var _this15 = _possibleConstructorReturn(this, _Expression13.call(this));

      _this15.operation = operation;
      _this15.left = left;
      _this15.right = right;
      return _this15;
    }

    Binary.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var left = this.left.evaluate(scope, lookupFunctions);

      switch (this.operation) {
        case '&&':
          return left && this.right.evaluate(scope, lookupFunctions);
        case '||':
          return left || this.right.evaluate(scope, lookupFunctions);
      }

      var right = this.right.evaluate(scope, lookupFunctions);

      switch (this.operation) {
        case '==':
          return left == right;
        case '===':
          return left === right;
        case '!=':
          return left != right;
        case '!==':
          return left !== right;
      }

      if (left === null || right === null || left === undefined || right === undefined) {
        switch (this.operation) {
          case '+':
            if (left !== null && left !== undefined) return left;
            if (right !== null && right !== undefined) return right;
            return 0;
          case '-':
            if (left !== null && left !== undefined) return left;
            if (right !== null && right !== undefined) return 0 - right;
            return 0;
        }

        return null;
      }

      switch (this.operation) {
        case '+':
          return autoConvertAdd(left, right);
        case '-':
          return left - right;
        case '*':
          return left * right;
        case '/':
          return left / right;
        case '%':
          return left % right;
        case '<':
          return left < right;
        case '>':
          return left > right;
        case '<=':
          return left <= right;
        case '>=':
          return left >= right;
        case '^':
          return left ^ right;
      }

      throw new Error('Internal error [' + this.operation + '] not handled');
    };

    Binary.prototype.accept = function accept(visitor) {
      return visitor.visitBinary(this);
    };

    Binary.prototype.connect = function connect(binding, scope) {
      this.left.connect(binding, scope);
      var left = this.left.evaluate(scope);
      if (this.operation === '&&' && !left || this.operation === '||' && left) {
        return;
      }
      this.right.connect(binding, scope);
    };

    return Binary;
  }(Expression);

  var PrefixNot = exports.PrefixNot = function (_Expression14) {
    _inherits(PrefixNot, _Expression14);

    function PrefixNot(operation, expression) {
      

      var _this16 = _possibleConstructorReturn(this, _Expression14.call(this));

      _this16.operation = operation;
      _this16.expression = expression;
      return _this16;
    }

    PrefixNot.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return !this.expression.evaluate(scope, lookupFunctions);
    };

    PrefixNot.prototype.accept = function accept(visitor) {
      return visitor.visitPrefix(this);
    };

    PrefixNot.prototype.connect = function connect(binding, scope) {
      this.expression.connect(binding, scope);
    };

    return PrefixNot;
  }(Expression);

  var LiteralPrimitive = exports.LiteralPrimitive = function (_Expression15) {
    _inherits(LiteralPrimitive, _Expression15);

    function LiteralPrimitive(value) {
      

      var _this17 = _possibleConstructorReturn(this, _Expression15.call(this));

      _this17.value = value;
      return _this17;
    }

    LiteralPrimitive.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.value;
    };

    LiteralPrimitive.prototype.accept = function accept(visitor) {
      return visitor.visitLiteralPrimitive(this);
    };

    LiteralPrimitive.prototype.connect = function connect(binding, scope) {};

    return LiteralPrimitive;
  }(Expression);

  var LiteralString = exports.LiteralString = function (_Expression16) {
    _inherits(LiteralString, _Expression16);

    function LiteralString(value) {
      

      var _this18 = _possibleConstructorReturn(this, _Expression16.call(this));

      _this18.value = value;
      return _this18;
    }

    LiteralString.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.value;
    };

    LiteralString.prototype.accept = function accept(visitor) {
      return visitor.visitLiteralString(this);
    };

    LiteralString.prototype.connect = function connect(binding, scope) {};

    return LiteralString;
  }(Expression);

  var LiteralArray = exports.LiteralArray = function (_Expression17) {
    _inherits(LiteralArray, _Expression17);

    function LiteralArray(elements) {
      

      var _this19 = _possibleConstructorReturn(this, _Expression17.call(this));

      _this19.elements = elements;
      return _this19;
    }

    LiteralArray.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var elements = this.elements;
      var result = [];

      for (var _i10 = 0, length = elements.length; _i10 < length; ++_i10) {
        result[_i10] = elements[_i10].evaluate(scope, lookupFunctions);
      }

      return result;
    };

    LiteralArray.prototype.accept = function accept(visitor) {
      return visitor.visitLiteralArray(this);
    };

    LiteralArray.prototype.connect = function connect(binding, scope) {
      var length = this.elements.length;
      for (var _i11 = 0; _i11 < length; _i11++) {
        this.elements[_i11].connect(binding, scope);
      }
    };

    return LiteralArray;
  }(Expression);

  var LiteralObject = exports.LiteralObject = function (_Expression18) {
    _inherits(LiteralObject, _Expression18);

    function LiteralObject(keys, values) {
      

      var _this20 = _possibleConstructorReturn(this, _Expression18.call(this));

      _this20.keys = keys;
      _this20.values = values;
      return _this20;
    }

    LiteralObject.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = {};
      var keys = this.keys;
      var values = this.values;

      for (var _i12 = 0, length = keys.length; _i12 < length; ++_i12) {
        instance[keys[_i12]] = values[_i12].evaluate(scope, lookupFunctions);
      }

      return instance;
    };

    LiteralObject.prototype.accept = function accept(visitor) {
      return visitor.visitLiteralObject(this);
    };

    LiteralObject.prototype.connect = function connect(binding, scope) {
      var length = this.keys.length;
      for (var _i13 = 0; _i13 < length; _i13++) {
        this.values[_i13].connect(binding, scope);
      }
    };

    return LiteralObject;
  }(Expression);

  function evalList(scope, list, lookupFunctions) {
    var length = list.length;
    var result = [];
    for (var _i14 = 0; _i14 < length; _i14++) {
      result[_i14] = list[_i14].evaluate(scope, lookupFunctions);
    }
    return result;
  }

  function autoConvertAdd(a, b) {
    if (a !== null && b !== null) {
      if (typeof a === 'string' && typeof b !== 'string') {
        return a + b.toString();
      }

      if (typeof a !== 'string' && typeof b === 'string') {
        return a.toString() + b;
      }

      return a + b;
    }

    if (a !== null) {
      return a;
    }

    if (b !== null) {
      return b;
    }

    return 0;
  }

  function getFunction(obj, name, mustExist) {
    var func = obj === null || obj === undefined ? null : obj[name];
    if (typeof func === 'function') {
      return func;
    }
    if (!mustExist && (func === null || func === undefined)) {
      return null;
    }
    throw new Error(name + ' is not a function');
  }

  function getKeyed(obj, key) {
    if (Array.isArray(obj)) {
      return obj[parseInt(key, 10)];
    } else if (obj) {
      return obj[key];
    } else if (obj === null || obj === undefined) {
      return undefined;
    }

    return obj[key];
  }

  function setKeyed(obj, key, value) {
    if (Array.isArray(obj)) {
      var index = parseInt(key, 10);

      if (obj.length <= index) {
        obj.length = index + 1;
      }

      obj[index] = value;
    } else {
      obj[key] = value;
    }

    return value;
  }

  var _Unparser = null;

  exports.Unparser = _Unparser;
  if (typeof FEATURE_NO_UNPARSER === 'undefined') {
    exports.Unparser = _Unparser = function () {
      function Unparser(buffer) {
        

        this.buffer = buffer;
      }

      Unparser.unparse = function unparse(expression) {
        var buffer = [];
        var visitor = new _Unparser(buffer);

        expression.accept(visitor);

        return buffer.join('');
      };

      Unparser.prototype.write = function write(text) {
        this.buffer.push(text);
      };

      Unparser.prototype.writeArgs = function writeArgs(args) {
        this.write('(');

        for (var _i15 = 0, length = args.length; _i15 < length; ++_i15) {
          if (_i15 !== 0) {
            this.write(',');
          }

          args[_i15].accept(this);
        }

        this.write(')');
      };

      Unparser.prototype.visitChain = function visitChain(chain) {
        var expressions = chain.expressions;

        for (var _i16 = 0, length = expression.length; _i16 < length; ++_i16) {
          if (_i16 !== 0) {
            this.write(';');
          }

          expressions[_i16].accept(this);
        }
      };

      Unparser.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
        var args = behavior.args;

        behavior.expression.accept(this);
        this.write('&' + behavior.name);

        for (var _i17 = 0, length = args.length; _i17 < length; ++_i17) {
          this.write(':');
          args[_i17].accept(this);
        }
      };

      Unparser.prototype.visitValueConverter = function visitValueConverter(converter) {
        var args = converter.args;

        converter.expression.accept(this);
        this.write('|' + converter.name);

        for (var _i18 = 0, length = args.length; _i18 < length; ++_i18) {
          this.write(':');
          args[_i18].accept(this);
        }
      };

      Unparser.prototype.visitAssign = function visitAssign(assign) {
        assign.target.accept(this);
        this.write('=');
        assign.value.accept(this);
      };

      Unparser.prototype.visitConditional = function visitConditional(conditional) {
        conditional.condition.accept(this);
        this.write('?');
        conditional.yes.accept(this);
        this.write(':');
        conditional.no.accept(this);
      };

      Unparser.prototype.visitAccessThis = function visitAccessThis(access) {
        if (access.ancestor === 0) {
          this.write('$this');
          return;
        }
        this.write('$parent');
        var i = access.ancestor - 1;
        while (i--) {
          this.write('.$parent');
        }
      };

      Unparser.prototype.visitAccessScope = function visitAccessScope(access) {
        var i = access.ancestor;
        while (i--) {
          this.write('$parent.');
        }
        this.write(access.name);
      };

      Unparser.prototype.visitAccessMember = function visitAccessMember(access) {
        access.object.accept(this);
        this.write('.' + access.name);
      };

      Unparser.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
        access.object.accept(this);
        this.write('[');
        access.key.accept(this);
        this.write(']');
      };

      Unparser.prototype.visitCallScope = function visitCallScope(call) {
        var i = call.ancestor;
        while (i--) {
          this.write('$parent.');
        }
        this.write(call.name);
        this.writeArgs(call.args);
      };

      Unparser.prototype.visitCallFunction = function visitCallFunction(call) {
        call.func.accept(this);
        this.writeArgs(call.args);
      };

      Unparser.prototype.visitCallMember = function visitCallMember(call) {
        call.object.accept(this);
        this.write('.' + call.name);
        this.writeArgs(call.args);
      };

      Unparser.prototype.visitPrefix = function visitPrefix(prefix) {
        this.write('(' + prefix.operation);
        prefix.expression.accept(this);
        this.write(')');
      };

      Unparser.prototype.visitBinary = function visitBinary(binary) {
        binary.left.accept(this);
        this.write(binary.operation);
        binary.right.accept(this);
      };

      Unparser.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
        this.write('' + literal.value);
      };

      Unparser.prototype.visitLiteralArray = function visitLiteralArray(literal) {
        var elements = literal.elements;

        this.write('[');

        for (var _i19 = 0, length = elements.length; _i19 < length; ++_i19) {
          if (_i19 !== 0) {
            this.write(',');
          }

          elements[_i19].accept(this);
        }

        this.write(']');
      };

      Unparser.prototype.visitLiteralObject = function visitLiteralObject(literal) {
        var keys = literal.keys;
        var values = literal.values;

        this.write('{');

        for (var _i20 = 0, length = keys.length; _i20 < length; ++_i20) {
          if (_i20 !== 0) {
            this.write(',');
          }

          this.write('\'' + keys[_i20] + '\':');
          values[_i20].accept(this);
        }

        this.write('}');
      };

      Unparser.prototype.visitLiteralString = function visitLiteralString(literal) {
        var escaped = literal.value.replace(/'/g, "\'");
        this.write('\'' + escaped + '\'');
      };

      return Unparser;
    }();
  }

  var ExpressionCloner = exports.ExpressionCloner = function () {
    function ExpressionCloner() {
      
    }

    ExpressionCloner.prototype.cloneExpressionArray = function cloneExpressionArray(array) {
      var clonedArray = [];
      var i = array.length;
      while (i--) {
        clonedArray[i] = array[i].accept(this);
      }
      return clonedArray;
    };

    ExpressionCloner.prototype.visitChain = function visitChain(chain) {
      return new Chain(this.cloneExpressionArray(chain.expressions));
    };

    ExpressionCloner.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
      return new BindingBehavior(behavior.expression.accept(this), behavior.name, this.cloneExpressionArray(behavior.args));
    };

    ExpressionCloner.prototype.visitValueConverter = function visitValueConverter(converter) {
      return new ValueConverter(converter.expression.accept(this), converter.name, this.cloneExpressionArray(converter.args));
    };

    ExpressionCloner.prototype.visitAssign = function visitAssign(assign) {
      return new Assign(assign.target.accept(this), assign.value.accept(this));
    };

    ExpressionCloner.prototype.visitConditional = function visitConditional(conditional) {
      return new Conditional(conditional.condition.accept(this), conditional.yes.accept(this), conditional.no.accept(this));
    };

    ExpressionCloner.prototype.visitAccessThis = function visitAccessThis(access) {
      return new AccessThis(access.ancestor);
    };

    ExpressionCloner.prototype.visitAccessScope = function visitAccessScope(access) {
      return new AccessScope(access.name, access.ancestor);
    };

    ExpressionCloner.prototype.visitAccessMember = function visitAccessMember(access) {
      return new AccessMember(access.object.accept(this), access.name);
    };

    ExpressionCloner.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
      return new AccessKeyed(access.object.accept(this), access.key.accept(this));
    };

    ExpressionCloner.prototype.visitCallScope = function visitCallScope(call) {
      return new CallScope(call.name, this.cloneExpressionArray(call.args), call.ancestor);
    };

    ExpressionCloner.prototype.visitCallFunction = function visitCallFunction(call) {
      return new CallFunction(call.func.accept(this), this.cloneExpressionArray(call.args));
    };

    ExpressionCloner.prototype.visitCallMember = function visitCallMember(call) {
      return new CallMember(call.object.accept(this), call.name, this.cloneExpressionArray(call.args));
    };

    ExpressionCloner.prototype.visitPrefix = function visitPrefix(prefix) {
      return new PrefixNot(prefix.operation, prefix.expression.accept(this));
    };

    ExpressionCloner.prototype.visitBinary = function visitBinary(binary) {
      return new Binary(binary.operation, binary.left.accept(this), binary.right.accept(this));
    };

    ExpressionCloner.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
      return new LiteralPrimitive(literal);
    };

    ExpressionCloner.prototype.visitLiteralArray = function visitLiteralArray(literal) {
      return new LiteralArray(this.cloneExpressionArray(literal.elements));
    };

    ExpressionCloner.prototype.visitLiteralObject = function visitLiteralObject(literal) {
      return new LiteralObject(literal.keys, this.cloneExpressionArray(literal.values));
    };

    ExpressionCloner.prototype.visitLiteralString = function visitLiteralString(literal) {
      return new LiteralString(literal.value);
    };

    return ExpressionCloner;
  }();

  function cloneExpression(expression) {
    var visitor = new ExpressionCloner();
    return expression.accept(visitor);
  }

  var bindingMode = exports.bindingMode = {
    oneTime: 0,
    toView: 1,
    oneWay: 1,
    twoWay: 2,
    fromView: 3
  };

  var Token = exports.Token = function () {
    function Token(index, text) {
      

      this.index = index;
      this.text = text;
    }

    Token.prototype.withOp = function withOp(op) {
      this.opKey = op;
      return this;
    };

    Token.prototype.withGetterSetter = function withGetterSetter(key) {
      this.key = key;
      return this;
    };

    Token.prototype.withValue = function withValue(value) {
      this.value = value;
      return this;
    };

    Token.prototype.toString = function toString() {
      return 'Token(' + this.text + ')';
    };

    return Token;
  }();

  var Lexer = exports.Lexer = function () {
    function Lexer() {
      
    }

    Lexer.prototype.lex = function lex(text) {
      var scanner = new Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();

      while (token) {
        tokens.push(token);
        token = scanner.scanToken();
      }

      return tokens;
    };

    return Lexer;
  }();

  var Scanner = exports.Scanner = function () {
    function Scanner(input) {
      

      this.input = input;
      this.length = input.length;
      this.peek = 0;
      this.index = -1;

      this.advance();
    }

    Scanner.prototype.scanToken = function scanToken() {
      while (this.peek <= $SPACE) {
        if (++this.index >= this.length) {
          this.peek = $EOF;
          return null;
        }

        this.peek = this.input.charCodeAt(this.index);
      }

      if (isIdentifierStart(this.peek)) {
        return this.scanIdentifier();
      }

      if (isDigit(this.peek)) {
        return this.scanNumber(this.index);
      }

      var start = this.index;

      switch (this.peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, String.fromCharCode(this.peek));
        case $SQ:
        case $DQ:
          return this.scanString();
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
        case $QUESTION:
          return this.scanOperator(start, String.fromCharCode(this.peek));
        case $LT:
        case $GT:
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');
        case $AMPERSAND:
          return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
        case $BAR:
          return this.scanComplexOperator(start, $BAR, '|', '|');
        case $NBSP:
          while (isWhitespace(this.peek)) {
            this.advance();
          }

          return this.scanToken();
      }

      var character = String.fromCharCode(this.peek);
      this.error('Unexpected character [' + character + ']');
      return null;
    };

    Scanner.prototype.scanCharacter = function scanCharacter(start, text) {
      assert(this.peek === text.charCodeAt(0));
      this.advance();
      return new Token(start, text);
    };

    Scanner.prototype.scanOperator = function scanOperator(start, text) {
      assert(this.peek === text.charCodeAt(0));
      assert(OPERATORS[text] === 1);
      this.advance();
      return new Token(start, text).withOp(text);
    };

    Scanner.prototype.scanComplexOperator = function scanComplexOperator(start, code, one, two) {
      assert(this.peek === one.charCodeAt(0));
      this.advance();

      var text = one;

      if (this.peek === code) {
        this.advance();
        text += two;
      }

      if (this.peek === code) {
        this.advance();
        text += two;
      }

      assert(OPERATORS[text] === 1);

      return new Token(start, text).withOp(text);
    };

    Scanner.prototype.scanIdentifier = function scanIdentifier() {
      assert(isIdentifierStart(this.peek));
      var start = this.index;

      this.advance();

      while (isIdentifierPart(this.peek)) {
        this.advance();
      }

      var text = this.input.substring(start, this.index);
      var result = new Token(start, text);

      if (OPERATORS[text] === 1) {
        result.withOp(text);
      } else {
        result.withGetterSetter(text);
      }

      return result;
    };

    Scanner.prototype.scanNumber = function scanNumber(start) {
      assert(isDigit(this.peek));
      var simple = this.index === start;
      this.advance();

      while (true) {
        if (!isDigit(this.peek)) {
          if (this.peek === $PERIOD) {
            simple = false;
          } else if (isExponentStart(this.peek)) {
            this.advance();

            if (isExponentSign(this.peek)) {
              this.advance();
            }

            if (!isDigit(this.peek)) {
              this.error('Invalid exponent', -1);
            }

            simple = false;
          } else {
            break;
          }
        }

        this.advance();
      }

      var text = this.input.substring(start, this.index);
      var value = simple ? parseInt(text, 10) : parseFloat(text);
      return new Token(start, text).withValue(value);
    };

    Scanner.prototype.scanString = function scanString() {
      assert(this.peek === $SQ || this.peek === $DQ);

      var start = this.index;
      var quote = this.peek;

      this.advance();

      var buffer = void 0;
      var marker = this.index;

      while (this.peek !== quote) {
        if (this.peek === $BACKSLASH) {
          if (!buffer) {
            buffer = [];
          }

          buffer.push(this.input.substring(marker, this.index));
          this.advance();

          var _unescaped = void 0;

          if (this.peek === $u) {
            var hex = this.input.substring(this.index + 1, this.index + 5);

            if (!/[A-Z0-9]{4}/.test(hex)) {
              this.error('Invalid unicode escape [\\u' + hex + ']');
            }

            _unescaped = parseInt(hex, 16);

            for (var _i21 = 0; _i21 < 5; ++_i21) {
              this.advance();
            }
          } else {
            _unescaped = unescape(this.peek);
            this.advance();
          }

          buffer.push(String.fromCharCode(_unescaped));
          marker = this.index;
        } else if (this.peek === $EOF) {
          this.error('Unterminated quote');
        } else {
          this.advance();
        }
      }

      var last = this.input.substring(marker, this.index);
      this.advance();
      var text = this.input.substring(start, this.index);

      var unescaped = last;

      if (buffer !== null && buffer !== undefined) {
        buffer.push(last);
        unescaped = buffer.join('');
      }

      return new Token(start, text).withValue(unescaped);
    };

    Scanner.prototype.advance = function advance() {
      if (++this.index >= this.length) {
        this.peek = $EOF;
      } else {
        this.peek = this.input.charCodeAt(this.index);
      }
    };

    Scanner.prototype.error = function error(message) {
      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

      var position = this.index + offset;
      throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
    };

    return Scanner;
  }();

  var OPERATORS = {
    'undefined': 1,
    'null': 1,
    'true': 1,
    'false': 1,
    '+': 1,
    '-': 1,
    '*': 1,
    '/': 1,
    '%': 1,
    '^': 1,
    '=': 1,
    '==': 1,
    '===': 1,
    '!=': 1,
    '!==': 1,
    '<': 1,
    '>': 1,
    '<=': 1,
    '>=': 1,
    '&&': 1,
    '||': 1,
    '&': 1,
    '|': 1,
    '!': 1,
    '?': 1
  };

  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;

  var $0 = 48;
  var $9 = 57;

  var $A = 65;
  var $E = 69;
  var $Z = 90;

  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;

  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $z = 122;

  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;

  function isWhitespace(code) {
    return code >= $TAB && code <= $SPACE || code === $NBSP;
  }

  function isIdentifierStart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || code === $_ || code === $$;
  }

  function isIdentifierPart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code === $_ || code === $$;
  }

  function isDigit(code) {
    return $0 <= code && code <= $9;
  }

  function isExponentStart(code) {
    return code === $e || code === $E;
  }

  function isExponentSign(code) {
    return code === $MINUS || code === $PLUS;
  }

  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }

  function assert(condition, message) {
    if (!condition) {
      throw message || 'Assertion failed';
    }
  }

  var EOF = new Token(-1, null);

  var Parser = exports.Parser = function () {
    function Parser() {
      

      this.cache = {};
      this.lexer = new Lexer();
    }

    Parser.prototype.parse = function parse(input) {
      input = input || '';

      return this.cache[input] || (this.cache[input] = new ParserImplementation(this.lexer, input).parseChain());
    };

    return Parser;
  }();

  var ParserImplementation = exports.ParserImplementation = function () {
    function ParserImplementation(lexer, input) {
      

      this.index = 0;
      this.input = input;
      this.tokens = lexer.lex(input);
    }

    ParserImplementation.prototype.parseChain = function parseChain() {
      var isChain = false;
      var expressions = [];

      while (this.optional(';')) {
        isChain = true;
      }

      while (this.index < this.tokens.length) {
        if (this.peek.text === ')' || this.peek.text === '}' || this.peek.text === ']') {
          this.error('Unconsumed token ' + this.peek.text);
        }

        var expr = this.parseBindingBehavior();
        expressions.push(expr);

        while (this.optional(';')) {
          isChain = true;
        }

        if (isChain) {
          this.error('Multiple expressions are not allowed.');
        }
      }

      return expressions.length === 1 ? expressions[0] : new Chain(expressions);
    };

    ParserImplementation.prototype.parseBindingBehavior = function parseBindingBehavior() {
      var result = this.parseValueConverter();

      while (this.optional('&')) {
        var name = this.peek.text;
        var args = [];

        this.advance();

        while (this.optional(':')) {
          args.push(this.parseExpression());
        }

        result = new BindingBehavior(result, name, args);
      }

      return result;
    };

    ParserImplementation.prototype.parseValueConverter = function parseValueConverter() {
      var result = this.parseExpression();

      while (this.optional('|')) {
        var name = this.peek.text;
        var args = [];

        this.advance();

        while (this.optional(':')) {
          args.push(this.parseExpression());
        }

        result = new ValueConverter(result, name, args, [result].concat(args));
      }

      return result;
    };

    ParserImplementation.prototype.parseExpression = function parseExpression() {
      var start = this.peek.index;
      var result = this.parseConditional();

      while (this.peek.text === '=') {
        if (!result.isAssignable) {
          var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
          var _expression = this.input.substring(start, end);

          this.error('Expression ' + _expression + ' is not assignable');
        }

        this.expect('=');
        result = new Assign(result, this.parseConditional());
      }

      return result;
    };

    ParserImplementation.prototype.parseConditional = function parseConditional() {
      var start = this.peek.index;
      var result = this.parseLogicalOr();

      if (this.optional('?')) {
        var yes = this.parseExpression();

        if (!this.optional(':')) {
          var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
          var _expression2 = this.input.substring(start, end);

          this.error('Conditional expression ' + _expression2 + ' requires all 3 expressions');
        }

        var no = this.parseExpression();
        result = new Conditional(result, yes, no);
      }

      return result;
    };

    ParserImplementation.prototype.parseLogicalOr = function parseLogicalOr() {
      var result = this.parseLogicalAnd();

      while (this.optional('||')) {
        result = new Binary('||', result, this.parseLogicalAnd());
      }

      return result;
    };

    ParserImplementation.prototype.parseLogicalAnd = function parseLogicalAnd() {
      var result = this.parseEquality();

      while (this.optional('&&')) {
        result = new Binary('&&', result, this.parseEquality());
      }

      return result;
    };

    ParserImplementation.prototype.parseEquality = function parseEquality() {
      var result = this.parseRelational();

      while (true) {
        if (this.optional('==')) {
          result = new Binary('==', result, this.parseRelational());
        } else if (this.optional('!=')) {
          result = new Binary('!=', result, this.parseRelational());
        } else if (this.optional('===')) {
          result = new Binary('===', result, this.parseRelational());
        } else if (this.optional('!==')) {
          result = new Binary('!==', result, this.parseRelational());
        } else {
          return result;
        }
      }
    };

    ParserImplementation.prototype.parseRelational = function parseRelational() {
      var result = this.parseAdditive();

      while (true) {
        if (this.optional('<')) {
          result = new Binary('<', result, this.parseAdditive());
        } else if (this.optional('>')) {
          result = new Binary('>', result, this.parseAdditive());
        } else if (this.optional('<=')) {
          result = new Binary('<=', result, this.parseAdditive());
        } else if (this.optional('>=')) {
          result = new Binary('>=', result, this.parseAdditive());
        } else {
          return result;
        }
      }
    };

    ParserImplementation.prototype.parseAdditive = function parseAdditive() {
      var result = this.parseMultiplicative();

      while (true) {
        if (this.optional('+')) {
          result = new Binary('+', result, this.parseMultiplicative());
        } else if (this.optional('-')) {
          result = new Binary('-', result, this.parseMultiplicative());
        } else {
          return result;
        }
      }
    };

    ParserImplementation.prototype.parseMultiplicative = function parseMultiplicative() {
      var result = this.parsePrefix();

      while (true) {
        if (this.optional('*')) {
          result = new Binary('*', result, this.parsePrefix());
        } else if (this.optional('%')) {
          result = new Binary('%', result, this.parsePrefix());
        } else if (this.optional('/')) {
          result = new Binary('/', result, this.parsePrefix());
        } else {
          return result;
        }
      }
    };

    ParserImplementation.prototype.parsePrefix = function parsePrefix() {
      if (this.optional('+')) {
        return this.parsePrefix();
      } else if (this.optional('-')) {
        return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
      } else if (this.optional('!')) {
        return new PrefixNot('!', this.parsePrefix());
      }

      return this.parseAccessOrCallMember();
    };

    ParserImplementation.prototype.parseAccessOrCallMember = function parseAccessOrCallMember() {
      var result = this.parsePrimary();

      while (true) {
        if (this.optional('.')) {
          var name = this.peek.text;

          this.advance();

          if (this.optional('(')) {
            var args = this.parseExpressionList(')');
            this.expect(')');
            if (result instanceof AccessThis) {
              result = new CallScope(name, args, result.ancestor);
            } else {
              result = new CallMember(result, name, args);
            }
          } else {
            if (result instanceof AccessThis) {
              result = new AccessScope(name, result.ancestor);
            } else {
              result = new AccessMember(result, name);
            }
          }
        } else if (this.optional('[')) {
          var key = this.parseExpression();
          this.expect(']');
          result = new AccessKeyed(result, key);
        } else if (this.optional('(')) {
          var _args = this.parseExpressionList(')');
          this.expect(')');
          result = new CallFunction(result, _args);
        } else {
          return result;
        }
      }
    };

    ParserImplementation.prototype.parsePrimary = function parsePrimary() {
      if (this.optional('(')) {
        var result = this.parseExpression();
        this.expect(')');
        return result;
      } else if (this.optional('null')) {
        return new LiteralPrimitive(null);
      } else if (this.optional('undefined')) {
        return new LiteralPrimitive(undefined);
      } else if (this.optional('true')) {
        return new LiteralPrimitive(true);
      } else if (this.optional('false')) {
        return new LiteralPrimitive(false);
      } else if (this.optional('[')) {
        var elements = this.parseExpressionList(']');
        this.expect(']');
        return new LiteralArray(elements);
      } else if (this.peek.text === '{') {
        return this.parseObject();
      } else if (this.peek.key !== null && this.peek.key !== undefined) {
        return this.parseAccessOrCallScope();
      } else if (this.peek.value !== null && this.peek.value !== undefined) {
        var value = this.peek.value;
        this.advance();
        return value instanceof String || typeof value === 'string' ? new LiteralString(value) : new LiteralPrimitive(value);
      } else if (this.index >= this.tokens.length) {
        throw new Error('Unexpected end of expression: ' + this.input);
      } else {
        this.error('Unexpected token ' + this.peek.text);
      }
    };

    ParserImplementation.prototype.parseAccessOrCallScope = function parseAccessOrCallScope() {
      var name = this.peek.key;

      this.advance();

      if (name === '$this') {
        return new AccessThis(0);
      }

      var ancestor = 0;
      while (name === '$parent') {
        ancestor++;
        if (this.optional('.')) {
          name = this.peek.key;
          this.advance();
        } else if (this.peek === EOF || this.peek.text === '(' || this.peek.text === ')' || this.peek.text === '[' || this.peek.text === '}' || this.peek.text === ',' || this.peek.text === '|' || this.peek.text === '&') {
          return new AccessThis(ancestor);
        } else {
          this.error('Unexpected token ' + this.peek.text);
        }
      }

      if (this.optional('(')) {
        var args = this.parseExpressionList(')');
        this.expect(')');
        return new CallScope(name, args, ancestor);
      }

      return new AccessScope(name, ancestor);
    };

    ParserImplementation.prototype.parseObject = function parseObject() {
      var keys = [];
      var values = [];

      this.expect('{');

      if (this.peek.text !== '}') {
        do {
          var peek = this.peek;
          var value = peek.value;
          keys.push(typeof value === 'string' ? value : peek.text);

          this.advance();
          if (peek.key && (this.peek.text === ',' || this.peek.text === '}')) {
            --this.index;
            values.push(this.parseAccessOrCallScope());
          } else {
            this.expect(':');
            values.push(this.parseExpression());
          }
        } while (this.optional(','));
      }

      this.expect('}');

      return new LiteralObject(keys, values);
    };

    ParserImplementation.prototype.parseExpressionList = function parseExpressionList(terminator) {
      var result = [];

      if (this.peek.text !== terminator) {
        do {
          result.push(this.parseExpression());
        } while (this.optional(','));
      }

      return result;
    };

    ParserImplementation.prototype.optional = function optional(text) {
      if (this.peek.text === text) {
        this.advance();
        return true;
      }

      return false;
    };

    ParserImplementation.prototype.expect = function expect(text) {
      if (this.peek.text === text) {
        this.advance();
      } else {
        this.error('Missing expected ' + text);
      }
    };

    ParserImplementation.prototype.advance = function advance() {
      this.index++;
    };

    ParserImplementation.prototype.error = function error(message) {
      var location = this.index < this.tokens.length ? 'at column ' + (this.tokens[this.index].index + 1) + ' in' : 'at the end of the expression';

      throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');
    };

    _createClass(ParserImplementation, [{
      key: 'peek',
      get: function get() {
        return this.index < this.tokens.length ? this.tokens[this.index] : EOF;
      }
    }]);

    return ParserImplementation;
  }();

  var mapProto = Map.prototype;

  function _getMapObserver(taskQueue, map) {
    return ModifyMapObserver.for(taskQueue, map);
  }

  exports.getMapObserver = _getMapObserver;

  var ModifyMapObserver = function (_ModifyCollectionObse2) {
    _inherits(ModifyMapObserver, _ModifyCollectionObse2);

    function ModifyMapObserver(taskQueue, map) {
      

      return _possibleConstructorReturn(this, _ModifyCollectionObse2.call(this, taskQueue, map));
    }

    ModifyMapObserver.for = function _for(taskQueue, map) {
      if (!('__map_observer__' in map)) {
        Reflect.defineProperty(map, '__map_observer__', {
          value: ModifyMapObserver.create(taskQueue, map),
          enumerable: false, configurable: false
        });
      }
      return map.__map_observer__;
    };

    ModifyMapObserver.create = function create(taskQueue, map) {
      var observer = new ModifyMapObserver(taskQueue, map);

      var proto = mapProto;
      if (proto.set !== map.set || proto.delete !== map.delete || proto.clear !== map.clear) {
        proto = {
          set: map.set,
          delete: map.delete,
          clear: map.clear
        };
      }

      map.set = function () {
        var hasValue = map.has(arguments[0]);
        var type = hasValue ? 'update' : 'add';
        var oldValue = map.get(arguments[0]);
        var methodCallResult = proto.set.apply(map, arguments);
        if (!hasValue || oldValue !== map.get(arguments[0])) {
          observer.addChangeRecord({
            type: type,
            object: map,
            key: arguments[0],
            oldValue: oldValue
          });
        }
        return methodCallResult;
      };

      map.delete = function () {
        var hasValue = map.has(arguments[0]);
        var oldValue = map.get(arguments[0]);
        var methodCallResult = proto.delete.apply(map, arguments);
        if (hasValue) {
          observer.addChangeRecord({
            type: 'delete',
            object: map,
            key: arguments[0],
            oldValue: oldValue
          });
        }
        return methodCallResult;
      };

      map.clear = function () {
        var methodCallResult = proto.clear.apply(map, arguments);
        observer.addChangeRecord({
          type: 'clear',
          object: map
        });
        return methodCallResult;
      };

      return observer;
    };

    return ModifyMapObserver;
  }(ModifyCollectionObserver);

  function findOriginalEventTarget(event) {
    return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
  }

  function stopPropagation() {
    this.standardStopPropagation();
    this.propagationStopped = true;
  }

  function interceptStopPropagation(event) {
    event.standardStopPropagation = event.stopPropagation;
    event.stopPropagation = stopPropagation;
  }

  function handleCapturedEvent(event) {
    var interceptInstalled = false;
    event.propagationStopped = false;
    var target = findOriginalEventTarget(event);

    var orderedCallbacks = [];

    while (target) {
      if (target.capturedCallbacks) {
        var callback = target.capturedCallbacks[event.type];
        if (callback) {
          if (!interceptInstalled) {
            interceptStopPropagation(event);
            interceptInstalled = true;
          }
          orderedCallbacks.push(callback);
        }
      }
      target = target.parentNode;
    }
    for (var _i22 = orderedCallbacks.length - 1; _i22 >= 0; _i22--) {
      var orderedCallback = orderedCallbacks[_i22];
      if ('handleEvent' in orderedCallback) {
        orderedCallback.handleEvent(event);
      } else {
        orderedCallback(event);
      }
      if (event.propagationStopped) {
        break;
      }
    }
  }

  var CapturedHandlerEntry = function () {
    function CapturedHandlerEntry(eventName) {
      

      this.eventName = eventName;
      this.count = 0;
    }

    CapturedHandlerEntry.prototype.increment = function increment() {
      this.count++;

      if (this.count === 1) {
        _aureliaPal.DOM.addEventListener(this.eventName, handleCapturedEvent, true);
      }
    };

    CapturedHandlerEntry.prototype.decrement = function decrement() {
      this.count--;

      if (this.count === 0) {
        _aureliaPal.DOM.removeEventListener(this.eventName, handleCapturedEvent, true);
      }
    };

    return CapturedHandlerEntry;
  }();

  function handleDelegatedEvent(event) {
    var interceptInstalled = false;
    event.propagationStopped = false;
    var target = findOriginalEventTarget(event);

    while (target && !event.propagationStopped) {
      if (target.delegatedCallbacks) {
        var callback = target.delegatedCallbacks[event.type];
        if (callback) {
          if (!interceptInstalled) {
            interceptStopPropagation(event);
            interceptInstalled = true;
          }
          if ('handleEvent' in callback) {
            callback.handleEvent(event);
          } else {
            callback(event);
          }
        }
      }

      target = target.parentNode;
    }
  }

  var DelegateHandlerEntry = function () {
    function DelegateHandlerEntry(eventName) {
      

      this.eventName = eventName;
      this.count = 0;
    }

    DelegateHandlerEntry.prototype.increment = function increment() {
      this.count++;

      if (this.count === 1) {
        _aureliaPal.DOM.addEventListener(this.eventName, handleDelegatedEvent, false);
      }
    };

    DelegateHandlerEntry.prototype.decrement = function decrement() {
      this.count--;

      if (this.count === 0) {
        _aureliaPal.DOM.removeEventListener(this.eventName, handleDelegatedEvent);
      }
    };

    return DelegateHandlerEntry;
  }();

  var DefaultEventStrategy = function () {
    function DefaultEventStrategy() {
      

      this.delegatedHandlers = {};
      this.capturedHandlers = {};
    }

    DefaultEventStrategy.prototype.subscribe = function subscribe(target, targetEvent, callback, strategy) {
      var _this22 = this;

      var delegatedHandlers = void 0;
      var capturedHandlers = void 0;
      var handlerEntry = void 0;

      if (strategy === delegationStrategy.bubbling) {
        var _ret = function () {
          delegatedHandlers = _this22.delegatedHandlers;
          handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent));
          var delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});

          handlerEntry.increment();
          delegatedCallbacks[targetEvent] = callback;

          return {
            v: function v() {
              handlerEntry.decrement();
              delegatedCallbacks[targetEvent] = null;
            }
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
      if (strategy === delegationStrategy.capturing) {
        var _ret2 = function () {
          capturedHandlers = _this22.capturedHandlers;
          handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new CapturedHandlerEntry(targetEvent));
          var capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});

          handlerEntry.increment();
          capturedCallbacks[targetEvent] = callback;

          return {
            v: function v() {
              handlerEntry.decrement();
              capturedCallbacks[targetEvent] = null;
            }
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }

      target.addEventListener(targetEvent, callback, false);

      return function () {
        target.removeEventListener(targetEvent, callback);
      };
    };

    return DefaultEventStrategy;
  }();

  var delegationStrategy = exports.delegationStrategy = {
    none: 0,
    capturing: 1,
    bubbling: 2
  };

  var EventManager = exports.EventManager = function () {
    function EventManager() {
      

      this.elementHandlerLookup = {};
      this.eventStrategyLookup = {};

      this.registerElementConfig({
        tagName: 'input',
        properties: {
          value: ['change', 'input'],
          checked: ['change', 'input'],
          files: ['change', 'input']
        }
      });

      this.registerElementConfig({
        tagName: 'textarea',
        properties: {
          value: ['change', 'input']
        }
      });

      this.registerElementConfig({
        tagName: 'select',
        properties: {
          value: ['change']
        }
      });

      this.registerElementConfig({
        tagName: 'content editable',
        properties: {
          value: ['change', 'input', 'blur', 'keyup', 'paste']
        }
      });

      this.registerElementConfig({
        tagName: 'scrollable element',
        properties: {
          scrollTop: ['scroll'],
          scrollLeft: ['scroll']
        }
      });

      this.defaultEventStrategy = new DefaultEventStrategy();
    }

    EventManager.prototype.registerElementConfig = function registerElementConfig(config) {
      var tagName = config.tagName.toLowerCase();
      var properties = config.properties;
      var propertyName = void 0;

      this.elementHandlerLookup[tagName] = {};

      for (propertyName in properties) {
        if (properties.hasOwnProperty(propertyName)) {
          this.registerElementPropertyConfig(tagName, propertyName, properties[propertyName]);
        }
      }
    };

    EventManager.prototype.registerElementPropertyConfig = function registerElementPropertyConfig(tagName, propertyName, events) {
      this.elementHandlerLookup[tagName][propertyName] = this.createElementHandler(events);
    };

    EventManager.prototype.createElementHandler = function createElementHandler(events) {
      return {
        subscribe: function subscribe(target, callbackOrListener) {
          events.forEach(function (changeEvent) {
            target.addEventListener(changeEvent, callbackOrListener, false);
          });

          return function () {
            events.forEach(function (changeEvent) {
              target.removeEventListener(changeEvent, callbackOrListener, false);
            });
          };
        }
      };
    };

    EventManager.prototype.registerElementHandler = function registerElementHandler(tagName, handler) {
      this.elementHandlerLookup[tagName.toLowerCase()] = handler;
    };

    EventManager.prototype.registerEventStrategy = function registerEventStrategy(eventName, strategy) {
      this.eventStrategyLookup[eventName] = strategy;
    };

    EventManager.prototype.getElementHandler = function getElementHandler(target, propertyName) {
      var tagName = void 0;
      var lookup = this.elementHandlerLookup;

      if (target.tagName) {
        tagName = target.tagName.toLowerCase();

        if (lookup[tagName] && lookup[tagName][propertyName]) {
          return lookup[tagName][propertyName];
        }

        if (propertyName === 'textContent' || propertyName === 'innerHTML') {
          return lookup['content editable'].value;
        }

        if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
          return lookup['scrollable element'][propertyName];
        }
      }

      return null;
    };

    EventManager.prototype.addEventListener = function addEventListener(target, targetEvent, callbackOrListener, delegate) {
      return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callbackOrListener, delegate);
    };

    return EventManager;
  }();

  var DirtyChecker = exports.DirtyChecker = function () {
    function DirtyChecker() {
      

      this.tracked = [];
      this.checkDelay = 120;
    }

    DirtyChecker.prototype.addProperty = function addProperty(property) {
      var tracked = this.tracked;

      tracked.push(property);

      if (tracked.length === 1) {
        this.scheduleDirtyCheck();
      }
    };

    DirtyChecker.prototype.removeProperty = function removeProperty(property) {
      var tracked = this.tracked;
      tracked.splice(tracked.indexOf(property), 1);
    };

    DirtyChecker.prototype.scheduleDirtyCheck = function scheduleDirtyCheck() {
      var _this23 = this;

      setTimeout(function () {
        return _this23.check();
      }, this.checkDelay);
    };

    DirtyChecker.prototype.check = function check() {
      var tracked = this.tracked;
      var i = tracked.length;

      while (i--) {
        var current = tracked[i];

        if (current.isDirty()) {
          current.call();
        }
      }

      if (tracked.length) {
        this.scheduleDirtyCheck();
      }
    };

    return DirtyChecker;
  }();

  var DirtyCheckProperty = exports.DirtyCheckProperty = (_dec5 = subscriberCollection(), _dec5(_class5 = function () {
    function DirtyCheckProperty(dirtyChecker, obj, propertyName) {
      

      this.dirtyChecker = dirtyChecker;
      this.obj = obj;
      this.propertyName = propertyName;
    }

    DirtyCheckProperty.prototype.getValue = function getValue() {
      return this.obj[this.propertyName];
    };

    DirtyCheckProperty.prototype.setValue = function setValue(newValue) {
      this.obj[this.propertyName] = newValue;
    };

    DirtyCheckProperty.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.getValue();

      this.callSubscribers(newValue, oldValue);

      this.oldValue = newValue;
    };

    DirtyCheckProperty.prototype.isDirty = function isDirty() {
      return this.oldValue !== this.obj[this.propertyName];
    };

    DirtyCheckProperty.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.oldValue = this.getValue();
        this.dirtyChecker.addProperty(this);
      }
      this.addSubscriber(context, callable);
    };

    DirtyCheckProperty.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.dirtyChecker.removeProperty(this);
      }
    };

    return DirtyCheckProperty;
  }()) || _class5);


  var logger = LogManager.getLogger('property-observation');

  var propertyAccessor = exports.propertyAccessor = {
    getValue: function getValue(obj, propertyName) {
      return obj[propertyName];
    },
    setValue: function setValue(value, obj, propertyName) {
      obj[propertyName] = value;
    }
  };

  var PrimitiveObserver = exports.PrimitiveObserver = function () {
    function PrimitiveObserver(primitive, propertyName) {
      

      this.doNotCache = true;

      this.primitive = primitive;
      this.propertyName = propertyName;
    }

    PrimitiveObserver.prototype.getValue = function getValue() {
      return this.primitive[this.propertyName];
    };

    PrimitiveObserver.prototype.setValue = function setValue() {
      var type = _typeof(this.primitive);
      throw new Error('The ' + this.propertyName + ' property of a ' + type + ' (' + this.primitive + ') cannot be assigned.');
    };

    PrimitiveObserver.prototype.subscribe = function subscribe() {};

    PrimitiveObserver.prototype.unsubscribe = function unsubscribe() {};

    return PrimitiveObserver;
  }();

  var SetterObserver = exports.SetterObserver = (_dec6 = subscriberCollection(), _dec6(_class7 = function () {
    function SetterObserver(taskQueue, obj, propertyName) {
      

      this.taskQueue = taskQueue;
      this.obj = obj;
      this.propertyName = propertyName;
      this.queued = false;
      this.observing = false;
    }

    SetterObserver.prototype.getValue = function getValue() {
      return this.obj[this.propertyName];
    };

    SetterObserver.prototype.setValue = function setValue(newValue) {
      this.obj[this.propertyName] = newValue;
    };

    SetterObserver.prototype.getterValue = function getterValue() {
      return this.currentValue;
    };

    SetterObserver.prototype.setterValue = function setterValue(newValue) {
      var oldValue = this.currentValue;

      if (oldValue !== newValue) {
        if (!this.queued) {
          this.oldValue = oldValue;
          this.queued = true;
          this.taskQueue.queueMicroTask(this);
        }

        this.currentValue = newValue;
      }
    };

    SetterObserver.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.currentValue;

      this.queued = false;

      this.callSubscribers(newValue, oldValue);
    };

    SetterObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.observing) {
        this.convertProperty();
      }
      this.addSubscriber(context, callable);
    };

    SetterObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };

    SetterObserver.prototype.convertProperty = function convertProperty() {
      this.observing = true;
      this.currentValue = this.obj[this.propertyName];
      this.setValue = this.setterValue;
      this.getValue = this.getterValue;

      if (!Reflect.defineProperty(this.obj, this.propertyName, {
        configurable: true,
        enumerable: this.propertyName in this.obj ? this.obj.propertyIsEnumerable(this.propertyName) : true,
        get: this.getValue.bind(this),
        set: this.setValue.bind(this)
      })) {
        logger.warn('Cannot observe property \'' + this.propertyName + '\' of object', this.obj);
      }
    };

    return SetterObserver;
  }()) || _class7);

  var XLinkAttributeObserver = exports.XLinkAttributeObserver = function () {
    function XLinkAttributeObserver(element, propertyName, attributeName) {
      

      this.element = element;
      this.propertyName = propertyName;
      this.attributeName = attributeName;
    }

    XLinkAttributeObserver.prototype.getValue = function getValue() {
      return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
    };

    XLinkAttributeObserver.prototype.setValue = function setValue(newValue) {
      return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
    };

    XLinkAttributeObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };

    return XLinkAttributeObserver;
  }();

  var dataAttributeAccessor = exports.dataAttributeAccessor = {
    getValue: function getValue(obj, propertyName) {
      return obj.getAttribute(propertyName);
    },
    setValue: function setValue(value, obj, propertyName) {
      if (value === null || value === undefined) {
        obj.removeAttribute(propertyName);
      } else {
        obj.setAttribute(propertyName, value);
      }
    }
  };

  var DataAttributeObserver = exports.DataAttributeObserver = function () {
    function DataAttributeObserver(element, propertyName) {
      

      this.element = element;
      this.propertyName = propertyName;
    }

    DataAttributeObserver.prototype.getValue = function getValue() {
      return this.element.getAttribute(this.propertyName);
    };

    DataAttributeObserver.prototype.setValue = function setValue(newValue) {
      if (newValue === null || newValue === undefined) {
        return this.element.removeAttribute(this.propertyName);
      }
      return this.element.setAttribute(this.propertyName, newValue);
    };

    DataAttributeObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };

    return DataAttributeObserver;
  }();

  var StyleObserver = exports.StyleObserver = function () {
    function StyleObserver(element, propertyName) {
      

      this.element = element;
      this.propertyName = propertyName;

      this.styles = null;
      this.version = 0;
    }

    StyleObserver.prototype.getValue = function getValue() {
      return this.element.style.cssText;
    };

    StyleObserver.prototype._setProperty = function _setProperty(style, value) {
      var priority = '';

      if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {
        priority = 'important';
        value = value.replace('!important', '');
      }
      this.element.style.setProperty(style, value, priority);
    };

    StyleObserver.prototype.setValue = function setValue(newValue) {
      var styles = this.styles || {};
      var style = void 0;
      var version = this.version;

      if (newValue !== null && newValue !== undefined) {
        if (newValue instanceof Object) {
          var value = void 0;
          for (style in newValue) {
            if (newValue.hasOwnProperty(style)) {
              value = newValue[style];
              style = style.replace(/([A-Z])/g, function (m) {
                return '-' + m.toLowerCase();
              });
              styles[style] = version;
              this._setProperty(style, value);
            }
          }
        } else if (newValue.length) {
          var rx = /\s*([\w\-]+)\s*:\s*((?:(?:[\w\-]+\(\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[\w\-]+\(\s*(?:^"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^\)]*)\),?|[^\)]*)\),?|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^;]*),?\s*)+);?/g;
          var pair = void 0;
          while ((pair = rx.exec(newValue)) !== null) {
            style = pair[1];
            if (!style) {
              continue;
            }

            styles[style] = version;
            this._setProperty(style, pair[2]);
          }
        }
      }

      this.styles = styles;
      this.version += 1;

      if (version === 0) {
        return;
      }

      version -= 1;
      for (style in styles) {
        if (!styles.hasOwnProperty(style) || styles[style] !== version) {
          continue;
        }

        this.element.style.removeProperty(style);
      }
    };

    StyleObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };

    return StyleObserver;
  }();

  var ValueAttributeObserver = exports.ValueAttributeObserver = (_dec7 = subscriberCollection(), _dec7(_class8 = function () {
    function ValueAttributeObserver(element, propertyName, handler) {
      

      this.element = element;
      this.propertyName = propertyName;
      this.handler = handler;
      if (propertyName === 'files') {
        this.setValue = function () {};
      }
    }

    ValueAttributeObserver.prototype.getValue = function getValue() {
      return this.element[this.propertyName];
    };

    ValueAttributeObserver.prototype.setValue = function setValue(newValue) {
      newValue = newValue === undefined || newValue === null ? '' : newValue;
      if (this.element[this.propertyName] !== newValue) {
        this.element[this.propertyName] = newValue;
        this.notify();
      }
    };

    ValueAttributeObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.getValue();

      this.callSubscribers(newValue, oldValue);

      this.oldValue = newValue;
    };

    ValueAttributeObserver.prototype.handleEvent = function handleEvent() {
      this.notify();
    };

    ValueAttributeObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.oldValue = this.getValue();
        this.disposeHandler = this.handler.subscribe(this.element, this);
      }

      this.addSubscriber(context, callable);
    };

    ValueAttributeObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };

    return ValueAttributeObserver;
  }()) || _class8);


  var checkedArrayContext = 'CheckedObserver:array';
  var checkedValueContext = 'CheckedObserver:value';

  var CheckedObserver = exports.CheckedObserver = (_dec8 = subscriberCollection(), _dec8(_class9 = function () {
    function CheckedObserver(element, handler, observerLocator) {
      

      this.element = element;
      this.handler = handler;
      this.observerLocator = observerLocator;
    }

    CheckedObserver.prototype.getValue = function getValue() {
      return this.value;
    };

    CheckedObserver.prototype.setValue = function setValue(newValue) {
      if (this.initialSync && this.value === newValue) {
        return;
      }

      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(checkedArrayContext, this);
        this.arrayObserver = null;
      }

      if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
        this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
        this.arrayObserver.subscribe(checkedArrayContext, this);
      }

      this.oldValue = this.value;
      this.value = newValue;
      this.synchronizeElement();
      this.notify();

      if (!this.initialSync) {
        this.initialSync = true;
        this.observerLocator.taskQueue.queueMicroTask(this);
      }
    };

    CheckedObserver.prototype.call = function call(context, splices) {
      this.synchronizeElement();

      if (!this.valueObserver) {
        this.valueObserver = this.element.__observers__.model || this.element.__observers__.value;
        if (this.valueObserver) {
          this.valueObserver.subscribe(checkedValueContext, this);
        }
      }
    };

    CheckedObserver.prototype.synchronizeElement = function synchronizeElement() {
      var value = this.value;
      var element = this.element;
      var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
      var isRadio = element.type === 'radio';
      var matcher = element.matcher || function (a, b) {
        return a === b;
      };

      element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && value.findIndex(function (item) {
        return !!matcher(item, elementValue);
      }) !== -1;
    };

    CheckedObserver.prototype.synchronizeValue = function synchronizeValue() {
      var value = this.value;
      var element = this.element;
      var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
      var index = void 0;
      var matcher = element.matcher || function (a, b) {
        return a === b;
      };

      if (element.type === 'checkbox') {
        if (Array.isArray(value)) {
          index = value.findIndex(function (item) {
            return !!matcher(item, elementValue);
          });
          if (element.checked && index === -1) {
            value.push(elementValue);
          } else if (!element.checked && index !== -1) {
            value.splice(index, 1);
          }

          return;
        }

        value = element.checked;
      } else if (element.checked) {
        value = elementValue;
      } else {
        return;
      }

      this.oldValue = this.value;
      this.value = value;
      this.notify();
    };

    CheckedObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.value;

      if (newValue === oldValue) {
        return;
      }

      this.callSubscribers(newValue, oldValue);
    };

    CheckedObserver.prototype.handleEvent = function handleEvent() {
      this.synchronizeValue();
    };

    CheckedObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.disposeHandler = this.handler.subscribe(this.element, this);
      }
      this.addSubscriber(context, callable);
    };

    CheckedObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };

    CheckedObserver.prototype.unbind = function unbind() {
      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(checkedArrayContext, this);
        this.arrayObserver = null;
      }
      if (this.valueObserver) {
        this.valueObserver.unsubscribe(checkedValueContext, this);
      }
    };

    return CheckedObserver;
  }()) || _class9);


  var selectArrayContext = 'SelectValueObserver:array';

  var SelectValueObserver = exports.SelectValueObserver = (_dec9 = subscriberCollection(), _dec9(_class10 = function () {
    function SelectValueObserver(element, handler, observerLocator) {
      

      this.element = element;
      this.handler = handler;
      this.observerLocator = observerLocator;
    }

    SelectValueObserver.prototype.getValue = function getValue() {
      return this.value;
    };

    SelectValueObserver.prototype.setValue = function setValue(newValue) {
      if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
        throw new Error('Only null or Array instances can be bound to a multi-select.');
      }
      if (this.value === newValue) {
        return;
      }

      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(selectArrayContext, this);
        this.arrayObserver = null;
      }

      if (Array.isArray(newValue)) {
        this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
        this.arrayObserver.subscribe(selectArrayContext, this);
      }

      this.oldValue = this.value;
      this.value = newValue;
      this.synchronizeOptions();
      this.notify();

      if (!this.initialSync) {
        this.initialSync = true;
        this.observerLocator.taskQueue.queueMicroTask(this);
      }
    };

    SelectValueObserver.prototype.call = function call(context, splices) {
      this.synchronizeOptions();
    };

    SelectValueObserver.prototype.synchronizeOptions = function synchronizeOptions() {
      var value = this.value;
      var isArray = void 0;

      if (Array.isArray(value)) {
        isArray = true;
      }

      var options = this.element.options;
      var i = options.length;
      var matcher = this.element.matcher || function (a, b) {
        return a === b;
      };

      var _loop = function _loop() {
        var option = options.item(i);
        var optionValue = option.hasOwnProperty('model') ? option.model : option.value;
        if (isArray) {
          option.selected = value.findIndex(function (item) {
            return !!matcher(optionValue, item);
          }) !== -1;
          return 'continue';
        }
        option.selected = !!matcher(optionValue, value);
      };

      while (i--) {
        var _ret3 = _loop();

        if (_ret3 === 'continue') continue;
      }
    };

    SelectValueObserver.prototype.synchronizeValue = function synchronizeValue() {
      var _this24 = this;

      var options = this.element.options;
      var count = 0;
      var value = [];

      for (var _i23 = 0, ii = options.length; _i23 < ii; _i23++) {
        var _option = options.item(_i23);
        if (!_option.selected) {
          continue;
        }
        value.push(_option.hasOwnProperty('model') ? _option.model : _option.value);
        count++;
      }

      if (this.element.multiple) {
        if (Array.isArray(this.value)) {
          var _ret4 = function () {
            var matcher = _this24.element.matcher || function (a, b) {
              return a === b;
            };

            var i = 0;

            var _loop2 = function _loop2() {
              var a = _this24.value[i];
              if (value.findIndex(function (b) {
                return matcher(a, b);
              }) === -1) {
                _this24.value.splice(i, 1);
              } else {
                i++;
              }
            };

            while (i < _this24.value.length) {
              _loop2();
            }

            i = 0;

            var _loop3 = function _loop3() {
              var a = value[i];
              if (_this24.value.findIndex(function (b) {
                return matcher(a, b);
              }) === -1) {
                _this24.value.push(a);
              }
              i++;
            };

            while (i < value.length) {
              _loop3();
            }
            return {
              v: void 0
            };
          }();

          if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === "object") return _ret4.v;
        }
      } else {
        if (count === 0) {
          value = null;
        } else {
          value = value[0];
        }
      }

      if (value !== this.value) {
        this.oldValue = this.value;
        this.value = value;
        this.notify();
      }
    };

    SelectValueObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.value;

      this.callSubscribers(newValue, oldValue);
    };

    SelectValueObserver.prototype.handleEvent = function handleEvent() {
      this.synchronizeValue();
    };

    SelectValueObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.disposeHandler = this.handler.subscribe(this.element, this);
      }
      this.addSubscriber(context, callable);
    };

    SelectValueObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };

    SelectValueObserver.prototype.bind = function bind() {
      var _this25 = this;

      this.domObserver = _aureliaPal.DOM.createMutationObserver(function () {
        _this25.synchronizeOptions();
        _this25.synchronizeValue();
      });
      this.domObserver.observe(this.element, { childList: true, subtree: true });
    };

    SelectValueObserver.prototype.unbind = function unbind() {
      this.domObserver.disconnect();
      this.domObserver = null;

      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(selectArrayContext, this);
        this.arrayObserver = null;
      }
    };

    return SelectValueObserver;
  }()) || _class10);

  var ClassObserver = exports.ClassObserver = function () {
    function ClassObserver(element) {
      

      this.element = element;
      this.doNotCache = true;
      this.value = '';
      this.version = 0;
    }

    ClassObserver.prototype.getValue = function getValue() {
      return this.value;
    };

    ClassObserver.prototype.setValue = function setValue(newValue) {
      var nameIndex = this.nameIndex || {};
      var version = this.version;
      var names = void 0;
      var name = void 0;

      if (newValue !== null && newValue !== undefined && newValue.length) {
        names = newValue.split(/\s+/);
        for (var _i24 = 0, length = names.length; _i24 < length; _i24++) {
          name = names[_i24];
          if (name === '') {
            continue;
          }
          nameIndex[name] = version;
          this.element.classList.add(name);
        }
      }

      this.value = newValue;
      this.nameIndex = nameIndex;
      this.version += 1;

      if (version === 0) {
        return;
      }

      version -= 1;
      for (name in nameIndex) {
        if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
          continue;
        }
        this.element.classList.remove(name);
      }
    };

    ClassObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "class" property is not supported.');
    };

    return ClassObserver;
  }();

  function hasDeclaredDependencies(descriptor) {
    return !!(descriptor && descriptor.get && descriptor.get.dependencies);
  }

  function declarePropertyDependencies(ctor, propertyName, dependencies) {
    var descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
    descriptor.get.dependencies = dependencies;
  }

  function computedFrom() {
    for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }

    return function (target, key, descriptor) {
      descriptor.get.dependencies = rest;
      return descriptor;
    };
  }

  var ComputedExpression = exports.ComputedExpression = function (_Expression19) {
    _inherits(ComputedExpression, _Expression19);

    function ComputedExpression(name, dependencies) {
      

      var _this26 = _possibleConstructorReturn(this, _Expression19.call(this));

      _this26.name = name;
      _this26.dependencies = dependencies;
      _this26.isAssignable = true;
      return _this26;
    }

    ComputedExpression.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return scope.bindingContext[this.name];
    };

    ComputedExpression.prototype.assign = function assign(scope, value) {
      scope.bindingContext[this.name] = value;
    };

    ComputedExpression.prototype.accept = function accept(visitor) {
      throw new Error('not implemented');
    };

    ComputedExpression.prototype.connect = function connect(binding, scope) {
      var dependencies = this.dependencies;
      var i = dependencies.length;
      while (i--) {
        dependencies[i].connect(binding, scope);
      }
    };

    return ComputedExpression;
  }(Expression);

  function createComputedObserver(obj, propertyName, descriptor, observerLocator) {
    var dependencies = descriptor.get.dependencies;
    if (!(dependencies instanceof ComputedExpression)) {
      var _i25 = dependencies.length;
      while (_i25--) {
        dependencies[_i25] = observerLocator.parser.parse(dependencies[_i25]);
      }
      dependencies = descriptor.get.dependencies = new ComputedExpression(propertyName, dependencies);
    }

    var scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };
    return new ExpressionObserver(scope, dependencies, observerLocator);
  }

  var svgElements = void 0;
  var svgPresentationElements = void 0;
  var svgPresentationAttributes = void 0;
  var svgAnalyzer = void 0;

  if (typeof FEATURE_NO_SVG === 'undefined') {
    (function () {
      svgElements = {
        a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
        altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
        animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
        ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
        feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
        feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
        feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
        feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
        feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
        feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
        feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
        feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
        feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
        'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
        'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
        'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
        'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
        'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
        glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
        image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
        linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
        marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
        mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
        'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
        mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
        style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
        svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
        switch: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
        symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
        text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
        title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
        tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
        view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
        vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
      };


      svgPresentationElements = {
        'a': true,
        'altGlyph': true,
        'animate': true,
        'animateColor': true,
        'circle': true,
        'clipPath': true,
        'defs': true,
        'ellipse': true,
        'feBlend': true,
        'feColorMatrix': true,
        'feComponentTransfer': true,
        'feComposite': true,
        'feConvolveMatrix': true,
        'feDiffuseLighting': true,
        'feDisplacementMap': true,
        'feFlood': true,
        'feGaussianBlur': true,
        'feImage': true,
        'feMerge': true,
        'feMorphology': true,
        'feOffset': true,
        'feSpecularLighting': true,
        'feTile': true,
        'feTurbulence': true,
        'filter': true,
        'font': true,
        'foreignObject': true,
        'g': true,
        'glyph': true,
        'glyphRef': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'missing-glyph': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'switch': true,
        'symbol': true,
        'text': true,
        'textPath': true,
        'tref': true,
        'tspan': true,
        'use': true
      };

      svgPresentationAttributes = {
        'alignment-baseline': true,
        'baseline-shift': true,
        'clip-path': true,
        'clip-rule': true,
        'clip': true,
        'color-interpolation-filters': true,
        'color-interpolation': true,
        'color-profile': true,
        'color-rendering': true,
        'color': true,
        'cursor': true,
        'direction': true,
        'display': true,
        'dominant-baseline': true,
        'enable-background': true,
        'fill-opacity': true,
        'fill-rule': true,
        'fill': true,
        'filter': true,
        'flood-color': true,
        'flood-opacity': true,
        'font-family': true,
        'font-size-adjust': true,
        'font-size': true,
        'font-stretch': true,
        'font-style': true,
        'font-variant': true,
        'font-weight': true,
        'glyph-orientation-horizontal': true,
        'glyph-orientation-vertical': true,
        'image-rendering': true,
        'kerning': true,
        'letter-spacing': true,
        'lighting-color': true,
        'marker-end': true,
        'marker-mid': true,
        'marker-start': true,
        'mask': true,
        'opacity': true,
        'overflow': true,
        'pointer-events': true,
        'shape-rendering': true,
        'stop-color': true,
        'stop-opacity': true,
        'stroke-dasharray': true,
        'stroke-dashoffset': true,
        'stroke-linecap': true,
        'stroke-linejoin': true,
        'stroke-miterlimit': true,
        'stroke-opacity': true,
        'stroke-width': true,
        'stroke': true,
        'text-anchor': true,
        'text-decoration': true,
        'text-rendering': true,
        'unicode-bidi': true,
        'visibility': true,
        'word-spacing': true,
        'writing-mode': true
      };

      var createElement = function createElement(html) {
        var div = _aureliaPal.DOM.createElement('div');
        div.innerHTML = html;
        return div.firstChild;
      };

      svgAnalyzer = function () {
        function SVGAnalyzer() {
          

          if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
            elements.altglyph = elements.altGlyph;
            delete elements.altGlyph;
            elements.altglyphdef = elements.altGlyphDef;
            delete elements.altGlyphDef;
            elements.altglyphitem = elements.altGlyphItem;
            delete elements.altGlyphItem;
            elements.glyphref = elements.glyphRef;
            delete elements.glyphRef;
          }
        }

        SVGAnalyzer.prototype.isStandardSvgAttribute = function isStandardSvgAttribute(nodeName, attributeName) {
          return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
        };

        return SVGAnalyzer;
      }();
    })();
  }

  var elements = exports.elements = svgElements;
  var presentationElements = exports.presentationElements = svgPresentationElements;
  var presentationAttributes = exports.presentationAttributes = svgPresentationAttributes;
  var SVGAnalyzer = exports.SVGAnalyzer = svgAnalyzer || function () {
    function _class11() {
      
    }

    _class11.prototype.isStandardSvgAttribute = function isStandardSvgAttribute() {
      return false;
    };

    return _class11;
  }();

  var ObserverLocator = exports.ObserverLocator = (_temp = _class12 = function () {
    function ObserverLocator(taskQueue, eventManager, dirtyChecker, svgAnalyzer, parser) {
      

      this.taskQueue = taskQueue;
      this.eventManager = eventManager;
      this.dirtyChecker = dirtyChecker;
      this.svgAnalyzer = svgAnalyzer;
      this.parser = parser;
      this.adapters = [];
      this.logger = LogManager.getLogger('observer-locator');
    }

    ObserverLocator.prototype.getObserver = function getObserver(obj, propertyName) {
      var observersLookup = obj.__observers__;
      var observer = void 0;

      if (observersLookup && propertyName in observersLookup) {
        return observersLookup[propertyName];
      }

      observer = this.createPropertyObserver(obj, propertyName);

      if (!observer.doNotCache) {
        if (observersLookup === undefined) {
          observersLookup = this.getOrCreateObserversLookup(obj);
        }

        observersLookup[propertyName] = observer;
      }

      return observer;
    };

    ObserverLocator.prototype.getOrCreateObserversLookup = function getOrCreateObserversLookup(obj) {
      return obj.__observers__ || this.createObserversLookup(obj);
    };

    ObserverLocator.prototype.createObserversLookup = function createObserversLookup(obj) {
      var value = {};

      if (!Reflect.defineProperty(obj, '__observers__', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: value
      })) {
        this.logger.warn('Cannot add observers to object', obj);
      }

      return value;
    };

    ObserverLocator.prototype.addAdapter = function addAdapter(adapter) {
      this.adapters.push(adapter);
    };

    ObserverLocator.prototype.getAdapterObserver = function getAdapterObserver(obj, propertyName, descriptor) {
      for (var _i26 = 0, ii = this.adapters.length; _i26 < ii; _i26++) {
        var adapter = this.adapters[_i26];
        var observer = adapter.getObserver(obj, propertyName, descriptor);
        if (observer) {
          return observer;
        }
      }
      return null;
    };

    ObserverLocator.prototype.createPropertyObserver = function createPropertyObserver(obj, propertyName) {
      var descriptor = void 0;
      var handler = void 0;
      var xlinkResult = void 0;

      if (!(obj instanceof Object)) {
        return new PrimitiveObserver(obj, propertyName);
      }

      if (obj instanceof _aureliaPal.DOM.Element) {
        if (propertyName === 'class') {
          return new ClassObserver(obj);
        }
        if (propertyName === 'style' || propertyName === 'css') {
          return new StyleObserver(obj, propertyName);
        }
        handler = this.eventManager.getElementHandler(obj, propertyName);
        if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
          return new SelectValueObserver(obj, handler, this);
        }
        if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
          return new CheckedObserver(obj, handler, this);
        }
        if (handler) {
          return new ValueAttributeObserver(obj, propertyName, handler);
        }
        xlinkResult = /^xlink:(.+)$/.exec(propertyName);
        if (xlinkResult) {
          return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
        }
        if (propertyName === 'role' && (obj instanceof _aureliaPal.DOM.Element || obj instanceof _aureliaPal.DOM.SVGElement) || /^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
          return new DataAttributeObserver(obj, propertyName);
        }
      }

      descriptor = Object.getPropertyDescriptor(obj, propertyName);

      if (hasDeclaredDependencies(descriptor)) {
        return createComputedObserver(obj, propertyName, descriptor, this);
      }

      if (descriptor) {
        var existingGetterOrSetter = descriptor.get || descriptor.set;
        if (existingGetterOrSetter) {
          if (existingGetterOrSetter.getObserver) {
            return existingGetterOrSetter.getObserver(obj);
          }

          var adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
          if (adapterObserver) {
            return adapterObserver;
          }
          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        }
      }

      if (obj instanceof Array) {
        if (propertyName === 'length') {
          return this.getArrayObserver(obj).getLengthObserver();
        }

        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      } else if (obj instanceof Map) {
        if (propertyName === 'size') {
          return this.getMapObserver(obj).getLengthObserver();
        }

        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      } else if (obj instanceof Set) {
        if (propertyName === 'size') {
          return this.getSetObserver(obj).getLengthObserver();
        }

        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      }

      return new SetterObserver(this.taskQueue, obj, propertyName);
    };

    ObserverLocator.prototype.getAccessor = function getAccessor(obj, propertyName) {
      if (obj instanceof _aureliaPal.DOM.Element) {
        if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || propertyName === 'model' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
          return this.getObserver(obj, propertyName);
        }
        if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName) || obj.tagName.toLowerCase() === 'img' && propertyName === 'src' || obj.tagName.toLowerCase() === 'a' && propertyName === 'href') {
          return dataAttributeAccessor;
        }
      }
      return propertyAccessor;
    };

    ObserverLocator.prototype.getArrayObserver = function getArrayObserver(array) {
      return _getArrayObserver(this.taskQueue, array);
    };

    ObserverLocator.prototype.getMapObserver = function getMapObserver(map) {
      return _getMapObserver(this.taskQueue, map);
    };

    ObserverLocator.prototype.getSetObserver = function getSetObserver(set) {
      return _getSetObserver(this.taskQueue, set);
    };

    return ObserverLocator;
  }(), _class12.inject = [_aureliaTaskQueue.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer, Parser], _temp);

  var ObjectObservationAdapter = exports.ObjectObservationAdapter = function () {
    function ObjectObservationAdapter() {
      
    }

    ObjectObservationAdapter.prototype.getObserver = function getObserver(object, propertyName, descriptor) {
      throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
    };

    return ObjectObservationAdapter;
  }();

  var BindingExpression = exports.BindingExpression = function () {
    function BindingExpression(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {
      

      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.sourceExpression = sourceExpression;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.attribute = attribute;
      this.discrete = false;
    }

    BindingExpression.prototype.createBinding = function createBinding(target) {
      return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
    };

    return BindingExpression;
  }();

  var Binding = exports.Binding = (_dec10 = connectable(), _dec10(_class13 = function () {
    function Binding(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {
      

      this.observerLocator = observerLocator;
      this.sourceExpression = sourceExpression;
      this.target = target;
      this.targetProperty = targetProperty;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
    }

    Binding.prototype.updateTarget = function updateTarget(value) {
      this.targetObserver.setValue(value, this.target, this.targetProperty);
    };

    Binding.prototype.updateSource = function updateSource(value) {
      this.sourceExpression.assign(this.source, value, this.lookupFunctions);
    };

    Binding.prototype.call = function call(context, newValue, oldValue) {
      if (!this.isBound) {
        return;
      }
      if (context === sourceContext) {
        oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
        newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        if (newValue !== oldValue) {
          this.updateTarget(newValue);
        }
        if (this.mode !== bindingMode.oneTime) {
          this._version++;
          this.sourceExpression.connect(this, this.source);
          this.unobserve(false);
        }
        return;
      }
      if (context === targetContext) {
        if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
          this.updateSource(newValue);
        }
        return;
      }
      throw new Error('Unexpected call context ' + context);
    };

    Binding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;

      if (this.sourceExpression.bind) {
        this.sourceExpression.bind(this, source, this.lookupFunctions);
      }

      var mode = this.mode;
      if (!this.targetObserver) {
        var method = mode === bindingMode.twoWay || mode === bindingMode.fromView ? 'getObserver' : 'getAccessor';
        this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
      }

      if ('bind' in this.targetObserver) {
        this.targetObserver.bind();
      }
      if (this.mode !== bindingMode.fromView) {
        var value = this.sourceExpression.evaluate(source, this.lookupFunctions);
        this.updateTarget(value);
      }

      if (mode === bindingMode.oneTime) {
        return;
      } else if (mode === bindingMode.toView) {
        enqueueBindingConnect(this);
      } else if (mode === bindingMode.twoWay) {
        this.sourceExpression.connect(this, source);
        this.targetObserver.subscribe(targetContext, this);
      } else if (mode === bindingMode.fromView) {
        this.targetObserver.subscribe(targetContext, this);
      }
    };

    Binding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      if ('unbind' in this.targetObserver) {
        this.targetObserver.unbind();
      }
      if (this.targetObserver.unsubscribe) {
        this.targetObserver.unsubscribe(targetContext, this);
      }
      this.unobserve(true);
    };

    Binding.prototype.connect = function connect(evaluate) {
      if (!this.isBound) {
        return;
      }
      if (evaluate) {
        var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.updateTarget(value);
      }
      this.sourceExpression.connect(this, this.source);
    };

    return Binding;
  }()) || _class13);

  var CallExpression = exports.CallExpression = function () {
    function CallExpression(observerLocator, targetProperty, sourceExpression, lookupFunctions) {
      

      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.sourceExpression = sourceExpression;
      this.lookupFunctions = lookupFunctions;
    }

    CallExpression.prototype.createBinding = function createBinding(target) {
      return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
    };

    return CallExpression;
  }();

  var Call = exports.Call = function () {
    function Call(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {
      

      this.sourceExpression = sourceExpression;
      this.target = target;
      this.targetProperty = observerLocator.getObserver(target, targetProperty);
      this.lookupFunctions = lookupFunctions;
    }

    Call.prototype.callSource = function callSource($event) {
      var overrideContext = this.source.overrideContext;
      Object.assign(overrideContext, $event);
      overrideContext.$event = $event;
      var mustEvaluate = true;
      var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
      delete overrideContext.$event;
      for (var prop in $event) {
        delete overrideContext[prop];
      }
      return result;
    };

    Call.prototype.bind = function bind(source) {
      var _this27 = this;

      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;

      if (this.sourceExpression.bind) {
        this.sourceExpression.bind(this, source, this.lookupFunctions);
      }
      this.targetProperty.setValue(function ($event) {
        return _this27.callSource($event);
      });
    };

    Call.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this.targetProperty.setValue(null);
    };

    return Call;
  }();

  var ValueConverterResource = exports.ValueConverterResource = function () {
    function ValueConverterResource(name) {
      

      this.name = name;
    }

    ValueConverterResource.convention = function convention(name) {
      if (name.endsWith('ValueConverter')) {
        return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
      }
    };

    ValueConverterResource.prototype.initialize = function initialize(container, target) {
      this.instance = container.get(target);
    };

    ValueConverterResource.prototype.register = function register(registry, name) {
      registry.registerValueConverter(name || this.name, this.instance);
    };

    ValueConverterResource.prototype.load = function load(container, target) {};

    return ValueConverterResource;
  }();

  function valueConverter(nameOrTarget) {
    if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(nameOrTarget), target);
      };
    }

    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(), nameOrTarget);
  }

  var BindingBehaviorResource = exports.BindingBehaviorResource = function () {
    function BindingBehaviorResource(name) {
      

      this.name = name;
    }

    BindingBehaviorResource.convention = function convention(name) {
      if (name.endsWith('BindingBehavior')) {
        return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
      }
    };

    BindingBehaviorResource.prototype.initialize = function initialize(container, target) {
      this.instance = container.get(target);
    };

    BindingBehaviorResource.prototype.register = function register(registry, name) {
      registry.registerBindingBehavior(name || this.name, this.instance);
    };

    BindingBehaviorResource.prototype.load = function load(container, target) {};

    return BindingBehaviorResource;
  }();

  function bindingBehavior(nameOrTarget) {
    if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
      };
    }

    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
  }

  var ListenerExpression = exports.ListenerExpression = function () {
    function ListenerExpression(eventManager, targetEvent, sourceExpression, delegationStrategy, preventDefault, lookupFunctions) {
      

      this.eventManager = eventManager;
      this.targetEvent = targetEvent;
      this.sourceExpression = sourceExpression;
      this.delegationStrategy = delegationStrategy;
      this.discrete = true;
      this.preventDefault = preventDefault;
      this.lookupFunctions = lookupFunctions;
    }

    ListenerExpression.prototype.createBinding = function createBinding(target) {
      return new Listener(this.eventManager, this.targetEvent, this.delegationStrategy, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
    };

    return ListenerExpression;
  }();

  var Listener = exports.Listener = function () {
    function Listener(eventManager, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, lookupFunctions) {
      

      this.eventManager = eventManager;
      this.targetEvent = targetEvent;
      this.delegationStrategy = delegationStrategy;
      this.sourceExpression = sourceExpression;
      this.target = target;
      this.preventDefault = preventDefault;
      this.lookupFunctions = lookupFunctions;
    }

    Listener.prototype.callSource = function callSource(event) {
      var overrideContext = this.source.overrideContext;
      overrideContext.$event = event;
      var mustEvaluate = true;
      var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
      delete overrideContext.$event;
      if (result !== true && this.preventDefault) {
        event.preventDefault();
      }
      return result;
    };

    Listener.prototype.handleEvent = function handleEvent(event) {
      this.callSource(event);
    };

    Listener.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;

      if (this.sourceExpression.bind) {
        this.sourceExpression.bind(this, source, this.lookupFunctions);
      }
      this._disposeListener = this.eventManager.addEventListener(this.target, this.targetEvent, this, this.delegationStrategy);
    };

    Listener.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this._disposeListener();
      this._disposeListener = null;
    };

    return Listener;
  }();

  function getAU(element) {
    var au = element.au;

    if (au === undefined) {
      throw new Error('No Aurelia APIs are defined for the element: "' + element.tagName + '".');
    }

    return au;
  }

  var NameExpression = exports.NameExpression = function () {
    function NameExpression(sourceExpression, apiName, lookupFunctions) {
      

      this.sourceExpression = sourceExpression;
      this.apiName = apiName;
      this.lookupFunctions = lookupFunctions;
      this.discrete = true;
    }

    NameExpression.prototype.createBinding = function createBinding(target) {
      return new NameBinder(this.sourceExpression, NameExpression.locateAPI(target, this.apiName), this.lookupFunctions);
    };

    NameExpression.locateAPI = function locateAPI(element, apiName) {
      switch (apiName) {
        case 'element':
          return element;
        case 'controller':
          return getAU(element).controller;
        case 'view-model':
          return getAU(element).controller.viewModel;
        case 'view':
          return getAU(element).controller.view;
        default:
          var target = getAU(element)[apiName];

          if (target === undefined) {
            throw new Error('Attempted to reference "' + apiName + '", but it was not found amongst the target\'s API.');
          }

          return target.viewModel;
      }
    };

    return NameExpression;
  }();

  var NameBinder = function () {
    function NameBinder(sourceExpression, target, lookupFunctions) {
      

      this.sourceExpression = sourceExpression;
      this.target = target;
      this.lookupFunctions = lookupFunctions;
    }

    NameBinder.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;
      if (this.sourceExpression.bind) {
        this.sourceExpression.bind(this, source, this.lookupFunctions);
      }
      this.sourceExpression.assign(this.source, this.target, this.lookupFunctions);
    };

    NameBinder.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.evaluate(this.source, this.lookupFunctions) === this.target) {
        this.sourceExpression.assign(this.source, null, this.lookupFunctions);
      }
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
    };

    return NameBinder;
  }();

  var LookupFunctions = {
    bindingBehaviors: function bindingBehaviors(name) {
      return null;
    },
    valueConverters: function valueConverters(name) {
      return null;
    }
  };

  var BindingEngine = exports.BindingEngine = (_temp2 = _class14 = function () {
    function BindingEngine(observerLocator, parser) {
      

      this.observerLocator = observerLocator;
      this.parser = parser;
    }

    BindingEngine.prototype.createBindingExpression = function createBindingExpression(targetProperty, sourceExpression) {
      var mode = arguments.length <= 2 || arguments[2] === undefined ? bindingMode.toView : arguments[2];
      var lookupFunctions = arguments.length <= 3 || arguments[3] === undefined ? LookupFunctions : arguments[3];

      return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
    };

    BindingEngine.prototype.propertyObserver = function propertyObserver(obj, propertyName) {
      var _this28 = this;

      return {
        subscribe: function subscribe(callback) {
          var observer = _this28.observerLocator.getObserver(obj, propertyName);
          observer.subscribe(callback);
          return {
            dispose: function dispose() {
              return observer.unsubscribe(callback);
            }
          };
        }
      };
    };

    BindingEngine.prototype.collectionObserver = function collectionObserver(collection) {
      var _this29 = this;

      return {
        subscribe: function subscribe(callback) {
          var observer = void 0;
          if (collection instanceof Array) {
            observer = _this29.observerLocator.getArrayObserver(collection);
          } else if (collection instanceof Map) {
            observer = _this29.observerLocator.getMapObserver(collection);
          } else if (collection instanceof Set) {
            observer = _this29.observerLocator.getSetObserver(collection);
          } else {
            throw new Error('collection must be an instance of Array, Map or Set.');
          }
          observer.subscribe(callback);
          return {
            dispose: function dispose() {
              return observer.unsubscribe(callback);
            }
          };
        }
      };
    };

    BindingEngine.prototype.expressionObserver = function expressionObserver(bindingContext, expression) {
      var scope = { bindingContext: bindingContext, overrideContext: createOverrideContext(bindingContext) };
      return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator, LookupFunctions);
    };

    BindingEngine.prototype.parseExpression = function parseExpression(expression) {
      return this.parser.parse(expression);
    };

    BindingEngine.prototype.registerAdapter = function registerAdapter(adapter) {
      this.observerLocator.addAdapter(adapter);
    };

    return BindingEngine;
  }(), _class14.inject = [ObserverLocator, Parser], _temp2);


  var setProto = Set.prototype;

  function _getSetObserver(taskQueue, set) {
    return ModifySetObserver.for(taskQueue, set);
  }

  exports.getSetObserver = _getSetObserver;

  var ModifySetObserver = function (_ModifyCollectionObse3) {
    _inherits(ModifySetObserver, _ModifyCollectionObse3);

    function ModifySetObserver(taskQueue, set) {
      

      return _possibleConstructorReturn(this, _ModifyCollectionObse3.call(this, taskQueue, set));
    }

    ModifySetObserver.for = function _for(taskQueue, set) {
      if (!('__set_observer__' in set)) {
        Reflect.defineProperty(set, '__set_observer__', {
          value: ModifySetObserver.create(taskQueue, set),
          enumerable: false, configurable: false
        });
      }
      return set.__set_observer__;
    };

    ModifySetObserver.create = function create(taskQueue, set) {
      var observer = new ModifySetObserver(taskQueue, set);

      var proto = setProto;
      if (proto.add !== set.add || proto.delete !== set.delete || proto.clear !== set.clear) {
        proto = {
          add: set.add,
          delete: set.delete,
          clear: set.clear
        };
      }

      set.add = function () {
        var type = 'add';
        var oldSize = set.size;
        var methodCallResult = proto.add.apply(set, arguments);
        var hasValue = set.size === oldSize;
        if (!hasValue) {
          observer.addChangeRecord({
            type: type,
            object: set,
            value: Array.from(set).pop()
          });
        }
        return methodCallResult;
      };

      set.delete = function () {
        var hasValue = set.has(arguments[0]);
        var methodCallResult = proto.delete.apply(set, arguments);
        if (hasValue) {
          observer.addChangeRecord({
            type: 'delete',
            object: set,
            value: arguments[0]
          });
        }
        return methodCallResult;
      };

      set.clear = function () {
        var methodCallResult = proto.clear.apply(set, arguments);
        observer.addChangeRecord({
          type: 'clear',
          object: set
        });
        return methodCallResult;
      };

      return observer;
    };

    return ModifySetObserver;
  }(ModifyCollectionObserver);

  function observable(targetOrConfig, key, descriptor) {
    function deco(target, key, descriptor, config) {
      var isClassDecorator = key === undefined;
      if (isClassDecorator) {
        target = target.prototype;
        key = typeof config === 'string' ? config : config.name;
      }

      var innerPropertyName = '_' + key;
      var innerPropertyDescriptor = {
        configurable: true,
        enumerable: false,
        writable: true
      };

      var callbackName = config && config.changeHandler || key + 'Changed';

      if (descriptor) {
        if (typeof descriptor.initializer === 'function') {
          innerPropertyDescriptor.value = descriptor.initializer();
        }
      } else {
        descriptor = {};
      }

      if (!('enumerable' in descriptor)) {
        descriptor.enumerable = true;
      }

      delete descriptor.value;
      delete descriptor.writable;
      delete descriptor.initializer;

      Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);

      descriptor.get = function () {
        return this[innerPropertyName];
      };
      descriptor.set = function (newValue) {
        var oldValue = this[innerPropertyName];
        if (newValue === oldValue) {
          return;
        }

        this[innerPropertyName] = newValue;
        Reflect.defineProperty(this, innerPropertyName, { enumerable: false });

        if (this[callbackName]) {
          this[callbackName](newValue, oldValue, key);
        }
      };

      descriptor.get.dependencies = [innerPropertyName];

      if (isClassDecorator) {
        Reflect.defineProperty(target, key, descriptor);
      } else {
        return descriptor;
      }
    }

    if (key === undefined) {
      return function (t, k, d) {
        return deco(t, k, d, targetOrConfig);
      };
    }
    return deco(targetOrConfig, key, descriptor);
  }

  var signals = {};

  function connectBindingToSignal(binding, name) {
    if (!signals.hasOwnProperty(name)) {
      signals[name] = 0;
    }
    binding.observeProperty(signals, name);
  }

  function signalBindings(name) {
    if (signals.hasOwnProperty(name)) {
      signals[name]++;
    }
  }
});
define('aurelia-bootstrapper',['module', 'exports', 'aurelia-pal', 'aurelia-polyfills'], function (module, exports, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.starting = undefined;
  exports.bootstrap = bootstrap;


  var bootstrapPromises = [];
  var startResolve = void 0;

  var startPromise = new Promise(function (resolve) {
    return startResolve = resolve;
  });
  var host = _aureliaPal.PLATFORM.global;
  var isNodeLike = typeof process !== 'undefined' && !process.browser;

  function ready() {
    if (!host.document || host.document.readyState === 'complete') {
      return Promise.resolve();
    }

    return new Promise(function (resolve) {
      host.document.addEventListener('DOMContentLoaded', completed);
      host.addEventListener('load', completed);

      function completed() {
        host.document.removeEventListener('DOMContentLoaded', completed);
        host.removeEventListener('load', completed);
        resolve();
      }
    });
  }

  function createLoader() {
    if (_aureliaPal.PLATFORM.Loader) {
      return Promise.resolve(new _aureliaPal.PLATFORM.Loader());
    }

    if (typeof AURELIA_WEBPACK_2_0 === 'undefined') {
      if (typeof __webpack_require__ !== 'undefined') {
        var m = __webpack_require__(require.resolve('aurelia-loader-webpack'));
        return Promise.resolve(new m.WebpackLoader());
      }

      if (host.System && typeof host.System.config === 'function') {
        return host.System.normalize('aurelia-bootstrapper').then(function (bsn) {
          return host.System.normalize('aurelia-loader-default', bsn);
        }).then(function (loaderName) {
          return host.System.import(loaderName).then(function (m) {
            return new m.DefaultLoader();
          });
        });
      }

      if (typeof host.require === 'function' && typeof host.require.version === 'string') {
        return new Promise(function (resolve, reject) {
          return host.require(['aurelia-loader-default'], function (m) {
            return resolve(new m.DefaultLoader());
          }, reject);
        });
      }

      if (isNodeLike && typeof module !== 'undefined' && typeof module.require !== 'undefined') {
        var _m = module.require('aurelia-loader-nodejs');
        return Promise.resolve(new _m.NodeJsLoader());
      }
    }

    return Promise.reject('No PLATFORM.Loader is defined and there is neither a System API (ES6) or a Require API (AMD) globally available to load your app.');
  }

  function initializePal(loader) {
    var type = void 0;

    var isRenderer = isNodeLike && (process.type === 'renderer' || process.versions['node-webkit']);

    if (isNodeLike && !isRenderer) {
      type = 'nodejs';
    } else if (typeof window !== 'undefined') {
      type = 'browser';
    } else if (typeof self !== 'undefined') {
      type = 'worker';
    } else {
      throw new Error('Could not determine platform implementation to load.');
    }

    return loader.loadModule('aurelia-pal-' + type).then(function (palModule) {
      return type === 'nodejs' && !_aureliaPal.isInitialized && palModule.globalize() || palModule.initialize();
    });
  }

  function preparePlatform(loader) {
    var map = function map(moduleId, relativeTo) {
      return loader.normalize(moduleId, relativeTo).then(function (normalized) {
        loader.map(moduleId, normalized);
        return normalized;
      });
    };

    return initializePal(loader).then(function () {
      return loader.normalize('aurelia-bootstrapper');
    }).then(function (bootstrapperName) {
      var frameworkPromise = map(_aureliaPal.PLATFORM.moduleName('aurelia-framework', { exports: ['Aurelia'] }), bootstrapperName);

      return Promise.all([frameworkPromise, frameworkPromise.then(function (frameworkName) {
        return map('aurelia-dependency-injection', frameworkName);
      }), map('aurelia-router', bootstrapperName), map('aurelia-logging-console', bootstrapperName)]);
    }).then(function (_ref) {
      var frameworkName = _ref[0];
      return loader.loadModule(frameworkName);
    }).then(function (fx) {
      return startResolve(function () {
        return new fx.Aurelia(loader);
      });
    });
  }

  function config(appHost, configModuleId, aurelia) {
    aurelia.host = appHost;
    aurelia.configModuleId = configModuleId || null;

    if (configModuleId) {
      return aurelia.loader.loadModule(configModuleId).then(function (customConfig) {
        if (!customConfig.configure) {
          throw new Error('Cannot initialize module \'' + configModuleId + '\' without a configure function.');
        }

        return customConfig.configure(aurelia);
      });
    }

    aurelia.use.standardConfiguration().developmentLogging();

    return aurelia.start().then(function () {
      return aurelia.setRoot();
    });
  }

  function run() {
    return ready().then(createLoader).then(preparePlatform).then(function () {
      var appHosts = host.document.querySelectorAll('[aurelia-app],[data-aurelia-app]');
      for (var i = 0, ii = appHosts.length; i < ii; ++i) {
        var appHost = appHosts[i];
        var moduleId = appHost.getAttribute('aurelia-app') || appHost.getAttribute('data-aurelia-app');
        bootstrap(config.bind(null, appHost, moduleId));
      }

      var toConsole = console.error.bind(console);
      var bootstraps = bootstrapPromises.map(function (p) {
        return p.catch(toConsole);
      });
      bootstrapPromises = null;
      return Promise.all(bootstraps);
    });
  }

  function bootstrap(configure) {
    var p = startPromise.then(function (factory) {
      return configure(factory());
    });
    if (bootstrapPromises) bootstrapPromises.push(p);
    return p;
  }

  var starting = exports.starting = run();
});
define('aurelia-dependency-injection',['exports', 'aurelia-metadata', 'aurelia-pal'], function (exports, _aureliaMetadata, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Container = exports.InvocationHandler = exports._emptyParameters = exports.SingletonRegistration = exports.TransientRegistration = exports.FactoryInvoker = exports.NewInstance = exports.Factory = exports.StrategyResolver = exports.Parent = exports.Optional = exports.All = exports.Lazy = exports.resolver = undefined;
  exports.getDecoratorDependencies = getDecoratorDependencies;
  exports.lazy = lazy;
  exports.all = all;
  exports.optional = optional;
  exports.parent = parent;
  exports.factory = factory;
  exports.newInstance = newInstance;
  exports.invoker = invoker;
  exports.invokeAsFactory = invokeAsFactory;
  exports.registration = registration;
  exports.transient = transient;
  exports.singleton = singleton;
  exports.autoinject = autoinject;
  exports.inject = inject;

  

  var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _dec5, _class9, _dec6, _class11, _dec7, _class13, _classInvokers;

  var resolver = exports.resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function (target) {
    if (!(typeof target.get === 'function')) {
      return 'Resolvers must implement: get(container: Container, key: any): any';
    }

    return true;
  });

  var Lazy = exports.Lazy = (_dec = resolver(), _dec(_class = function () {
    function Lazy(key) {
      

      this._key = key;
    }

    Lazy.prototype.get = function get(container) {
      var _this = this;

      return function () {
        return container.get(_this._key);
      };
    };

    Lazy.of = function of(key) {
      return new Lazy(key);
    };

    return Lazy;
  }()) || _class);
  var All = exports.All = (_dec2 = resolver(), _dec2(_class3 = function () {
    function All(key) {
      

      this._key = key;
    }

    All.prototype.get = function get(container) {
      return container.getAll(this._key);
    };

    All.of = function of(key) {
      return new All(key);
    };

    return All;
  }()) || _class3);
  var Optional = exports.Optional = (_dec3 = resolver(), _dec3(_class5 = function () {
    function Optional(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      

      this._key = key;
      this._checkParent = checkParent;
    }

    Optional.prototype.get = function get(container) {
      if (container.hasResolver(this._key, this._checkParent)) {
        return container.get(this._key);
      }

      return null;
    };

    Optional.of = function of(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      return new Optional(key, checkParent);
    };

    return Optional;
  }()) || _class5);
  var Parent = exports.Parent = (_dec4 = resolver(), _dec4(_class7 = function () {
    function Parent(key) {
      

      this._key = key;
    }

    Parent.prototype.get = function get(container) {
      return container.parent ? container.parent.get(this._key) : null;
    };

    Parent.of = function of(key) {
      return new Parent(key);
    };

    return Parent;
  }()) || _class7);
  var StrategyResolver = exports.StrategyResolver = (_dec5 = resolver(), _dec5(_class9 = function () {
    function StrategyResolver(strategy, state) {
      

      this.strategy = strategy;
      this.state = state;
    }

    StrategyResolver.prototype.get = function get(container, key) {
      switch (this.strategy) {
        case 0:
          return this.state;
        case 1:
          var singleton = container.invoke(this.state);
          this.state = singleton;
          this.strategy = 0;
          return singleton;
        case 2:
          return container.invoke(this.state);
        case 3:
          return this.state(container, key, this);
        case 4:
          return this.state[0].get(container, key);
        case 5:
          return container.get(this.state);
        default:
          throw new Error('Invalid strategy: ' + this.strategy);
      }
    };

    return StrategyResolver;
  }()) || _class9);
  var Factory = exports.Factory = (_dec6 = resolver(), _dec6(_class11 = function () {
    function Factory(key) {
      

      this._key = key;
    }

    Factory.prototype.get = function get(container) {
      var _this2 = this;

      return function () {
        for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }

        return container.invoke(_this2._key, rest);
      };
    };

    Factory.of = function of(key) {
      return new Factory(key);
    };

    return Factory;
  }()) || _class11);
  var NewInstance = exports.NewInstance = (_dec7 = resolver(), _dec7(_class13 = function () {
    function NewInstance(key) {
      

      this.key = key;
      this.asKey = key;

      for (var _len2 = arguments.length, dynamicDependencies = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        dynamicDependencies[_key2 - 1] = arguments[_key2];
      }

      this.dynamicDependencies = dynamicDependencies;
    }

    NewInstance.prototype.get = function get(container) {
      var dynamicDependencies = this.dynamicDependencies.length > 0 ? this.dynamicDependencies.map(function (dependency) {
        return dependency['protocol:aurelia:resolver'] ? dependency.get(container) : container.get(dependency);
      }) : undefined;
      var instance = container.invoke(this.key, dynamicDependencies);
      container.registerInstance(this.asKey, instance);
      return instance;
    };

    NewInstance.prototype.as = function as(key) {
      this.asKey = key;
      return this;
    };

    NewInstance.of = function of(key) {
      for (var _len3 = arguments.length, dynamicDependencies = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        dynamicDependencies[_key3 - 1] = arguments[_key3];
      }

      return new (Function.prototype.bind.apply(NewInstance, [null].concat([key], dynamicDependencies)))();
    };

    return NewInstance;
  }()) || _class13);
  function getDecoratorDependencies(target, name) {
    var dependencies = target.inject;
    if (typeof dependencies === 'function') {
      throw new Error('Decorator ' + name + ' cannot be used with "inject()".  Please use an array instead.');
    }
    if (!dependencies) {
      dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
      target.inject = dependencies;
    }

    return dependencies;
  }

  function lazy(keyValue) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'lazy');
      params[index] = Lazy.of(keyValue);
    };
  }

  function all(keyValue) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'all');
      params[index] = All.of(keyValue);
    };
  }

  function optional() {
    var checkParentOrTarget = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

    var deco = function deco(checkParent) {
      return function (target, key, index) {
        var params = getDecoratorDependencies(target, 'optional');
        params[index] = Optional.of(params[index], checkParent);
      };
    };
    if (typeof checkParentOrTarget === 'boolean') {
      return deco(checkParentOrTarget);
    }
    return deco(true);
  }

  function parent(target, key, index) {
    var params = getDecoratorDependencies(target, 'parent');
    params[index] = Parent.of(params[index]);
  }

  function factory(keyValue, asValue) {
    return function (target, key, index) {
      var params = getDecoratorDependencies(target, 'factory');
      var factory = Factory.of(keyValue);
      params[index] = asValue ? factory.as(asValue) : factory;
    };
  }

  function newInstance(asKeyOrTarget) {
    for (var _len4 = arguments.length, dynamicDependencies = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      dynamicDependencies[_key4 - 1] = arguments[_key4];
    }

    var deco = function deco(asKey) {
      return function (target, key, index) {
        var params = getDecoratorDependencies(target, 'newInstance');
        params[index] = NewInstance.of.apply(NewInstance, [params[index]].concat(dynamicDependencies));
        if (!!asKey) {
          params[index].as(asKey);
        }
      };
    };
    if (arguments.length >= 1) {
      return deco(asKeyOrTarget);
    }
    return deco();
  }

  function invoker(value) {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
    };
  }

  function invokeAsFactory(potentialTarget) {
    var deco = function deco(target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
    };

    return potentialTarget ? deco(potentialTarget) : deco;
  }

  var FactoryInvoker = exports.FactoryInvoker = function () {
    function FactoryInvoker() {
      
    }

    FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
      var i = dependencies.length;
      var args = new Array(i);

      while (i--) {
        args[i] = container.get(dependencies[i]);
      }

      return fn.apply(undefined, args);
    };

    FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
      var i = staticDependencies.length;
      var args = new Array(i);

      while (i--) {
        args[i] = container.get(staticDependencies[i]);
      }

      if (dynamicDependencies !== undefined) {
        args = args.concat(dynamicDependencies);
      }

      return fn.apply(undefined, args);
    };

    return FactoryInvoker;
  }();

  FactoryInvoker.instance = new FactoryInvoker();

  function registration(value) {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
    };
  }

  function transient(key) {
    return registration(new TransientRegistration(key));
  }

  function singleton(keyOrRegisterInChild) {
    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
  }

  var TransientRegistration = exports.TransientRegistration = function () {
    function TransientRegistration(key) {
      

      this._key = key;
    }

    TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
      var existingResolver = container.getResolver(this._key || key);
      return existingResolver === undefined ? container.registerTransient(this._key || key, fn) : existingResolver;
    };

    return TransientRegistration;
  }();

  var SingletonRegistration = exports.SingletonRegistration = function () {
    function SingletonRegistration(keyOrRegisterInChild) {
      var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      

      if (typeof keyOrRegisterInChild === 'boolean') {
        this._registerInChild = keyOrRegisterInChild;
      } else {
        this._key = keyOrRegisterInChild;
        this._registerInChild = registerInChild;
      }
    }

    SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
      var targetContainer = this._registerInChild ? container : container.root;
      var existingResolver = targetContainer.getResolver(this._key || key);
      return existingResolver === undefined ? targetContainer.registerSingleton(this._key || key, fn) : existingResolver;
    };

    return SingletonRegistration;
  }();

  function validateKey(key) {
    if (key === null || key === undefined) {
      throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    }
  }
  var _emptyParameters = exports._emptyParameters = Object.freeze([]);

  _aureliaMetadata.metadata.registration = 'aurelia:registration';
  _aureliaMetadata.metadata.invoker = 'aurelia:invoker';

  var resolverDecorates = resolver.decorates;

  var InvocationHandler = exports.InvocationHandler = function () {
    function InvocationHandler(fn, invoker, dependencies) {
      

      this.fn = fn;
      this.invoker = invoker;
      this.dependencies = dependencies;
    }

    InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
      return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
    };

    return InvocationHandler;
  }();

  function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
    var i = staticDependencies.length;
    var args = new Array(i);
    var lookup = void 0;

    while (i--) {
      lookup = staticDependencies[i];

      if (lookup === null || lookup === undefined) {
        throw new Error('Constructor Parameter with index ' + i + ' cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
      } else {
        args[i] = container.get(lookup);
      }
    }

    if (dynamicDependencies !== undefined) {
      args = args.concat(dynamicDependencies);
    }

    return Reflect.construct(fn, args);
  }

  var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
    invoke: function invoke(container, Type) {
      return new Type();
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[1] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]));
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[2] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]));
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[3] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[4] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[5] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
    },

    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers.fallback = {
    invoke: invokeWithDynamicDependencies,
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers);

  function getDependencies(f) {
    if (!f.hasOwnProperty('inject')) {
      return [];
    }

    if (typeof f.inject === 'function') {
      return f.inject();
    }

    return f.inject;
  }

  var Container = exports.Container = function () {
    function Container(configuration) {
      

      if (configuration === undefined) {
        configuration = {};
      }

      this._configuration = configuration;
      this._onHandlerCreated = configuration.onHandlerCreated;
      this._handlers = configuration.handlers || (configuration.handlers = new Map());
      this._resolvers = new Map();
      this.root = this;
      this.parent = null;
    }

    Container.prototype.makeGlobal = function makeGlobal() {
      Container.instance = this;
      return this;
    };

    Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
      this._onHandlerCreated = onHandlerCreated;
      this._configuration.onHandlerCreated = onHandlerCreated;
    };

    Container.prototype.registerInstance = function registerInstance(key, instance) {
      return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
    };

    Container.prototype.registerSingleton = function registerSingleton(key, fn) {
      return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
    };

    Container.prototype.registerTransient = function registerTransient(key, fn) {
      return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
    };

    Container.prototype.registerHandler = function registerHandler(key, handler) {
      return this.registerResolver(key, new StrategyResolver(3, handler));
    };

    Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
      return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
    };

    Container.prototype.registerResolver = function registerResolver(key, resolver) {
      validateKey(key);

      var allResolvers = this._resolvers;
      var result = allResolvers.get(key);

      if (result === undefined) {
        allResolvers.set(key, resolver);
      } else if (result.strategy === 4) {
        result.state.push(resolver);
      } else {
        allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
      }

      return resolver;
    };

    Container.prototype.autoRegister = function autoRegister(key, fn) {
      fn = fn === undefined ? key : fn;

      if (typeof fn === 'function') {
        var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);

        if (_registration === undefined) {
          return this.registerResolver(key, new StrategyResolver(1, fn));
        }

        return _registration.registerResolver(this, key, fn);
      }

      return this.registerResolver(key, new StrategyResolver(0, fn));
    };

    Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
      var i = fns.length;
      while (i--) {
        this.autoRegister(fns[i]);
      }
    };

    Container.prototype.unregister = function unregister(key) {
      this._resolvers.delete(key);
    };

    Container.prototype.hasResolver = function hasResolver(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      validateKey(key);

      return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
    };

    Container.prototype.getResolver = function getResolver(key) {
      return this._resolvers.get(key);
    };

    Container.prototype.get = function get(key) {
      validateKey(key);

      if (key === Container) {
        return this;
      }

      if (resolverDecorates(key)) {
        return key.get(this, key);
      }

      var resolver = this._resolvers.get(key);

      if (resolver === undefined) {
        if (this.parent === null) {
          return this.autoRegister(key).get(this, key);
        }

        var _registration2 = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, key);

        if (_registration2 === undefined) {
          return this.parent._get(key);
        }

        return _registration2.registerResolver(this, key, key).get(this, key);
      }

      return resolver.get(this, key);
    };

    Container.prototype._get = function _get(key) {
      var resolver = this._resolvers.get(key);

      if (resolver === undefined) {
        if (this.parent === null) {
          return this.autoRegister(key).get(this, key);
        }

        return this.parent._get(key);
      }

      return resolver.get(this, key);
    };

    Container.prototype.getAll = function getAll(key) {
      validateKey(key);

      var resolver = this._resolvers.get(key);

      if (resolver === undefined) {
        if (this.parent === null) {
          return _emptyParameters;
        }

        return this.parent.getAll(key);
      }

      if (resolver.strategy === 4) {
        var state = resolver.state;
        var i = state.length;
        var results = new Array(i);

        while (i--) {
          results[i] = state[i].get(this, key);
        }

        return results;
      }

      return [resolver.get(this, key)];
    };

    Container.prototype.createChild = function createChild() {
      var child = new Container(this._configuration);
      child.root = this.root;
      child.parent = this;
      return child;
    };

    Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
      try {
        var _handler = this._handlers.get(fn);

        if (_handler === undefined) {
          _handler = this._createInvocationHandler(fn);
          this._handlers.set(fn, _handler);
        }

        return _handler.invoke(this, dynamicDependencies);
      } catch (e) {
        throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
      }
    };

    Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
      var dependencies = void 0;

      if (fn.inject === undefined) {
        dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
      } else {
        dependencies = [];
        var ctor = fn;
        while (typeof ctor === 'function') {
          var _dependencies;

          (_dependencies = dependencies).push.apply(_dependencies, getDependencies(ctor));
          ctor = Object.getPrototypeOf(ctor);
        }
      }

      var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;

      var handler = new InvocationHandler(fn, invoker, dependencies);
      return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
    };

    return Container;
  }();

  function autoinject(potentialTarget) {
    var deco = function deco(target) {
      var previousInject = target.inject ? target.inject.slice() : null;
      var autoInject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
      if (!previousInject) {
        target.inject = autoInject;
      } else {
        for (var i = 0; i < autoInject.length; i++) {
          if (previousInject[i] && previousInject[i] !== autoInject[i]) {
            var prevIndex = previousInject.indexOf(autoInject[i]);
            if (prevIndex > -1) {
              previousInject.splice(prevIndex, 1);
            }
            previousInject.splice(prevIndex > -1 && prevIndex < i ? i - 1 : i, 0, autoInject[i]);
          } else if (!previousInject[i]) {
            previousInject[i] = autoInject[i];
          }
        }
        target.inject = previousInject;
      }
    };

    return potentialTarget ? deco(potentialTarget) : deco;
  }

  function inject() {
    for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      rest[_key5] = arguments[_key5];
    }

    return function (target, key, descriptor) {
      if (typeof descriptor === 'number' && rest.length === 1) {
        var params = target.inject;
        if (typeof params === 'function') {
          throw new Error('Decorator inject cannot be used with "inject()".  Please use an array instead.');
        }
        if (!params) {
          params = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
          target.inject = params;
        }
        params[descriptor] = rest[0];
        return;
      }

      if (descriptor) {
        var _fn = descriptor.value;
        _fn.inject = rest;
      } else {
        target.inject = rest;
      }
    };
  }
});
define('aurelia-event-aggregator',['exports', 'aurelia-logging'], function (exports, _aureliaLogging) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EventAggregator = undefined;
  exports.includeEventsIn = includeEventsIn;
  exports.configure = configure;

  var LogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  

  var logger = LogManager.getLogger('event-aggregator');

  var Handler = function () {
    function Handler(messageType, callback) {
      

      this.messageType = messageType;
      this.callback = callback;
    }

    Handler.prototype.handle = function handle(message) {
      if (message instanceof this.messageType) {
        this.callback.call(null, message);
      }
    };

    return Handler;
  }();

  function invokeCallback(callback, data, event) {
    try {
      callback(data, event);
    } catch (e) {
      logger.error(e);
    }
  }

  function invokeHandler(handler, data) {
    try {
      handler.handle(data);
    } catch (e) {
      logger.error(e);
    }
  }

  var EventAggregator = exports.EventAggregator = function () {
    function EventAggregator() {
      

      this.eventLookup = {};
      this.messageHandlers = [];
    }

    EventAggregator.prototype.publish = function publish(event, data) {
      var subscribers = void 0;
      var i = void 0;

      if (!event) {
        throw new Error('Event was invalid.');
      }

      if (typeof event === 'string') {
        subscribers = this.eventLookup[event];
        if (subscribers) {
          subscribers = subscribers.slice();
          i = subscribers.length;

          while (i--) {
            invokeCallback(subscribers[i], data, event);
          }
        }
      } else {
        subscribers = this.messageHandlers.slice();
        i = subscribers.length;

        while (i--) {
          invokeHandler(subscribers[i], event);
        }
      }
    };

    EventAggregator.prototype.subscribe = function subscribe(event, callback) {
      var handler = void 0;
      var subscribers = void 0;

      if (!event) {
        throw new Error('Event channel/type was invalid.');
      }

      if (typeof event === 'string') {
        handler = callback;
        subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
      } else {
        handler = new Handler(event, callback);
        subscribers = this.messageHandlers;
      }

      subscribers.push(handler);

      return {
        dispose: function dispose() {
          var idx = subscribers.indexOf(handler);
          if (idx !== -1) {
            subscribers.splice(idx, 1);
          }
        }
      };
    };

    EventAggregator.prototype.subscribeOnce = function subscribeOnce(event, callback) {
      var sub = this.subscribe(event, function (a, b) {
        sub.dispose();
        return callback(a, b);
      });

      return sub;
    };

    return EventAggregator;
  }();

  function includeEventsIn(obj) {
    var ea = new EventAggregator();

    obj.subscribeOnce = function (event, callback) {
      return ea.subscribeOnce(event, callback);
    };

    obj.subscribe = function (event, callback) {
      return ea.subscribe(event, callback);
    };

    obj.publish = function (event, data) {
      ea.publish(event, data);
    };

    return ea;
  }

  function configure(config) {
    config.instance(EventAggregator, includeEventsIn(config.aurelia));
  }
});
define('aurelia-framework',['exports', 'aurelia-dependency-injection', 'aurelia-binding', 'aurelia-metadata', 'aurelia-templating', 'aurelia-loader', 'aurelia-task-queue', 'aurelia-path', 'aurelia-pal', 'aurelia-logging'], function (exports, _aureliaDependencyInjection, _aureliaBinding, _aureliaMetadata, _aureliaTemplating, _aureliaLoader, _aureliaTaskQueue, _aureliaPath, _aureliaPal, _aureliaLogging) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LogManager = exports.FrameworkConfiguration = exports.Aurelia = undefined;
  Object.keys(_aureliaDependencyInjection).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaDependencyInjection[key];
      }
    });
  });
  Object.keys(_aureliaBinding).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaBinding[key];
      }
    });
  });
  Object.keys(_aureliaMetadata).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaMetadata[key];
      }
    });
  });
  Object.keys(_aureliaTemplating).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaTemplating[key];
      }
    });
  });
  Object.keys(_aureliaLoader).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaLoader[key];
      }
    });
  });
  Object.keys(_aureliaTaskQueue).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaTaskQueue[key];
      }
    });
  });
  Object.keys(_aureliaPath).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaPath[key];
      }
    });
  });
  Object.keys(_aureliaPal).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _aureliaPal[key];
      }
    });
  });

  var TheLogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  

  function preventActionlessFormSubmit() {
    _aureliaPal.DOM.addEventListener('submit', function (evt) {
      var target = evt.target;
      var action = target.action;

      if (target.tagName.toLowerCase() === 'form' && !action) {
        evt.preventDefault();
      }
    });
  }

  var Aurelia = exports.Aurelia = function () {
    function Aurelia(loader, container, resources) {
      

      this.loader = loader || new _aureliaPal.PLATFORM.Loader();
      this.container = container || new _aureliaDependencyInjection.Container().makeGlobal();
      this.resources = resources || new _aureliaTemplating.ViewResources();
      this.use = new FrameworkConfiguration(this);
      this.logger = TheLogManager.getLogger('aurelia');
      this.hostConfigured = false;
      this.host = null;

      this.use.instance(Aurelia, this);
      this.use.instance(_aureliaLoader.Loader, this.loader);
      this.use.instance(_aureliaTemplating.ViewResources, this.resources);
    }

    Aurelia.prototype.start = function start() {
      var _this = this;

      if (this._started) {
        return this._started;
      }

      this.logger.info('Aurelia Starting');
      return this._started = this.use.apply().then(function () {
        preventActionlessFormSubmit();

        if (!_this.container.hasResolver(_aureliaTemplating.BindingLanguage)) {
          var message = 'You must configure Aurelia with a BindingLanguage implementation.';
          _this.logger.error(message);
          throw new Error(message);
        }

        _this.logger.info('Aurelia Started');
        var evt = _aureliaPal.DOM.createCustomEvent('aurelia-started', { bubbles: true, cancelable: true });
        _aureliaPal.DOM.dispatchEvent(evt);
        return _this;
      });
    };

    Aurelia.prototype.enhance = function enhance() {
      var _this2 = this;

      var bindingContext = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      this._configureHost(applicationHost || _aureliaPal.DOM.querySelectorAll('body')[0]);

      return new Promise(function (resolve) {
        var engine = _this2.container.get(_aureliaTemplating.TemplatingEngine);
        _this2.root = engine.enhance({ container: _this2.container, element: _this2.host, resources: _this2.resources, bindingContext: bindingContext });
        _this2.root.attached();
        _this2._onAureliaComposed();
        resolve(_this2);
      });
    };

    Aurelia.prototype.setRoot = function setRoot() {
      var _this3 = this;

      var root = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var instruction = {};

      if (this.root && this.root.viewModel && this.root.viewModel.router) {
        this.root.viewModel.router.deactivate();
        this.root.viewModel.router.reset();
      }

      this._configureHost(applicationHost);

      var engine = this.container.get(_aureliaTemplating.TemplatingEngine);
      var transaction = this.container.get(_aureliaTemplating.CompositionTransaction);
      delete transaction.initialComposition;

      if (!root) {
        if (this.configModuleId) {
          root = (0, _aureliaPath.relativeToFile)('./app', this.configModuleId);
        } else {
          root = 'app';
        }
      }

      instruction.viewModel = root;
      instruction.container = instruction.childContainer = this.container;
      instruction.viewSlot = this.hostSlot;
      instruction.host = this.host;

      return engine.compose(instruction).then(function (r) {
        _this3.root = r;
        instruction.viewSlot.attached();
        _this3._onAureliaComposed();
        return _this3;
      });
    };

    Aurelia.prototype._configureHost = function _configureHost(applicationHost) {
      if (this.hostConfigured) {
        return;
      }
      applicationHost = applicationHost || this.host;

      if (!applicationHost || typeof applicationHost === 'string') {
        this.host = _aureliaPal.DOM.getElementById(applicationHost || 'applicationHost');
      } else {
        this.host = applicationHost;
      }

      if (!this.host) {
        throw new Error('No applicationHost was specified.');
      }

      this.hostConfigured = true;
      this.host.aurelia = this;
      this.hostSlot = new _aureliaTemplating.ViewSlot(this.host, true);
      this.hostSlot.transformChildNodesIntoView();
      this.container.registerInstance(_aureliaPal.DOM.boundary, this.host);
    };

    Aurelia.prototype._onAureliaComposed = function _onAureliaComposed() {
      var evt = _aureliaPal.DOM.createCustomEvent('aurelia-composed', { bubbles: true, cancelable: true });
      setTimeout(function () {
        return _aureliaPal.DOM.dispatchEvent(evt);
      }, 1);
    };

    return Aurelia;
  }();

  var logger = TheLogManager.getLogger('aurelia');
  var extPattern = /\.[^/.]+$/;

  function runTasks(config, tasks) {
    var current = void 0;
    var next = function next() {
      current = tasks.shift();
      if (current) {
        return Promise.resolve(current(config)).then(next);
      }

      return Promise.resolve();
    };

    return next();
  }

  function loadPlugin(config, loader, info) {
    logger.debug('Loading plugin ' + info.moduleId + '.');
    config.resourcesRelativeTo = info.resourcesRelativeTo;

    var id = info.moduleId;

    if (info.resourcesRelativeTo.length > 1) {
      return loader.normalize(info.moduleId, info.resourcesRelativeTo[1]).then(function (normalizedId) {
        return _loadPlugin(normalizedId);
      });
    }

    return _loadPlugin(id);

    function _loadPlugin(moduleId) {
      return loader.loadModule(moduleId).then(function (m) {
        if ('configure' in m) {
          return Promise.resolve(m.configure(config, info.config || {})).then(function () {
            config.resourcesRelativeTo = null;
            logger.debug('Configured plugin ' + info.moduleId + '.');
          });
        }

        config.resourcesRelativeTo = null;
        logger.debug('Loaded plugin ' + info.moduleId + '.');
      });
    }
  }

  function loadResources(aurelia, resourcesToLoad, appResources) {
    var viewEngine = aurelia.container.get(_aureliaTemplating.ViewEngine);

    return Promise.all(Object.keys(resourcesToLoad).map(function (n) {
      return _normalize(resourcesToLoad[n]);
    })).then(function (loads) {
      var names = [];
      var importIds = [];

      loads.forEach(function (l) {
        names.push(undefined);
        importIds.push(l.importId);
      });

      return viewEngine.importViewResources(importIds, names, appResources);
    });

    function _normalize(load) {
      var moduleId = load.moduleId;
      var ext = getExt(moduleId);

      if (isOtherResource(moduleId)) {
        moduleId = removeExt(moduleId);
      }

      return aurelia.loader.normalize(moduleId, load.relativeTo).then(function (normalized) {
        return {
          name: load.moduleId,
          importId: isOtherResource(load.moduleId) ? addOriginalExt(normalized, ext) : normalized
        };
      });
    }

    function isOtherResource(name) {
      var ext = getExt(name);
      if (!ext) return false;
      if (ext === '') return false;
      if (ext === '.js' || ext === '.ts') return false;
      return true;
    }

    function removeExt(name) {
      return name.replace(extPattern, '');
    }

    function addOriginalExt(normalized, ext) {
      return removeExt(normalized) + '.' + ext;
    }
  }

  function getExt(name) {
    var match = name.match(extPattern);
    if (match && match.length > 0) {
      return match[0].split('.')[1];
    }
  }

  function assertProcessed(plugins) {
    if (plugins.processed) {
      throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
    }
  }

  var FrameworkConfiguration = function () {
    function FrameworkConfiguration(aurelia) {
      var _this4 = this;

      

      this.aurelia = aurelia;
      this.container = aurelia.container;
      this.info = [];
      this.processed = false;
      this.preTasks = [];
      this.postTasks = [];
      this.resourcesToLoad = {};
      this.preTask(function () {
        return aurelia.loader.normalize('aurelia-bootstrapper').then(function (name) {
          return _this4.bootstrapperName = name;
        });
      });
      this.postTask(function () {
        return loadResources(aurelia, _this4.resourcesToLoad, aurelia.resources);
      });
    }

    FrameworkConfiguration.prototype.instance = function instance(type, _instance) {
      this.container.registerInstance(type, _instance);
      return this;
    };

    FrameworkConfiguration.prototype.singleton = function singleton(type, implementation) {
      this.container.registerSingleton(type, implementation);
      return this;
    };

    FrameworkConfiguration.prototype.transient = function transient(type, implementation) {
      this.container.registerTransient(type, implementation);
      return this;
    };

    FrameworkConfiguration.prototype.preTask = function preTask(task) {
      assertProcessed(this);
      this.preTasks.push(task);
      return this;
    };

    FrameworkConfiguration.prototype.postTask = function postTask(task) {
      assertProcessed(this);
      this.postTasks.push(task);
      return this;
    };

    FrameworkConfiguration.prototype.feature = function feature(plugin) {
      var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var hasIndex = /\/index$/i.test(plugin);
      var moduleId = hasIndex || getExt(plugin) ? plugin : plugin + '/index';
      var root = hasIndex ? plugin.substr(0, plugin.length - 6) : plugin;
      return this.plugin({ moduleId: moduleId, resourcesRelativeTo: [root, ''], config: config });
    };

    FrameworkConfiguration.prototype.globalResources = function globalResources(resources) {
      assertProcessed(this);

      var toAdd = Array.isArray(resources) ? resources : arguments;
      var resource = void 0;
      var resourcesRelativeTo = this.resourcesRelativeTo || ['', ''];

      for (var i = 0, ii = toAdd.length; i < ii; ++i) {
        resource = toAdd[i];
        if (typeof resource !== 'string') {
          throw new Error('Invalid resource path [' + resource + ']. Resources must be specified as relative module IDs.');
        }

        var parent = resourcesRelativeTo[0];
        var grandParent = resourcesRelativeTo[1];
        var name = resource;

        if ((resource.startsWith('./') || resource.startsWith('../')) && parent !== '') {
          name = (0, _aureliaPath.join)(parent, resource);
        }

        this.resourcesToLoad[name] = { moduleId: name, relativeTo: grandParent };
      }

      return this;
    };

    FrameworkConfiguration.prototype.globalName = function globalName(resourcePath, newName) {
      assertProcessed(this);
      this.resourcesToLoad[resourcePath] = { moduleId: newName, relativeTo: '' };
      return this;
    };

    FrameworkConfiguration.prototype.plugin = function plugin(_plugin, config) {
      assertProcessed(this);

      if (typeof _plugin === 'string') {
        return this.plugin({ moduleId: _plugin, resourcesRelativeTo: [_plugin, ''], config: config || {} });
      }

      this.info.push(_plugin);
      return this;
    };

    FrameworkConfiguration.prototype._addNormalizedPlugin = function _addNormalizedPlugin(name, config) {
      var _this5 = this;

      var plugin = { moduleId: name, resourcesRelativeTo: [name, ''], config: config || {} };
      this.plugin(plugin);

      this.preTask(function () {
        var relativeTo = [name, _this5.bootstrapperName];
        plugin.moduleId = name;
        plugin.resourcesRelativeTo = relativeTo;
        return Promise.resolve();
      });

      return this;
    };

    FrameworkConfiguration.prototype.defaultBindingLanguage = function defaultBindingLanguage() {
      return this._addNormalizedPlugin('aurelia-templating-binding');
    };

    FrameworkConfiguration.prototype.router = function router() {
      return this._addNormalizedPlugin('aurelia-templating-router');
    };

    FrameworkConfiguration.prototype.history = function history() {
      return this._addNormalizedPlugin('aurelia-history-browser');
    };

    FrameworkConfiguration.prototype.defaultResources = function defaultResources() {
      return this._addNormalizedPlugin('aurelia-templating-resources');
    };

    FrameworkConfiguration.prototype.eventAggregator = function eventAggregator() {
      return this._addNormalizedPlugin('aurelia-event-aggregator');
    };

    FrameworkConfiguration.prototype.basicConfiguration = function basicConfiguration() {
      return this.defaultBindingLanguage().defaultResources().eventAggregator();
    };

    FrameworkConfiguration.prototype.standardConfiguration = function standardConfiguration() {
      return this.basicConfiguration().history().router();
    };

    FrameworkConfiguration.prototype.developmentLogging = function developmentLogging() {
      var _this6 = this;

      this.preTask(function () {
        return _this6.aurelia.loader.normalize('aurelia-logging-console', _this6.bootstrapperName).then(function (name) {
          return _this6.aurelia.loader.loadModule(name).then(function (m) {
            TheLogManager.addAppender(new m.ConsoleAppender());
            TheLogManager.setLevel(TheLogManager.logLevel.debug);
          });
        });
      });

      return this;
    };

    FrameworkConfiguration.prototype.apply = function apply() {
      var _this7 = this;

      if (this.processed) {
        return Promise.resolve();
      }

      return runTasks(this, this.preTasks).then(function () {
        var loader = _this7.aurelia.loader;
        var info = _this7.info;
        var current = void 0;

        var next = function next() {
          current = info.shift();
          if (current) {
            return loadPlugin(_this7, loader, current).then(next);
          }

          _this7.processed = true;
          return Promise.resolve();
        };

        return next().then(function () {
          return runTasks(_this7, _this7.postTasks);
        });
      });
    };

    return FrameworkConfiguration;
  }();

  exports.FrameworkConfiguration = FrameworkConfiguration;
  var LogManager = exports.LogManager = TheLogManager;
});
define('aurelia-loader',['exports', 'aurelia-path', 'aurelia-metadata'], function (exports, _aureliaPath, _aureliaMetadata) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Loader = exports.TemplateRegistryEntry = exports.TemplateDependency = undefined;

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  

  var TemplateDependency = exports.TemplateDependency = function TemplateDependency(src, name) {
    

    this.src = src;
    this.name = name;
  };

  var TemplateRegistryEntry = exports.TemplateRegistryEntry = function () {
    function TemplateRegistryEntry(address) {
      

      this.templateIsLoaded = false;
      this.factoryIsReady = false;
      this.resources = null;
      this.dependencies = null;

      this.address = address;
      this.onReady = null;
      this._template = null;
      this._factory = null;
    }

    TemplateRegistryEntry.prototype.addDependency = function addDependency(src, name) {
      var finalSrc = typeof src === 'string' ? (0, _aureliaPath.relativeToFile)(src, this.address) : _aureliaMetadata.Origin.get(src).moduleId;

      this.dependencies.push(new TemplateDependency(finalSrc, name));
    };

    _createClass(TemplateRegistryEntry, [{
      key: 'template',
      get: function get() {
        return this._template;
      },
      set: function set(value) {
        var address = this.address;
        var requires = void 0;
        var current = void 0;
        var src = void 0;
        var dependencies = void 0;

        this._template = value;
        this.templateIsLoaded = true;

        requires = value.content.querySelectorAll('require');
        dependencies = this.dependencies = new Array(requires.length);

        for (var i = 0, ii = requires.length; i < ii; ++i) {
          current = requires[i];
          src = current.getAttribute('from');

          if (!src) {
            throw new Error('<require> element in ' + address + ' has no "from" attribute.');
          }

          dependencies[i] = new TemplateDependency((0, _aureliaPath.relativeToFile)(src, address), current.getAttribute('as'));

          if (current.parentNode) {
            current.parentNode.removeChild(current);
          }
        }
      }
    }, {
      key: 'factory',
      get: function get() {
        return this._factory;
      },
      set: function set(value) {
        this._factory = value;
        this.factoryIsReady = true;
      }
    }]);

    return TemplateRegistryEntry;
  }();

  var Loader = exports.Loader = function () {
    function Loader() {
      

      this.templateRegistry = {};
    }

    Loader.prototype.map = function map(id, source) {
      throw new Error('Loaders must implement map(id, source).');
    };

    Loader.prototype.normalizeSync = function normalizeSync(moduleId, relativeTo) {
      throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
    };

    Loader.prototype.normalize = function normalize(moduleId, relativeTo) {
      throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
    };

    Loader.prototype.loadModule = function loadModule(id) {
      throw new Error('Loaders must implement loadModule(id).');
    };

    Loader.prototype.loadAllModules = function loadAllModules(ids) {
      throw new Error('Loader must implement loadAllModules(ids).');
    };

    Loader.prototype.loadTemplate = function loadTemplate(url) {
      throw new Error('Loader must implement loadTemplate(url).');
    };

    Loader.prototype.loadText = function loadText(url) {
      throw new Error('Loader must implement loadText(url).');
    };

    Loader.prototype.applyPluginToUrl = function applyPluginToUrl(url, pluginName) {
      throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
    };

    Loader.prototype.addPlugin = function addPlugin(pluginName, implementation) {
      throw new Error('Loader must implement addPlugin(pluginName, implementation).');
    };

    Loader.prototype.getOrCreateTemplateRegistryEntry = function getOrCreateTemplateRegistryEntry(address) {
      return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
    };

    return Loader;
  }();
});
define('aurelia-loader-default',['exports', 'aurelia-loader', 'aurelia-pal', 'aurelia-metadata'], function (exports, _aureliaLoader, _aureliaPal, _aureliaMetadata) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DefaultLoader = exports.TextTemplateLoader = undefined;

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  

  var TextTemplateLoader = exports.TextTemplateLoader = function () {
    function TextTemplateLoader() {
      
    }

    TextTemplateLoader.prototype.loadTemplate = function loadTemplate(loader, entry) {
      return loader.loadText(entry.address).then(function (text) {
        entry.template = _aureliaPal.DOM.createTemplateFromMarkup(text);
      });
    };

    return TextTemplateLoader;
  }();

  function ensureOriginOnExports(executed, name) {
    var target = executed;
    var key = void 0;
    var exportedValue = void 0;

    if (target.__useDefault) {
      target = target['default'];
    }

    _aureliaMetadata.Origin.set(target, new _aureliaMetadata.Origin(name, 'default'));

    for (key in target) {
      exportedValue = target[key];

      if (typeof exportedValue === 'function') {
        _aureliaMetadata.Origin.set(exportedValue, new _aureliaMetadata.Origin(name, key));
      }
    }

    return executed;
  }

  var DefaultLoader = exports.DefaultLoader = function (_Loader) {
    _inherits(DefaultLoader, _Loader);

    function DefaultLoader() {
      

      var _this = _possibleConstructorReturn(this, _Loader.call(this));

      _this.textPluginName = 'text';


      _this.moduleRegistry = Object.create(null);
      _this.useTemplateLoader(new TextTemplateLoader());

      var that = _this;

      _this.addPlugin('template-registry-entry', {
        'fetch': function fetch(address) {
          var entry = that.getOrCreateTemplateRegistryEntry(address);
          return entry.templateIsLoaded ? entry : that.templateLoader.loadTemplate(that, entry).then(function (x) {
            return entry;
          });
        }
      });
      return _this;
    }

    DefaultLoader.prototype.useTemplateLoader = function useTemplateLoader(templateLoader) {
      this.templateLoader = templateLoader;
    };

    DefaultLoader.prototype.loadAllModules = function loadAllModules(ids) {
      var loads = [];

      for (var i = 0, ii = ids.length; i < ii; ++i) {
        loads.push(this.loadModule(ids[i]));
      }

      return Promise.all(loads);
    };

    DefaultLoader.prototype.loadTemplate = function loadTemplate(url) {
      return this._import(this.applyPluginToUrl(url, 'template-registry-entry'));
    };

    DefaultLoader.prototype.loadText = function loadText(url) {
      return this._import(this.applyPluginToUrl(url, this.textPluginName)).then(function (textOrModule) {
        if (typeof textOrModule === 'string') {
          return textOrModule;
        }

        return textOrModule['default'];
      });
    };

    return DefaultLoader;
  }(_aureliaLoader.Loader);

  _aureliaPal.PLATFORM.Loader = DefaultLoader;

  if (!_aureliaPal.PLATFORM.global.System || !_aureliaPal.PLATFORM.global.System.import) {
    if (_aureliaPal.PLATFORM.global.requirejs && requirejs.s && requirejs.s.contexts && requirejs.s.contexts._ && requirejs.s.contexts._.defined) {
      _aureliaPal.PLATFORM.eachModule = function (callback) {
        var defined = requirejs.s.contexts._.defined;
        for (var key in defined) {
          try {
            if (callback(key, defined[key])) return;
          } catch (e) {}
        }
      };
    } else {
      _aureliaPal.PLATFORM.eachModule = function (callback) {};
    }

    DefaultLoader.prototype._import = function (moduleId) {
      return new Promise(function (resolve, reject) {
        require([moduleId], resolve, reject);
      });
    };

    DefaultLoader.prototype.loadModule = function (id) {
      var _this2 = this;

      var existing = this.moduleRegistry[id];
      if (existing !== undefined) {
        return Promise.resolve(existing);
      }

      return new Promise(function (resolve, reject) {
        require([id], function (m) {
          _this2.moduleRegistry[id] = m;
          resolve(ensureOriginOnExports(m, id));
        }, reject);
      });
    };

    DefaultLoader.prototype.map = function (id, source) {};

    DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
      return Promise.resolve(moduleId);
    };

    DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
      return moduleId;
    };

    DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
      return pluginName + '!' + url;
    };

    DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
      var nonAnonDefine = define;
      nonAnonDefine(pluginName, [], {
        'load': function load(name, req, onload) {
          var result = implementation.fetch(name);
          Promise.resolve(result).then(onload);
        }
      });
    };
  } else {
    _aureliaPal.PLATFORM.eachModule = function (callback) {
      if (System.registry) {
        var keys = Array.from(System.registry.keys());
        for (var i = 0; i < keys.length; i++) {
          try {
            var key = keys[i];
            if (callback(key, System.registry.get(key))) {
              return;
            }
          } catch (e) {}
        }
        return;
      }

      var modules = System._loader.modules;

      for (var _key in modules) {
        try {
          if (callback(_key, modules[_key].module)) return;
        } catch (e) {}
      }
    };

    System.set('text', System.newModule({
      'translate': function translate(load) {
        return 'module.exports = "' + load.source.replace(/(["\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029') + '";';
      }
    }));

    DefaultLoader.prototype._import = function (moduleId) {
      return System.import(moduleId);
    };

    DefaultLoader.prototype.loadModule = function (id) {
      var _this3 = this;

      return System.normalize(id).then(function (newId) {
        var existing = _this3.moduleRegistry[newId];
        if (existing !== undefined) {
          return Promise.resolve(existing);
        }

        return System.import(newId).then(function (m) {
          _this3.moduleRegistry[newId] = m;
          return ensureOriginOnExports(m, newId);
        });
      });
    };

    DefaultLoader.prototype.map = function (id, source) {
      var _map;

      System.config({ map: (_map = {}, _map[id] = source, _map) });
    };

    DefaultLoader.prototype.normalizeSync = function (moduleId, relativeTo) {
      return System.normalizeSync(moduleId, relativeTo);
    };

    DefaultLoader.prototype.normalize = function (moduleId, relativeTo) {
      return System.normalize(moduleId, relativeTo);
    };

    DefaultLoader.prototype.applyPluginToUrl = function (url, pluginName) {
      return url + '!' + pluginName;
    };

    DefaultLoader.prototype.addPlugin = function (pluginName, implementation) {
      System.set(pluginName, System.newModule({
        'fetch': function fetch(load, _fetch) {
          var result = implementation.fetch(load.address);
          return Promise.resolve(result).then(function (x) {
            load.metadata.result = x;
            return '';
          });
        },
        'instantiate': function instantiate(load) {
          return load.metadata.result;
        }
      }));
    };
  }
});
define('aurelia-logging',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getLogger = getLogger;
  exports.addAppender = addAppender;
  exports.removeAppender = removeAppender;
  exports.getAppenders = getAppenders;
  exports.clearAppenders = clearAppenders;
  exports.addCustomLevel = addCustomLevel;
  exports.removeCustomLevel = removeCustomLevel;
  exports.setLevel = setLevel;
  exports.getLevel = getLevel;

  

  var logLevel = exports.logLevel = {
    none: 0,
    error: 10,
    warn: 20,
    info: 30,
    debug: 40
  };

  var loggers = {};
  var appenders = [];
  var globalDefaultLevel = logLevel.none;

  var standardLevels = ['none', 'error', 'warn', 'info', 'debug'];
  function isStandardLevel(level) {
    return standardLevels.filter(function (l) {
      return l === level;
    }).length > 0;
  }

  function appendArgs() {
    return [this].concat(Array.prototype.slice.call(arguments));
  }

  function logFactory(level) {
    var threshold = logLevel[level];
    return function () {
      if (this.level < threshold) {
        return;
      }

      var args = appendArgs.apply(this, arguments);
      var i = appenders.length;
      while (i--) {
        var _appenders$i;

        (_appenders$i = appenders[i])[level].apply(_appenders$i, args);
      }
    };
  }

  function logFactoryCustom(level) {
    var threshold = logLevel[level];
    return function () {
      if (this.level < threshold) {
        return;
      }

      var args = appendArgs.apply(this, arguments);
      var i = appenders.length;
      while (i--) {
        var appender = appenders[i];
        if (appender[level] !== undefined) {
          appender[level].apply(appender, args);
        }
      }
    };
  }

  function connectLoggers() {
    var proto = Logger.prototype;
    for (var _level in logLevel) {
      if (isStandardLevel(_level)) {
        if (_level !== 'none') {
          proto[_level] = logFactory(_level);
        }
      } else {
        proto[_level] = logFactoryCustom(_level);
      }
    }
  }

  function disconnectLoggers() {
    var proto = Logger.prototype;
    for (var _level2 in logLevel) {
      if (_level2 !== 'none') {
        proto[_level2] = function () {};
      }
    }
  }

  function getLogger(id) {
    return loggers[id] || new Logger(id);
  }

  function addAppender(appender) {
    if (appenders.push(appender) === 1) {
      connectLoggers();
    }
  }

  function removeAppender(appender) {
    appenders = appenders.filter(function (a) {
      return a !== appender;
    });
  }

  function getAppenders() {
    return [].concat(appenders);
  }

  function clearAppenders() {
    appenders = [];
    disconnectLoggers();
  }

  function addCustomLevel(name, value) {
    if (logLevel[name] !== undefined) {
      throw Error('Log level "' + name + '" already exists.');
    }

    if (isNaN(value)) {
      throw Error('Value must be a number.');
    }

    logLevel[name] = value;

    if (appenders.length > 0) {
      connectLoggers();
    } else {
      Logger.prototype[name] = function () {};
    }
  }

  function removeCustomLevel(name) {
    if (logLevel[name] === undefined) {
      return;
    }

    if (isStandardLevel(name)) {
      throw Error('Built-in log level "' + name + '" cannot be removed.');
    }

    delete logLevel[name];
    delete Logger.prototype[name];
  }

  function setLevel(level) {
    globalDefaultLevel = level;
    for (var key in loggers) {
      loggers[key].setLevel(level);
    }
  }

  function getLevel() {
    return globalDefaultLevel;
  }

  var Logger = exports.Logger = function () {
    function Logger(id) {
      

      var cached = loggers[id];
      if (cached) {
        return cached;
      }

      loggers[id] = this;
      this.id = id;
      this.level = globalDefaultLevel;
    }

    Logger.prototype.debug = function debug(message) {};

    Logger.prototype.info = function info(message) {};

    Logger.prototype.warn = function warn(message) {};

    Logger.prototype.error = function error(message) {};

    Logger.prototype.setLevel = function setLevel(level) {
      this.level = level;
    };

    return Logger;
  }();
});
define('aurelia-logging-console',['exports', 'aurelia-logging'], function (exports, _aureliaLogging) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ConsoleAppender = undefined;

  

  var ConsoleAppender = exports.ConsoleAppender = function () {
    function ConsoleAppender() {
      
    }

    ConsoleAppender.prototype.debug = function debug(logger) {
      var _console;

      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      (_console = console).debug.apply(_console, ['DEBUG [' + logger.id + ']'].concat(rest));
    };

    ConsoleAppender.prototype.info = function info(logger) {
      var _console2;

      for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }

      (_console2 = console).info.apply(_console2, ['INFO [' + logger.id + ']'].concat(rest));
    };

    ConsoleAppender.prototype.warn = function warn(logger) {
      var _console3;

      for (var _len3 = arguments.length, rest = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        rest[_key3 - 1] = arguments[_key3];
      }

      (_console3 = console).warn.apply(_console3, ['WARN [' + logger.id + ']'].concat(rest));
    };

    ConsoleAppender.prototype.error = function error(logger) {
      var _console4;

      for (var _len4 = arguments.length, rest = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        rest[_key4 - 1] = arguments[_key4];
      }

      (_console4 = console).error.apply(_console4, ['ERROR [' + logger.id + ']'].concat(rest));
    };

    return ConsoleAppender;
  }();
});
define('aurelia-metadata',['exports', 'aurelia-pal'], function (exports, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Origin = exports.metadata = undefined;
  exports.decorators = decorators;
  exports.deprecated = deprecated;
  exports.mixin = mixin;
  exports.protocol = protocol;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  function isObject(val) {
    return val && (typeof val === 'function' || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object');
  }

  var metadata = exports.metadata = {
    resource: 'aurelia:resource',
    paramTypes: 'design:paramtypes',
    propertyType: 'design:type',
    properties: 'design:properties',
    get: function get(metadataKey, target, targetKey) {
      if (!isObject(target)) {
        return undefined;
      }
      var result = metadata.getOwn(metadataKey, target, targetKey);
      return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
    },
    getOwn: function getOwn(metadataKey, target, targetKey) {
      if (!isObject(target)) {
        return undefined;
      }
      return Reflect.getOwnMetadata(metadataKey, target, targetKey);
    },
    define: function define(metadataKey, metadataValue, target, targetKey) {
      Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
    },
    getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
      var result = metadata.getOwn(metadataKey, target, targetKey);

      if (result === undefined) {
        result = new Type();
        Reflect.defineMetadata(metadataKey, result, target, targetKey);
      }

      return result;
    }
  };

  var originStorage = new Map();
  var unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

  var Origin = exports.Origin = function () {
    function Origin(moduleId, moduleMember) {
      

      this.moduleId = moduleId;
      this.moduleMember = moduleMember;
    }

    Origin.get = function get(fn) {
      var origin = originStorage.get(fn);

      if (origin === undefined) {
        _aureliaPal.PLATFORM.eachModule(function (key, value) {
          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
            for (var name in value) {
              var exp = value[name];
              if (exp === fn) {
                originStorage.set(fn, origin = new Origin(key, name));
                return true;
              }
            }
          }

          if (value === fn) {
            originStorage.set(fn, origin = new Origin(key, 'default'));
            return true;
          }

          return false;
        });
      }

      return origin || unknownOrigin;
    };

    Origin.set = function set(fn, origin) {
      originStorage.set(fn, origin);
    };

    return Origin;
  }();

  function decorators() {
    for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }

    var applicator = function applicator(target, key, descriptor) {
      var i = rest.length;

      if (key) {
        descriptor = descriptor || {
          value: target[key],
          writable: true,
          configurable: true,
          enumerable: true
        };

        while (i--) {
          descriptor = rest[i](target, key, descriptor) || descriptor;
        }

        Object.defineProperty(target, key, descriptor);
      } else {
        while (i--) {
          target = rest[i](target) || target;
        }
      }

      return target;
    };

    applicator.on = applicator;
    return applicator;
  }

  function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
    function decorator(target, key, descriptor) {
      var methodSignature = target.constructor.name + '#' + key;
      var options = maybeKey ? {} : optionsOrTarget || {};
      var message = 'DEPRECATION - ' + methodSignature;

      if (typeof descriptor.value !== 'function') {
        throw new SyntaxError('Only methods can be marked as deprecated.');
      }

      if (options.message) {
        message += ' - ' + options.message;
      }

      return _extends({}, descriptor, {
        value: function deprecationWrapper() {
          if (options.error) {
            throw new Error(message);
          } else {
            console.warn(message);
          }

          return descriptor.value.apply(this, arguments);
        }
      });
    }

    return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
  }

  function mixin(behavior) {
    var instanceKeys = Object.keys(behavior);

    function _mixin(possible) {
      var decorator = function decorator(target) {
        var resolvedTarget = typeof target === 'function' ? target.prototype : target;

        var i = instanceKeys.length;
        while (i--) {
          var property = instanceKeys[i];
          Object.defineProperty(resolvedTarget, property, {
            value: behavior[property],
            writable: true
          });
        }
      };

      return possible ? decorator(possible) : decorator;
    }

    return _mixin;
  }

  function alwaysValid() {
    return true;
  }
  function noCompose() {}

  function ensureProtocolOptions(options) {
    if (options === undefined) {
      options = {};
    } else if (typeof options === 'function') {
      options = {
        validate: options
      };
    }

    if (!options.validate) {
      options.validate = alwaysValid;
    }

    if (!options.compose) {
      options.compose = noCompose;
    }

    return options;
  }

  function createProtocolValidator(validate) {
    return function (target) {
      var result = validate(target);
      return result === true;
    };
  }

  function createProtocolAsserter(name, validate) {
    return function (target) {
      var result = validate(target);
      if (result !== true) {
        throw new Error(result || name + ' was not correctly implemented.');
      }
    };
  }

  function protocol(name, options) {
    options = ensureProtocolOptions(options);

    var result = function result(target) {
      var resolvedTarget = typeof target === 'function' ? target.prototype : target;

      options.compose(resolvedTarget);
      result.assert(resolvedTarget);

      Object.defineProperty(resolvedTarget, 'protocol:' + name, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: true
      });
    };

    result.validate = createProtocolValidator(options.validate);
    result.assert = createProtocolAsserter(name, options.validate);

    return result;
  }

  protocol.create = function (name, options) {
    options = ensureProtocolOptions(options);
    var hidden = 'protocol:' + name;
    var result = function result(target) {
      var decorator = protocol(name, options);
      return target ? decorator(target) : decorator;
    };

    result.decorates = function (obj) {
      return obj[hidden] === true;
    };
    result.validate = createProtocolValidator(options.validate);
    result.assert = createProtocolAsserter(name, options.validate);

    return result;
  };
});
define('aurelia-pal',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AggregateError = AggregateError;
  exports.initializePAL = initializePAL;
  exports.reset = reset;
  function AggregateError(message, innerError, skipIfAlreadyAggregate) {
    if (innerError) {
      if (innerError.innerError && skipIfAlreadyAggregate) {
        return innerError;
      }

      var separator = '\n------------------------------------------------\n';

      message += separator + 'Inner Error:\n';

      if (typeof innerError === 'string') {
        message += 'Message: ' + innerError;
      } else {
        if (innerError.message) {
          message += 'Message: ' + innerError.message;
        } else {
          message += 'Unknown Inner Error Type. Displaying Inner Error as JSON:\n ' + JSON.stringify(innerError, null, '  ');
        }

        if (innerError.stack) {
          message += '\nInner Error Stack:\n' + innerError.stack;
          message += '\nEnd Inner Error Stack';
        }
      }

      message += separator;
    }

    var e = new Error(message);
    if (innerError) {
      e.innerError = innerError;
    }

    return e;
  }

  var FEATURE = exports.FEATURE = {};

  var PLATFORM = exports.PLATFORM = {
    noop: function noop() {},
    eachModule: function eachModule() {},
    moduleName: function (_moduleName) {
      function moduleName(_x) {
        return _moduleName.apply(this, arguments);
      }

      moduleName.toString = function () {
        return _moduleName.toString();
      };

      return moduleName;
    }(function (moduleName) {
      return moduleName;
    })
  };

  PLATFORM.global = function () {
    if (typeof self !== 'undefined') {
      return self;
    }

    if (typeof global !== 'undefined') {
      return global;
    }

    return new Function('return this')();
  }();

  var DOM = exports.DOM = {};
  var isInitialized = exports.isInitialized = false;
  function initializePAL(callback) {
    if (isInitialized) {
      return;
    }
    exports.isInitialized = isInitialized = true;
    if (typeof Object.getPropertyDescriptor !== 'function') {
      Object.getPropertyDescriptor = function (subject, name) {
        var pd = Object.getOwnPropertyDescriptor(subject, name);
        var proto = Object.getPrototypeOf(subject);
        while (typeof pd === 'undefined' && proto !== null) {
          pd = Object.getOwnPropertyDescriptor(proto, name);
          proto = Object.getPrototypeOf(proto);
        }
        return pd;
      };
    }

    callback(PLATFORM, FEATURE, DOM);
  }
  function reset() {
    exports.isInitialized = isInitialized = false;
  }
});
define('aurelia-pal-browser',['exports', 'aurelia-pal'], function (exports, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._DOM = exports._FEATURE = exports._PLATFORM = undefined;
  exports.initialize = initialize;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _PLATFORM = exports._PLATFORM = {
    location: window.location,
    history: window.history,
    addEventListener: function addEventListener(eventName, callback, capture) {
      this.global.addEventListener(eventName, callback, capture);
    },
    removeEventListener: function removeEventListener(eventName, callback, capture) {
      this.global.removeEventListener(eventName, callback, capture);
    },

    performance: window.performance,
    requestAnimationFrame: function requestAnimationFrame(callback) {
      return this.global.requestAnimationFrame(callback);
    }
  };

  if (typeof FEATURE_NO_IE === 'undefined') {
    var test = function test() {};

    if (test.name === undefined) {
      Object.defineProperty(Function.prototype, 'name', {
        get: function get() {
          var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

          Object.defineProperty(this, 'name', { value: name });
          return name;
        }
      });
    }
  }

  if (typeof FEATURE_NO_IE === 'undefined') {
    if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
      (function () {
        var protoProp = 'prototype';
        var strTrim = String.prototype.trim;
        var arrIndexOf = Array.prototype.indexOf;
        var emptyArray = [];

        var DOMEx = function DOMEx(type, message) {
          this.name = type;
          this.code = DOMException[type];
          this.message = message;
        };

        var checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
          if (token === '') {
            throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
          }

          if (/\s/.test(token)) {
            throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
          }

          return arrIndexOf.call(classList, token);
        };

        var ClassList = function ClassList(elem) {
          var trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
          var classes = trimmedClasses ? trimmedClasses.split(/\s+/) : emptyArray;

          for (var i = 0, ii = classes.length; i < ii; ++i) {
            this.push(classes[i]);
          }

          this._updateClassName = function () {
            elem.setAttribute('class', this.toString());
          };
        };

        var classListProto = ClassList[protoProp] = [];

        DOMEx[protoProp] = Error[protoProp];

        classListProto.item = function (i) {
          return this[i] || null;
        };

        classListProto.contains = function (token) {
          token += '';
          return checkTokenAndGetIndex(this, token) !== -1;
        };

        classListProto.add = function () {
          var tokens = arguments;
          var i = 0;
          var ii = tokens.length;
          var token = void 0;
          var updated = false;

          do {
            token = tokens[i] + '';
            if (checkTokenAndGetIndex(this, token) === -1) {
              this.push(token);
              updated = true;
            }
          } while (++i < ii);

          if (updated) {
            this._updateClassName();
          }
        };

        classListProto.remove = function () {
          var tokens = arguments;
          var i = 0;
          var ii = tokens.length;
          var token = void 0;
          var updated = false;
          var index = void 0;

          do {
            token = tokens[i] + '';
            index = checkTokenAndGetIndex(this, token);
            while (index !== -1) {
              this.splice(index, 1);
              updated = true;
              index = checkTokenAndGetIndex(this, token);
            }
          } while (++i < ii);

          if (updated) {
            this._updateClassName();
          }
        };

        classListProto.toggle = function (token, force) {
          token += '';

          var result = this.contains(token);
          var method = result ? force !== true && 'remove' : force !== false && 'add';

          if (method) {
            this[method](token);
          }

          if (force === true || force === false) {
            return force;
          }

          return !result;
        };

        classListProto.toString = function () {
          return this.join(' ');
        };

        Object.defineProperty(Element.prototype, 'classList', {
          get: function get() {
            return new ClassList(this);
          },
          enumerable: true,
          configurable: true
        });
      })();
    } else {
      var testElement = document.createElement('_');
      testElement.classList.add('c1', 'c2');

      if (!testElement.classList.contains('c2')) {
        var createMethod = function createMethod(method) {
          var original = DOMTokenList.prototype[method];

          DOMTokenList.prototype[method] = function (token) {
            for (var i = 0, ii = arguments.length; i < ii; ++i) {
              token = arguments[i];
              original.call(this, token);
            }
          };
        };

        createMethod('add');
        createMethod('remove');
      }

      testElement.classList.toggle('c3', false);

      if (testElement.classList.contains('c3')) {
        (function () {
          var _toggle = DOMTokenList.prototype.toggle;

          DOMTokenList.prototype.toggle = function (token, force) {
            if (1 in arguments && !this.contains(token) === !force) {
              return force;
            }

            return _toggle.call(this, token);
          };
        })();
      }

      testElement = null;
    }
  }

  if (typeof FEATURE_NO_IE === 'undefined') {
    // @license http://opensource.org/licenses/MIT
    if ('performance' in window === false) {
      window.performance = {};
    }

    if ('now' in window.performance === false) {
      (function () {
        var nowOffset = Date.now();

        if (performance.timing && performance.timing.navigationStart) {
          nowOffset = performance.timing.navigationStart;
        }

        window.performance.now = function now() {
          return Date.now() - nowOffset;
        };
      })();
    }

    _PLATFORM.performance = window.performance;
  }

  if (typeof FEATURE_NO_IE === 'undefined') {
    (function () {
      var con = window.console = window.console || {};
      var nop = function nop() {};

      if (!con.memory) con.memory = {};
      ('assert,clear,count,debug,dir,dirxml,error,exception,group,' + 'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' + 'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',').forEach(function (m) {
        if (!con[m]) con[m] = nop;
      });

      if (_typeof(con.log) === 'object') {
        'log,info,warn,error,assert,dir,clear,profile,profileEnd'.split(',').forEach(function (method) {
          console[method] = this.bind(console[method], console);
        }, Function.prototype.call);
      }
    })();
  }

  if (typeof FEATURE_NO_IE === 'undefined') {
    if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
      var _CustomEvent = function _CustomEvent(event, params) {
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: undefined
        };

        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };

      _CustomEvent.prototype = window.Event.prototype;
      window.CustomEvent = _CustomEvent;
    }
  }

  if (Element && !Element.prototype.matches) {
    var proto = Element.prototype;
    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
  }

  var _FEATURE = exports._FEATURE = {
    shadowDOM: !!HTMLElement.prototype.attachShadow,
    scopedCSS: 'scoped' in document.createElement('style'),
    htmlTemplateElement: function () {
      var d = document.createElement('div');
      d.innerHTML = '<template></template>';
      return 'content' in d.children[0];
    }(),
    mutationObserver: !!(window.MutationObserver || window.WebKitMutationObserver),
    ensureHTMLTemplateElement: function ensureHTMLTemplateElement(t) {
      return t;
    }
  };

  if (typeof FEATURE_NO_IE === 'undefined') {
    (function () {
      var isSVGTemplate = function isSVGTemplate(el) {
        return el.tagName === 'template' && el.namespaceURI === 'http://www.w3.org/2000/svg';
      };

      var fixSVGTemplateElement = function fixSVGTemplateElement(el) {
        var template = el.ownerDocument.createElement('template');
        var attrs = el.attributes;
        var length = attrs.length;
        var attr = void 0;

        el.parentNode.insertBefore(template, el);

        while (length-- > 0) {
          attr = attrs[length];
          template.setAttribute(attr.name, attr.value);
          el.removeAttribute(attr.name);
        }

        el.parentNode.removeChild(el);

        return fixHTMLTemplateElement(template);
      };

      var fixHTMLTemplateElement = function fixHTMLTemplateElement(template) {
        var content = template.content = document.createDocumentFragment();
        var child = void 0;

        while (child = template.firstChild) {
          content.appendChild(child);
        }

        return template;
      };

      var fixHTMLTemplateElementRoot = function fixHTMLTemplateElementRoot(template) {
        var content = fixHTMLTemplateElement(template).content;
        var childTemplates = content.querySelectorAll('template');

        for (var i = 0, ii = childTemplates.length; i < ii; ++i) {
          var child = childTemplates[i];

          if (isSVGTemplate(child)) {
            fixSVGTemplateElement(child);
          } else {
            fixHTMLTemplateElement(child);
          }
        }

        return template;
      };

      if (!_FEATURE.htmlTemplateElement) {
        _FEATURE.ensureHTMLTemplateElement = fixHTMLTemplateElementRoot;
      }
    })();
  }

  var shadowPoly = window.ShadowDOMPolyfill || null;

  var _DOM = exports._DOM = {
    Element: Element,
    SVGElement: SVGElement,
    boundary: 'aurelia-dom-boundary',
    addEventListener: function addEventListener(eventName, callback, capture) {
      document.addEventListener(eventName, callback, capture);
    },
    removeEventListener: function removeEventListener(eventName, callback, capture) {
      document.removeEventListener(eventName, callback, capture);
    },
    adoptNode: function adoptNode(node) {
      return document.adoptNode(node, true);
    },
    createAttribute: function createAttribute(name) {
      return document.createAttribute(name);
    },
    createElement: function createElement(tagName) {
      return document.createElement(tagName);
    },
    createTextNode: function createTextNode(text) {
      return document.createTextNode(text);
    },
    createComment: function createComment(text) {
      return document.createComment(text);
    },
    createDocumentFragment: function createDocumentFragment() {
      return document.createDocumentFragment();
    },
    createTemplateElement: function createTemplateElement() {
      var template = document.createElement('template');
      return _FEATURE.ensureHTMLTemplateElement(template);
    },
    createMutationObserver: function createMutationObserver(callback) {
      return new (window.MutationObserver || window.WebKitMutationObserver)(callback);
    },
    createCustomEvent: function createCustomEvent(eventType, options) {
      return new window.CustomEvent(eventType, options);
    },
    dispatchEvent: function dispatchEvent(evt) {
      document.dispatchEvent(evt);
    },
    getComputedStyle: function getComputedStyle(element) {
      return window.getComputedStyle(element);
    },
    getElementById: function getElementById(id) {
      return document.getElementById(id);
    },
    querySelectorAll: function querySelectorAll(query) {
      return document.querySelectorAll(query);
    },
    nextElementSibling: function nextElementSibling(element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      do {
        element = element.nextSibling;
      } while (element && element.nodeType !== 1);
      return element;
    },
    createTemplateFromMarkup: function createTemplateFromMarkup(markup) {
      var parser = document.createElement('div');
      parser.innerHTML = markup;

      var temp = parser.firstElementChild;
      if (!temp || temp.nodeName !== 'TEMPLATE') {
        throw new Error('Template markup must be wrapped in a <template> element e.g. <template> <!-- markup here --> </template>');
      }

      return _FEATURE.ensureHTMLTemplateElement(temp);
    },
    appendNode: function appendNode(newNode, parentNode) {
      (parentNode || document.body).appendChild(newNode);
    },
    replaceNode: function replaceNode(newNode, node, parentNode) {
      if (node.parentNode) {
        node.parentNode.replaceChild(newNode, node);
      } else if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).replaceChild(shadowPoly.unwrap(newNode), shadowPoly.unwrap(node));
      } else {
        parentNode.replaceChild(newNode, node);
      }
    },
    removeNode: function removeNode(node, parentNode) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      } else if (parentNode) {
        if (shadowPoly !== null) {
          shadowPoly.unwrap(parentNode).removeChild(shadowPoly.unwrap(node));
        } else {
          parentNode.removeChild(node);
        }
      }
    },
    injectStyles: function injectStyles(styles, destination, prepend, id) {
      if (id) {
        var oldStyle = document.getElementById(id);
        if (oldStyle) {
          var isStyleTag = oldStyle.tagName.toLowerCase() === 'style';

          if (isStyleTag) {
            oldStyle.innerHTML = styles;
            return;
          }

          throw new Error('The provided id does not indicate a style tag.');
        }
      }

      var node = document.createElement('style');
      node.innerHTML = styles;
      node.type = 'text/css';

      if (id) {
        node.id = id;
      }

      destination = destination || document.head;

      if (prepend && destination.childNodes.length > 0) {
        destination.insertBefore(node, destination.childNodes[0]);
      } else {
        destination.appendChild(node);
      }

      return node;
    }
  };

  function initialize() {
    if (_aureliaPal.isInitialized) {
      return;
    }

    (0, _aureliaPal.initializePAL)(function (platform, feature, dom) {
      Object.assign(platform, _PLATFORM);
      Object.assign(feature, _FEATURE);
      Object.assign(dom, _DOM);

      Object.defineProperty(dom, 'title', {
        get: function get() {
          return document.title;
        },
        set: function set(value) {
          document.title = value;
        }
      });

      Object.defineProperty(dom, 'activeElement', {
        get: function get() {
          return document.activeElement;
        }
      });

      Object.defineProperty(platform, 'XMLHttpRequest', {
        get: function get() {
          return platform.global.XMLHttpRequest;
        }
      });
    });
  }
});
define('aurelia-path',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.relativeToFile = relativeToFile;
  exports.join = join;
  exports.buildQueryString = buildQueryString;
  exports.parseQueryString = parseQueryString;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  function trimDots(ary) {
    for (var i = 0; i < ary.length; ++i) {
      var part = ary[i];
      if (part === '.') {
        ary.splice(i, 1);
        i -= 1;
      } else if (part === '..') {
        if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {
          continue;
        } else if (i > 0) {
          ary.splice(i - 1, 2);
          i -= 2;
        }
      }
    }
  }

  function relativeToFile(name, file) {
    var fileParts = file && file.split('/');
    var nameParts = name.trim().split('/');

    if (nameParts[0].charAt(0) === '.' && fileParts) {
      var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
      nameParts.unshift.apply(nameParts, normalizedBaseParts);
    }

    trimDots(nameParts);

    return nameParts.join('/');
  }

  function join(path1, path2) {
    if (!path1) {
      return path2;
    }

    if (!path2) {
      return path1;
    }

    var schemeMatch = path1.match(/^([^/]*?:)\//);
    var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';
    path1 = path1.substr(scheme.length);

    var urlPrefix = void 0;
    if (path1.indexOf('///') === 0 && scheme === 'file:') {
      urlPrefix = '///';
    } else if (path1.indexOf('//') === 0) {
      urlPrefix = '//';
    } else if (path1.indexOf('/') === 0) {
      urlPrefix = '/';
    } else {
      urlPrefix = '';
    }

    var trailingSlash = path2.slice(-1) === '/' ? '/' : '';

    var url1 = path1.split('/');
    var url2 = path2.split('/');
    var url3 = [];

    for (var i = 0, ii = url1.length; i < ii; ++i) {
      if (url1[i] === '..') {
        url3.pop();
      } else if (url1[i] === '.' || url1[i] === '') {
        continue;
      } else {
        url3.push(url1[i]);
      }
    }

    for (var _i = 0, _ii = url2.length; _i < _ii; ++_i) {
      if (url2[_i] === '..') {
        url3.pop();
      } else if (url2[_i] === '.' || url2[_i] === '') {
        continue;
      } else {
        url3.push(url2[_i]);
      }
    }

    return scheme + urlPrefix + url3.join('/') + trailingSlash;
  }

  var encode = encodeURIComponent;
  var encodeKey = function encodeKey(k) {
    return encode(k).replace('%24', '$');
  };

  function buildParam(key, value, traditional) {
    var result = [];
    if (value === null || value === undefined) {
      return result;
    }
    if (Array.isArray(value)) {
      for (var i = 0, l = value.length; i < l; i++) {
        if (traditional) {
          result.push(encodeKey(key) + '=' + encode(value[i]));
        } else {
          var arrayKey = key + '[' + (_typeof(value[i]) === 'object' && value[i] !== null ? i : '') + ']';
          result = result.concat(buildParam(arrayKey, value[i]));
        }
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !traditional) {
      for (var propertyName in value) {
        result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));
      }
    } else {
      result.push(encodeKey(key) + '=' + encode(value));
    }
    return result;
  }

  function buildQueryString(params, traditional) {
    var pairs = [];
    var keys = Object.keys(params || {}).sort();
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      pairs = pairs.concat(buildParam(key, params[key], traditional));
    }

    if (pairs.length === 0) {
      return '';
    }

    return pairs.join('&');
  }

  function processScalarParam(existedParam, value) {
    if (Array.isArray(existedParam)) {
      existedParam.push(value);
      return existedParam;
    }
    if (existedParam !== undefined) {
      return [existedParam, value];
    }

    return value;
  }

  function parseComplexParam(queryParams, keys, value) {
    var currentParams = queryParams;
    var keysLastIndex = keys.length - 1;
    for (var j = 0; j <= keysLastIndex; j++) {
      var key = keys[j] === '' ? currentParams.length : keys[j];
      if (j < keysLastIndex) {
        var prevValue = !currentParams[key] || _typeof(currentParams[key]) === 'object' ? currentParams[key] : [currentParams[key]];
        currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);
      } else {
        currentParams = currentParams[key] = value;
      }
    }
  }

  function parseQueryString(queryString) {
    var queryParams = {};
    if (!queryString || typeof queryString !== 'string') {
      return queryParams;
    }

    var query = queryString;
    if (query.charAt(0) === '?') {
      query = query.substr(1);
    }

    var pairs = query.replace(/\+/g, ' ').split('&');
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i].split('=');
      var key = decodeURIComponent(pair[0]);
      if (!key) {
        continue;
      }

      var keys = key.split('][');
      var keysLastIndex = keys.length - 1;

      if (/\[/.test(keys[0]) && /\]$/.test(keys[keysLastIndex])) {
        keys[keysLastIndex] = keys[keysLastIndex].replace(/\]$/, '');
        keys = keys.shift().split('[').concat(keys);
        keysLastIndex = keys.length - 1;
      } else {
        keysLastIndex = 0;
      }

      if (pair.length >= 2) {
        var value = pair[1] ? decodeURIComponent(pair[1]) : '';
        if (keysLastIndex) {
          parseComplexParam(queryParams, keys, value);
        } else {
          queryParams[key] = processScalarParam(queryParams[key], value);
        }
      } else {
        queryParams[key] = true;
      }
    }
    return queryParams;
  }
});
define('aurelia-polyfills',['aurelia-pal'], function (_aureliaPal) {
  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  if (typeof FEATURE_NO_ES2015 === 'undefined') {

    (function (Object, GOPS) {
      'use strict';

      if (GOPS in Object) return;

      var setDescriptor,
          G = _aureliaPal.PLATFORM.global,
          id = 0,
          random = '' + Math.random(),
          prefix = '__\x01symbol:',
          prefixLength = prefix.length,
          internalSymbol = '__\x01symbol@@' + random,
          DP = 'defineProperty',
          DPies = 'defineProperties',
          GOPN = 'getOwnPropertyNames',
          GOPD = 'getOwnPropertyDescriptor',
          PIE = 'propertyIsEnumerable',
          gOPN = Object[GOPN],
          gOPD = Object[GOPD],
          create = Object.create,
          keys = Object.keys,
          defineProperty = Object[DP],
          $defineProperties = Object[DPies],
          descriptor = gOPD(Object, GOPN),
          ObjectProto = Object.prototype,
          hOP = ObjectProto.hasOwnProperty,
          pIE = ObjectProto[PIE],
          toString = ObjectProto.toString,
          indexOf = Array.prototype.indexOf || function (v) {
        for (var i = this.length; i-- && this[i] !== v;) {}
        return i;
      },
          addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {
        if (!hOP.call(o, internalSymbol)) {
          defineProperty(o, internalSymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: {}
          });
        }
        o[internalSymbol]['@@' + uid] = enumerable;
      },
          createWithSymbols = function createWithSymbols(proto, descriptors) {
        var self = create(proto);
        if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {
          gOPN(descriptors).forEach(function (key) {
            if (propertyIsEnumerable.call(descriptors, key)) {
              $defineProperty(self, key, descriptors[key]);
            }
          });
        }
        return self;
      },
          copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {
        var newDescriptor = create(descriptor);
        newDescriptor.enumerable = false;
        return newDescriptor;
      },
          get = function get() {},
          onlyNonSymbols = function onlyNonSymbols(name) {
        return name != internalSymbol && !hOP.call(source, name);
      },
          onlySymbols = function onlySymbols(name) {
        return name != internalSymbol && hOP.call(source, name);
      },
          propertyIsEnumerable = function propertyIsEnumerable(key) {
        var uid = '' + key;
        return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);
      },
          setAndGetSymbol = function setAndGetSymbol(uid) {
        var descriptor = {
          enumerable: false,
          configurable: true,
          get: get,
          set: function set(value) {
            setDescriptor(this, uid, {
              enumerable: false,
              configurable: true,
              writable: true,
              value: value
            });
            addInternalIfNeeded(this, uid, true);
          }
        };
        defineProperty(ObjectProto, uid, descriptor);
        return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);
      },
          _Symbol = function _Symbol2(description) {
        if (this && this !== G) {
          throw new TypeError('Symbol is not a constructor');
        }
        return setAndGetSymbol(prefix.concat(description || '', random, ++id));
      },
          source = create(null),
          sourceConstructor = { value: _Symbol },
          sourceMap = function sourceMap(uid) {
        return source[uid];
      },
          $defineProperty = function defineProp(o, key, descriptor) {
        var uid = '' + key;
        if (onlySymbols(uid)) {
          setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);
          addInternalIfNeeded(o, uid, !!descriptor.enumerable);
        } else {
          defineProperty(o, key, descriptor);
        }
        return o;
      },
          $getOwnPropertySymbols = function getOwnPropertySymbols(o) {
        var cof = toString.call(o);
        o = cof === '[object String]' ? o.split('') : Object(o);
        return gOPN(o).filter(onlySymbols).map(sourceMap);
      };

      descriptor.value = $defineProperty;
      defineProperty(Object, DP, descriptor);

      descriptor.value = $getOwnPropertySymbols;
      defineProperty(Object, GOPS, descriptor);

      var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      descriptor.value = function getOwnPropertyNames(o) {
        if (toString.call(o) === '[object Window]') {
          try {
            return originalObjectGetOwnPropertyNames(o);
          } catch (e) {
            return [].concat([], cachedWindowNames);
          }
        }
        return gOPN(o).filter(onlyNonSymbols);
      };
      defineProperty(Object, GOPN, descriptor);

      descriptor.value = function defineProperties(o, descriptors) {
        var symbols = $getOwnPropertySymbols(descriptors);
        if (symbols.length) {
          keys(descriptors).concat(symbols).forEach(function (uid) {
            if (propertyIsEnumerable.call(descriptors, uid)) {
              $defineProperty(o, uid, descriptors[uid]);
            }
          });
        } else {
          $defineProperties(o, descriptors);
        }
        return o;
      };
      defineProperty(Object, DPies, descriptor);

      descriptor.value = propertyIsEnumerable;
      defineProperty(ObjectProto, PIE, descriptor);

      descriptor.value = _Symbol;
      defineProperty(G, 'Symbol', descriptor);

      descriptor.value = function (key) {
        var uid = prefix.concat(prefix, key, random);
        return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);
      };
      defineProperty(_Symbol, 'for', descriptor);

      descriptor.value = function (symbol) {
        return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;
      };
      defineProperty(_Symbol, 'keyFor', descriptor);

      descriptor.value = function getOwnPropertyDescriptor(o, key) {
        var descriptor = gOPD(o, key);
        if (descriptor && onlySymbols(key)) {
          descriptor.enumerable = propertyIsEnumerable.call(o, key);
        }
        return descriptor;
      };
      defineProperty(Object, GOPD, descriptor);

      descriptor.value = function (proto, descriptors) {
        return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);
      };
      defineProperty(Object, 'create', descriptor);

      descriptor.value = function () {
        var str = toString.call(this);
        return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;
      };
      defineProperty(ObjectProto, 'toString', descriptor);

      try {
        setDescriptor = create(defineProperty({}, prefix, {
          get: function get() {
            return defineProperty(this, prefix, { value: false })[prefix];
          }
        }))[prefix] || defineProperty;
      } catch (o_O) {
        setDescriptor = function setDescriptor(o, key, descriptor) {
          var protoDescriptor = gOPD(ObjectProto, key);
          delete ObjectProto[key];
          defineProperty(o, key, descriptor);
          defineProperty(ObjectProto, key, protoDescriptor);
        };
      }
    })(Object, 'getOwnPropertySymbols');

    (function (O, S) {
      var dP = O.defineProperty,
          ObjectProto = O.prototype,
          toString = ObjectProto.toString,
          toStringTag = 'toStringTag',
          descriptor;
      ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {
        if (!(name in Symbol)) {
          dP(Symbol, name, { value: Symbol(name) });
          switch (name) {
            case toStringTag:
              descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');
              descriptor.value = function () {
                var str = toString.call(this),
                    tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];
                return typeof tst === 'undefined' ? str : '[object ' + tst + ']';
              };
              dP(ObjectProto, 'toString', descriptor);
              break;
          }
        }
      });
    })(Object, Symbol);

    (function (Si, AP, SP) {

      function returnThis() {
        return this;
      }

      if (!AP[Si]) AP[Si] = function () {
        var i = 0,
            self = this,
            iterator = {
          next: function next() {
            var done = self.length <= i;
            return done ? { done: done } : { done: done, value: self[i++] };
          }
        };
        iterator[Si] = returnThis;
        return iterator;
      };

      if (!SP[Si]) SP[Si] = function () {
        var fromCodePoint = String.fromCodePoint,
            self = this,
            i = 0,
            length = self.length,
            iterator = {
          next: function next() {
            var done = length <= i,
                c = done ? '' : fromCodePoint(self.codePointAt(i));
            i += c.length;
            return done ? { done: done } : { done: done, value: c };
          }
        };
        iterator[Si] = returnThis;
        return iterator;
      };
    })(Symbol.iterator, Array.prototype, String.prototype);
  }

  if (typeof FEATURE_NO_ES2015 === 'undefined') {

    Number.isNaN = Number.isNaN || function (value) {
      return value !== value;
    };

    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };
  }

  if (!String.prototype.endsWith || function () {
    try {
      return !"ab".endsWith("a", 1);
    } catch (e) {
      return true;
    }
  }()) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }

  if (!String.prototype.startsWith || function () {
    try {
      return !"ab".startsWith("b", 1);
    } catch (e) {
      return true;
    }
  }()) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.substr(position, searchString.length) === searchString;
    };
  }

  if (typeof FEATURE_NO_ES2015 === 'undefined') {

    if (!Array.from) {
      Array.from = function () {
        var toInteger = function toInteger(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);
        };
        var toLength = function toLength(it) {
          return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;
        };
        var iterCall = function iterCall(iter, fn, val, index) {
          try {
            return fn(val, index);
          } catch (E) {
            if (typeof iter.return == 'function') iter.return();
            throw E;
          }
        };

        return function from(arrayLike) {
          var O = Object(arrayLike),
              C = typeof this == 'function' ? this : Array,
              aLen = arguments.length,
              mapfn = aLen > 1 ? arguments[1] : undefined,
              mapping = mapfn !== undefined,
              index = 0,
              iterFn = O[Symbol.iterator],
              length,
              result,
              step,
              iterator;
          if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);
          if (iterFn != undefined && !Array.isArray(arrayLike)) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;
            }
          } else {
            length = toLength(O.length);
            for (result = new C(length); length > index; index++) {
              result[index] = mapping ? mapfn(O[index], index) : O[index];
            }
          }
          result.length = index;
          return result;
        };
      }();
    }

    if (!Array.prototype.find) {
      Object.defineProperty(Array.prototype, 'find', {
        configurable: true,
        writable: true,
        enumerable: false,
        value: function value(predicate) {
          if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
          }
          if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
          }
          var list = Object(this);
          var length = list.length >>> 0;
          var thisArg = arguments[1];
          var value;

          for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
              return value;
            }
          }
          return undefined;
        }
      });
    }

    if (!Array.prototype.findIndex) {
      Object.defineProperty(Array.prototype, 'findIndex', {
        configurable: true,
        writable: true,
        enumerable: false,
        value: function value(predicate) {
          if (this === null) {
            throw new TypeError('Array.prototype.findIndex called on null or undefined');
          }
          if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
          }
          var list = Object(this);
          var length = list.length >>> 0;
          var thisArg = arguments[1];
          var value;

          for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
              return i;
            }
          }
          return -1;
        }
      });
    }
  }

  if (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function value(searchElement) {
        var O = Object(this);
        var len = parseInt(O.length) || 0;
        if (len === 0) {
          return false;
        }
        var n = parseInt(arguments[1]) || 0;
        var k;
        if (n >= 0) {
          k = n;
        } else {
          k = len + n;
          if (k < 0) {
            k = 0;
          }
        }
        var currentElement;
        while (k < len) {
          currentElement = O[k];
          if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
            return true;
          }
          k++;
        }
        return false;
      }
    });
  }

  if (typeof FEATURE_NO_ES2015 === 'undefined') {

    (function () {
      var needsFix = false;

      try {
        var s = Object.keys('a');
        needsFix = s.length !== 1 || s[0] !== '0';
      } catch (e) {
        needsFix = true;
      }

      if (needsFix) {
        Object.keys = function () {
          var hasOwnProperty = Object.prototype.hasOwnProperty,
              hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
              dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
              dontEnumsLength = dontEnums.length;

          return function (obj) {
            if (obj === undefined || obj === null) {
              throw TypeError('Cannot convert undefined or null to object');
            }

            obj = Object(obj);

            var result = [],
                prop,
                i;

            for (prop in obj) {
              if (hasOwnProperty.call(obj, prop)) {
                result.push(prop);
              }
            }

            if (hasDontEnumBug) {
              for (i = 0; i < dontEnumsLength; i++) {
                if (hasOwnProperty.call(obj, dontEnums[i])) {
                  result.push(dontEnums[i]);
                }
              }
            }

            return result;
          };
        }();
      }
    })();

    (function (O) {
      if ('assign' in O) {
        return;
      }

      O.defineProperty(O, 'assign', {
        configurable: true,
        writable: true,
        value: function () {
          var gOPS = O.getOwnPropertySymbols,
              pIE = O.propertyIsEnumerable,
              filterOS = gOPS ? function (self) {
            return gOPS(self).filter(pIE, self);
          } : function () {
            return Array.prototype;
          };

          return function assign(where) {
            if (gOPS && !(where instanceof O)) {
              console.warn('problematic Symbols', where);
            }

            function set(keyOrSymbol) {
              where[keyOrSymbol] = arg[keyOrSymbol];
            }

            for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var arg = arguments[i];

              if (arg === null || arg === undefined) {
                continue;
              }

              O.keys(arg).concat(filterOS(arg)).forEach(set);
            }

            return where;
          };
        }()
      });
    })(Object);

    if (!Object.is) {
      Object.is = function (x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      };
    }
  }

  if (typeof FEATURE_NO_ES2015 === 'undefined') {

    (function (global) {
      var i;

      var defineProperty = Object.defineProperty,
          is = function is(a, b) {
        return a === b || a !== a && b !== b;
      };

      if (typeof WeakMap == 'undefined') {
        global.WeakMap = createCollection({
          'delete': sharedDelete,

          clear: sharedClear,

          get: sharedGet,

          has: mapHas,

          set: sharedSet
        }, true);
      }

      if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
        var _createCollection;

        global.Map = createCollection((_createCollection = {
          'delete': sharedDelete,

          has: mapHas,

          get: sharedGet,

          set: sharedSet,

          keys: sharedKeys,

          values: sharedValues,

          entries: mapEntries,

          forEach: sharedForEach,

          clear: sharedClear
        }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));
      }

      if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
        var _createCollection2;

        global.Set = createCollection((_createCollection2 = {
          has: setHas,

          add: sharedAdd,

          'delete': sharedDelete,

          clear: sharedClear,

          keys: sharedValues,
          values: sharedValues,

          entries: setEntries,

          forEach: sharedForEach
        }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));
      }

      if (typeof WeakSet == 'undefined') {
        global.WeakSet = createCollection({
          'delete': sharedDelete,

          add: sharedAdd,

          clear: sharedClear,

          has: setHas
        }, true);
      }

      function createCollection(proto, objectOnly) {
        function Collection(a) {
          if (!this || this.constructor !== Collection) return new Collection(a);
          this._keys = [];
          this._values = [];
          this._itp = [];
          this.objectOnly = objectOnly;

          if (a) init.call(this, a);
        }

        if (!objectOnly) {
          defineProperty(proto, 'size', {
            get: sharedSize
          });
        }

        proto.constructor = Collection;
        Collection.prototype = proto;

        return Collection;
      }

      function init(a) {
        var i;

        if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {
            this.set(a[0], a[1]);
          }, this);
      }

      function sharedDelete(key) {
        if (this.has(key)) {
          this._keys.splice(i, 1);
          this._values.splice(i, 1);

          this._itp.forEach(function (p) {
            if (i < p[0]) p[0]--;
          });
        }

        return -1 < i;
      };

      function sharedGet(key) {
        return this.has(key) ? this._values[i] : undefined;
      }

      function has(list, key) {
        if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");

        if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
        return -1 < i;
      }

      function setHas(value) {
        return has.call(this, this._values, value);
      }

      function mapHas(value) {
        return has.call(this, this._keys, value);
      }

      function sharedSet(key, value) {
        this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
        return this;
      }

      function sharedAdd(value) {
        if (!this.has(value)) this._values.push(value);
        return this;
      }

      function sharedClear() {
        (this._keys || 0).length = this._values.length = 0;
      }

      function sharedKeys() {
        return sharedIterator(this._itp, this._keys);
      }

      function sharedValues() {
        return sharedIterator(this._itp, this._values);
      }

      function mapEntries() {
        return sharedIterator(this._itp, this._keys, this._values);
      }

      function setEntries() {
        return sharedIterator(this._itp, this._values, this._values);
      }

      function sharedIterator(itp, array, array2) {
        var _ref;

        var p = [0],
            done = false;
        itp.push(p);
        return _ref = {}, _ref[Symbol.iterator] = function () {
          return this;
        }, _ref.next = function next() {
          var v,
              k = p[0];
          if (!done && k < array.length) {
            v = array2 ? [array[k], array2[k]] : array[k];
            p[0]++;
          } else {
            done = true;
            itp.splice(itp.indexOf(p), 1);
          }
          return { done: done, value: v };
        }, _ref;
      }

      function sharedSize() {
        return this._values.length;
      }

      function sharedForEach(callback, context) {
        var it = this.entries();
        for (;;) {
          var r = it.next();
          if (r.done) break;
          callback.call(context, r.value[1], r.value[0], this);
        }
      }
    })(_aureliaPal.PLATFORM.global);
  }

  if (typeof FEATURE_NO_ES2015 === 'undefined') {
    (function () {

      var bind = Function.prototype.bind;

      if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
        _aureliaPal.PLATFORM.global.Reflect = {};
      }

      if (typeof Reflect.defineProperty !== 'function') {
        Reflect.defineProperty = function (target, propertyKey, descriptor) {
          if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {
            throw new TypeError('Reflect.defineProperty called on non-object');
          }
          try {
            Object.defineProperty(target, propertyKey, descriptor);
            return true;
          } catch (e) {
            return false;
          }
        };
      }

      if (typeof Reflect.construct !== 'function') {
        Reflect.construct = function (Target, args) {
          if (args) {
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
          }

          var a = [null];
          a.push.apply(a, args);
          return new (bind.apply(Target, a))();
        };
      }

      if (typeof Reflect.ownKeys !== 'function') {
        Reflect.ownKeys = function (o) {
          return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
        };
      }
    })();
  }

  if (typeof FEATURE_NO_ESNEXT === 'undefined') {
    (function () {

      var emptyMetadata = Object.freeze({});
      var metadataContainerKey = '__metadata__';

      if (typeof Reflect.getOwnMetadata !== 'function') {
        Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {
          if (target.hasOwnProperty(metadataContainerKey)) {
            return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];
          }
        };
      }

      if (typeof Reflect.defineMetadata !== 'function') {
        Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {
          var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
          var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
          targetContainer[metadataKey] = metadataValue;
        };
      }

      if (typeof Reflect.metadata !== 'function') {
        Reflect.metadata = function (metadataKey, metadataValue) {
          return function (target, targetKey) {
            Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
          };
        };
      }
    })();
  }
});
define('aurelia-task-queue',['exports', 'aurelia-pal'], function (exports, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TaskQueue = undefined;

  

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  var hasSetImmediate = typeof setImmediate === 'function';
  var stackSeparator = '\nEnqueued in TaskQueue by:\n';
  var microStackSeparator = '\nEnqueued in MicroTaskQueue by:\n';

  function makeRequestFlushFromMutationObserver(flush) {
    var toggle = 1;
    var observer = _aureliaPal.DOM.createMutationObserver(flush);
    var node = _aureliaPal.DOM.createTextNode('');
    observer.observe(node, { characterData: true });
    return function requestFlush() {
      toggle = -toggle;
      node.data = toggle;
    };
  }

  function makeRequestFlushFromTimer(flush) {
    return function requestFlush() {
      var timeoutHandle = setTimeout(handleFlushTimer, 0);

      var intervalHandle = setInterval(handleFlushTimer, 50);
      function handleFlushTimer() {
        clearTimeout(timeoutHandle);
        clearInterval(intervalHandle);
        flush();
      }
    };
  }

  function onError(error, task, longStacks) {
    if (longStacks && task.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null) {
      error.stack = filterFlushStack(error.stack) + task.stack;
    }

    if ('onError' in task) {
      task.onError(error);
    } else if (hasSetImmediate) {
      setImmediate(function () {
        throw error;
      });
    } else {
      setTimeout(function () {
        throw error;
      }, 0);
    }
  }

  var TaskQueue = exports.TaskQueue = function () {
    function TaskQueue() {
      var _this = this;

      

      this.flushing = false;
      this.longStacks = false;

      this.microTaskQueue = [];
      this.microTaskQueueCapacity = 1024;
      this.taskQueue = [];

      if (_aureliaPal.FEATURE.mutationObserver) {
        this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(function () {
          return _this.flushMicroTaskQueue();
        });
      } else {
        this.requestFlushMicroTaskQueue = makeRequestFlushFromTimer(function () {
          return _this.flushMicroTaskQueue();
        });
      }

      this.requestFlushTaskQueue = makeRequestFlushFromTimer(function () {
        return _this.flushTaskQueue();
      });
    }

    TaskQueue.prototype._flushQueue = function _flushQueue(queue, capacity) {
      var index = 0;
      var task = void 0;

      try {
        this.flushing = true;
        while (index < queue.length) {
          task = queue[index];
          if (this.longStacks) {
            this.stack = typeof task.stack === 'string' ? task.stack : undefined;
          }
          task.call();
          index++;

          if (index > capacity) {
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
              queue[scan] = queue[scan + index];
            }

            queue.length -= index;
            index = 0;
          }
        }
      } catch (error) {
        onError(error, task, this.longStacks);
      } finally {
        this.flushing = false;
      }
    };

    TaskQueue.prototype.queueMicroTask = function queueMicroTask(task) {
      if (this.microTaskQueue.length < 1) {
        this.requestFlushMicroTaskQueue();
      }

      if (this.longStacks) {
        task.stack = this.prepareQueueStack(microStackSeparator);
      }

      this.microTaskQueue.push(task);
    };

    TaskQueue.prototype.queueTask = function queueTask(task) {
      if (this.taskQueue.length < 1) {
        this.requestFlushTaskQueue();
      }

      if (this.longStacks) {
        task.stack = this.prepareQueueStack(stackSeparator);
      }

      this.taskQueue.push(task);
    };

    TaskQueue.prototype.flushTaskQueue = function flushTaskQueue() {
      var queue = this.taskQueue;
      this.taskQueue = [];
      this._flushQueue(queue, Number.MAX_VALUE);
    };

    TaskQueue.prototype.flushMicroTaskQueue = function flushMicroTaskQueue() {
      var queue = this.microTaskQueue;
      this._flushQueue(queue, this.microTaskQueueCapacity);
      queue.length = 0;
    };

    TaskQueue.prototype.prepareQueueStack = function prepareQueueStack(separator) {
      var stack = separator + filterQueueStack(captureStack());

      if (typeof this.stack === 'string') {
        stack = filterFlushStack(stack) + this.stack;
      }

      return stack;
    };

    return TaskQueue;
  }();

  function captureStack() {
    var error = new Error();

    if (error.stack) {
      return error.stack;
    }

    try {
      throw error;
    } catch (e) {
      return e.stack;
    }
  }

  function filterQueueStack(stack) {
    return stack.replace(/^[\s\S]*?\bqueue(Micro)?Task\b[^\n]*\n/, '');
  }

  function filterFlushStack(stack) {
    var index = stack.lastIndexOf('flushMicroTaskQueue');

    if (index < 0) {
      index = stack.lastIndexOf('flushTaskQueue');
      if (index < 0) {
        return stack;
      }
    }

    index = stack.lastIndexOf('\n', index);

    return index < 0 ? stack : stack.substr(0, index);
  }
});
define('aurelia-templating',['exports', 'aurelia-logging', 'aurelia-metadata', 'aurelia-pal', 'aurelia-path', 'aurelia-loader', 'aurelia-dependency-injection', 'aurelia-binding', 'aurelia-task-queue'], function (exports, _aureliaLogging, _aureliaMetadata, _aureliaPal, _aureliaPath, _aureliaLoader, _aureliaDependencyInjection, _aureliaBinding, _aureliaTaskQueue) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TemplatingEngine = exports.ElementConfigResource = exports.CompositionEngine = exports.SwapStrategies = exports.HtmlBehaviorResource = exports.BindableProperty = exports.BehaviorPropertyObserver = exports.Controller = exports.ViewEngine = exports.ModuleAnalyzer = exports.ResourceDescription = exports.ResourceModule = exports.ViewCompiler = exports.ViewFactory = exports.BoundViewFactory = exports.ViewSlot = exports.View = exports.ViewResources = exports.ShadowDOM = exports.ShadowSlot = exports.PassThroughSlot = exports.SlotCustomAttribute = exports.BindingLanguage = exports.ViewLocator = exports.InlineViewStrategy = exports.TemplateRegistryViewStrategy = exports.NoViewStrategy = exports.ConventionalViewStrategy = exports.RelativeViewStrategy = exports.viewStrategy = exports.TargetInstruction = exports.BehaviorInstruction = exports.ViewCompileInstruction = exports.ResourceLoadContext = exports.ElementEvents = exports.ViewEngineHooksResource = exports.CompositionTransaction = exports.CompositionTransactionOwnershipToken = exports.CompositionTransactionNotifier = exports.Animator = exports.animationEvent = undefined;
  exports._hyphenate = _hyphenate;
  exports._isAllWhitespace = _isAllWhitespace;
  exports.viewEngineHooks = viewEngineHooks;
  exports.children = children;
  exports.child = child;
  exports.resource = resource;
  exports.behavior = behavior;
  exports.customElement = customElement;
  exports.customAttribute = customAttribute;
  exports.templateController = templateController;
  exports.bindable = bindable;
  exports.dynamicOptions = dynamicOptions;
  exports.useShadowDOM = useShadowDOM;
  exports.processAttributes = processAttributes;
  exports.processContent = processContent;
  exports.containerless = containerless;
  exports.useViewStrategy = useViewStrategy;
  exports.useView = useView;
  exports.inlineView = inlineView;
  exports.noView = noView;
  exports.elementConfig = elementConfig;
  exports.viewResources = viewResources;

  var LogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _class, _temp, _dec, _class2, _dec2, _class3, _dec3, _class4, _dec4, _class5, _dec5, _class6, _class7, _temp2, _dec6, _class8, _class9, _temp3, _class11, _dec7, _class13, _dec8, _class14, _class15, _temp4, _dec9, _class16, _dec10, _class17, _dec11, _class18;

  

  var animationEvent = exports.animationEvent = {
    enterBegin: 'animation:enter:begin',
    enterActive: 'animation:enter:active',
    enterDone: 'animation:enter:done',
    enterTimeout: 'animation:enter:timeout',

    leaveBegin: 'animation:leave:begin',
    leaveActive: 'animation:leave:active',
    leaveDone: 'animation:leave:done',
    leaveTimeout: 'animation:leave:timeout',

    staggerNext: 'animation:stagger:next',

    removeClassBegin: 'animation:remove-class:begin',
    removeClassActive: 'animation:remove-class:active',
    removeClassDone: 'animation:remove-class:done',
    removeClassTimeout: 'animation:remove-class:timeout',

    addClassBegin: 'animation:add-class:begin',
    addClassActive: 'animation:add-class:active',
    addClassDone: 'animation:add-class:done',
    addClassTimeout: 'animation:add-class:timeout',

    animateBegin: 'animation:animate:begin',
    animateActive: 'animation:animate:active',
    animateDone: 'animation:animate:done',
    animateTimeout: 'animation:animate:timeout',

    sequenceBegin: 'animation:sequence:begin',
    sequenceDone: 'animation:sequence:done'
  };

  var Animator = exports.Animator = function () {
    function Animator() {
      
    }

    Animator.prototype.enter = function enter(element) {
      return Promise.resolve(false);
    };

    Animator.prototype.leave = function leave(element) {
      return Promise.resolve(false);
    };

    Animator.prototype.removeClass = function removeClass(element, className) {
      element.classList.remove(className);
      return Promise.resolve(false);
    };

    Animator.prototype.addClass = function addClass(element, className) {
      element.classList.add(className);
      return Promise.resolve(false);
    };

    Animator.prototype.animate = function animate(element, className) {
      return Promise.resolve(false);
    };

    Animator.prototype.runSequence = function runSequence(animations) {};

    Animator.prototype.registerEffect = function registerEffect(effectName, properties) {};

    Animator.prototype.unregisterEffect = function unregisterEffect(effectName) {};

    return Animator;
  }();

  var CompositionTransactionNotifier = exports.CompositionTransactionNotifier = function () {
    function CompositionTransactionNotifier(owner) {
      

      this.owner = owner;
      this.owner._compositionCount++;
    }

    CompositionTransactionNotifier.prototype.done = function done() {
      this.owner._compositionCount--;
      this.owner._tryCompleteTransaction();
    };

    return CompositionTransactionNotifier;
  }();

  var CompositionTransactionOwnershipToken = exports.CompositionTransactionOwnershipToken = function () {
    function CompositionTransactionOwnershipToken(owner) {
      

      this.owner = owner;
      this.owner._ownershipToken = this;
      this.thenable = this._createThenable();
    }

    CompositionTransactionOwnershipToken.prototype.waitForCompositionComplete = function waitForCompositionComplete() {
      this.owner._tryCompleteTransaction();
      return this.thenable;
    };

    CompositionTransactionOwnershipToken.prototype.resolve = function resolve() {
      this._resolveCallback();
    };

    CompositionTransactionOwnershipToken.prototype._createThenable = function _createThenable() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._resolveCallback = resolve;
      });
    };

    return CompositionTransactionOwnershipToken;
  }();

  var CompositionTransaction = exports.CompositionTransaction = function () {
    function CompositionTransaction() {
      

      this._ownershipToken = null;
      this._compositionCount = 0;
    }

    CompositionTransaction.prototype.tryCapture = function tryCapture() {
      return this._ownershipToken === null ? new CompositionTransactionOwnershipToken(this) : null;
    };

    CompositionTransaction.prototype.enlist = function enlist() {
      return new CompositionTransactionNotifier(this);
    };

    CompositionTransaction.prototype._tryCompleteTransaction = function _tryCompleteTransaction() {
      if (this._compositionCount <= 0) {
        this._compositionCount = 0;

        if (this._ownershipToken !== null) {
          var token = this._ownershipToken;
          this._ownershipToken = null;
          token.resolve();
        }
      }
    };

    return CompositionTransaction;
  }();

  var capitalMatcher = /([A-Z])/g;

  function addHyphenAndLower(char) {
    return '-' + char.toLowerCase();
  }

  function _hyphenate(name) {
    return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
  }

  function _isAllWhitespace(node) {
    return !(node.auInterpolationTarget || /[^\t\n\r ]/.test(node.textContent));
  }

  var ViewEngineHooksResource = exports.ViewEngineHooksResource = function () {
    function ViewEngineHooksResource() {
      
    }

    ViewEngineHooksResource.prototype.initialize = function initialize(container, target) {
      this.instance = container.get(target);
    };

    ViewEngineHooksResource.prototype.register = function register(registry, name) {
      registry.registerViewEngineHooks(this.instance);
    };

    ViewEngineHooksResource.prototype.load = function load(container, target) {};

    ViewEngineHooksResource.convention = function convention(name) {
      if (name.endsWith('ViewEngineHooks')) {
        return new ViewEngineHooksResource();
      }
    };

    return ViewEngineHooksResource;
  }();

  function viewEngineHooks(target) {
    var deco = function deco(t) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ViewEngineHooksResource(), t);
    };

    return target ? deco(target) : deco;
  }

  var ElementEvents = exports.ElementEvents = function () {
    function ElementEvents(element) {
      

      this.element = element;
      this.subscriptions = {};
    }

    ElementEvents.prototype._enqueueHandler = function _enqueueHandler(handler) {
      this.subscriptions[handler.eventName] = this.subscriptions[handler.eventName] || [];
      this.subscriptions[handler.eventName].push(handler);
    };

    ElementEvents.prototype._dequeueHandler = function _dequeueHandler(handler) {
      var index = void 0;
      var subscriptions = this.subscriptions[handler.eventName];
      if (subscriptions) {
        index = subscriptions.indexOf(handler);
        if (index > -1) {
          subscriptions.splice(index, 1);
        }
      }
      return handler;
    };

    ElementEvents.prototype.publish = function publish(eventName) {
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var cancelable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var event = _aureliaPal.DOM.createCustomEvent(eventName, { cancelable: cancelable, bubbles: bubbles, detail: detail });
      this.element.dispatchEvent(event);
    };

    ElementEvents.prototype.subscribe = function subscribe(eventName, handler) {
      var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (typeof handler === 'function') {
        var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, false);
        return eventHandler;
      }

      return undefined;
    };

    ElementEvents.prototype.subscribeOnce = function subscribeOnce(eventName, handler) {
      var captureOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (typeof handler === 'function') {
        var eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, true);
        return eventHandler;
      }

      return undefined;
    };

    ElementEvents.prototype.dispose = function dispose(eventName) {
      if (eventName && typeof eventName === 'string') {
        var subscriptions = this.subscriptions[eventName];
        if (subscriptions) {
          while (subscriptions.length) {
            var subscription = subscriptions.pop();
            if (subscription) {
              subscription.dispose();
            }
          }
        }
      } else {
        this.disposeAll();
      }
    };

    ElementEvents.prototype.disposeAll = function disposeAll() {
      for (var key in this.subscriptions) {
        this.dispose(key);
      }
    };

    return ElementEvents;
  }();

  var EventHandlerImpl = function () {
    function EventHandlerImpl(owner, eventName, handler, captureOrOptions, once) {
      

      this.owner = owner;
      this.eventName = eventName;
      this.handler = handler;

      this.capture = typeof captureOrOptions === 'boolean' ? captureOrOptions : captureOrOptions.capture;
      this.bubbles = !this.capture;
      this.captureOrOptions = captureOrOptions;
      this.once = once;
      owner.element.addEventListener(eventName, this, captureOrOptions);
      owner._enqueueHandler(this);
    }

    EventHandlerImpl.prototype.handleEvent = function handleEvent(e) {
      var fn = this.handler;
      fn(e);
      if (this.once) {
        this.dispose();
      }
    };

    EventHandlerImpl.prototype.dispose = function dispose() {
      this.owner.element.removeEventListener(this.eventName, this, this.captureOrOptions);
      this.owner._dequeueHandler(this);
      this.owner = this.handler = null;
    };

    return EventHandlerImpl;
  }();

  var ResourceLoadContext = exports.ResourceLoadContext = function () {
    function ResourceLoadContext() {
      

      this.dependencies = {};
    }

    ResourceLoadContext.prototype.addDependency = function addDependency(url) {
      this.dependencies[url] = true;
    };

    ResourceLoadContext.prototype.hasDependency = function hasDependency(url) {
      return url in this.dependencies;
    };

    return ResourceLoadContext;
  }();

  var ViewCompileInstruction = exports.ViewCompileInstruction = function ViewCompileInstruction() {
    var targetShadowDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var compileSurrogate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    

    this.targetShadowDOM = targetShadowDOM;
    this.compileSurrogate = compileSurrogate;
    this.associatedModuleId = null;
  };

  ViewCompileInstruction.normal = new ViewCompileInstruction();

  var BehaviorInstruction = exports.BehaviorInstruction = function () {
    BehaviorInstruction.enhance = function enhance() {
      var instruction = new BehaviorInstruction();
      instruction.enhance = true;
      return instruction;
    };

    BehaviorInstruction.unitTest = function unitTest(type, attributes) {
      var instruction = new BehaviorInstruction();
      instruction.type = type;
      instruction.attributes = attributes || {};
      return instruction;
    };

    BehaviorInstruction.element = function element(node, type) {
      var instruction = new BehaviorInstruction();
      instruction.type = type;
      instruction.attributes = {};
      instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
      instruction.initiatedByBehavior = true;
      return instruction;
    };

    BehaviorInstruction.attribute = function attribute(attrName, type) {
      var instruction = new BehaviorInstruction();
      instruction.attrName = attrName;
      instruction.type = type || null;
      instruction.attributes = {};
      return instruction;
    };

    BehaviorInstruction.dynamic = function dynamic(host, viewModel, viewFactory) {
      var instruction = new BehaviorInstruction();
      instruction.host = host;
      instruction.viewModel = viewModel;
      instruction.viewFactory = viewFactory;
      instruction.inheritBindingContext = true;
      return instruction;
    };

    function BehaviorInstruction() {
      

      this.initiatedByBehavior = false;
      this.enhance = false;
      this.partReplacements = null;
      this.viewFactory = null;
      this.originalAttrName = null;
      this.skipContentProcessing = false;
      this.contentFactory = null;
      this.viewModel = null;
      this.anchorIsContainer = false;
      this.host = null;
      this.attributes = null;
      this.type = null;
      this.attrName = null;
      this.inheritBindingContext = false;
    }

    return BehaviorInstruction;
  }();

  BehaviorInstruction.normal = new BehaviorInstruction();

  var TargetInstruction = exports.TargetInstruction = (_temp = _class = function () {
    TargetInstruction.shadowSlot = function shadowSlot(parentInjectorId) {
      var instruction = new TargetInstruction();
      instruction.parentInjectorId = parentInjectorId;
      instruction.shadowSlot = true;
      return instruction;
    };

    TargetInstruction.contentExpression = function contentExpression(expression) {
      var instruction = new TargetInstruction();
      instruction.contentExpression = expression;
      return instruction;
    };

    TargetInstruction.lifting = function lifting(parentInjectorId, liftingInstruction) {
      var instruction = new TargetInstruction();
      instruction.parentInjectorId = parentInjectorId;
      instruction.expressions = TargetInstruction.noExpressions;
      instruction.behaviorInstructions = [liftingInstruction];
      instruction.viewFactory = liftingInstruction.viewFactory;
      instruction.providers = [liftingInstruction.type.target];
      instruction.lifting = true;
      return instruction;
    };

    TargetInstruction.normal = function normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
      var instruction = new TargetInstruction();
      instruction.injectorId = injectorId;
      instruction.parentInjectorId = parentInjectorId;
      instruction.providers = providers;
      instruction.behaviorInstructions = behaviorInstructions;
      instruction.expressions = expressions;
      instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
      instruction.elementInstruction = elementInstruction;
      return instruction;
    };

    TargetInstruction.surrogate = function surrogate(providers, behaviorInstructions, expressions, values) {
      var instruction = new TargetInstruction();
      instruction.expressions = expressions;
      instruction.behaviorInstructions = behaviorInstructions;
      instruction.providers = providers;
      instruction.values = values;
      return instruction;
    };

    function TargetInstruction() {
      

      this.injectorId = null;
      this.parentInjectorId = null;

      this.shadowSlot = false;
      this.slotName = null;
      this.slotFallbackFactory = null;

      this.contentExpression = null;

      this.expressions = null;
      this.behaviorInstructions = null;
      this.providers = null;

      this.viewFactory = null;

      this.anchorIsContainer = false;
      this.elementInstruction = null;
      this.lifting = false;

      this.values = null;
    }

    return TargetInstruction;
  }(), _class.noExpressions = Object.freeze([]), _temp);
  var viewStrategy = exports.viewStrategy = _aureliaMetadata.protocol.create('aurelia:view-strategy', {
    validate: function validate(target) {
      if (!(typeof target.loadViewFactory === 'function')) {
        return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
      }

      return true;
    },
    compose: function compose(target) {
      if (!(typeof target.makeRelativeTo === 'function')) {
        target.makeRelativeTo = _aureliaPal.PLATFORM.noop;
      }
    }
  });

  var RelativeViewStrategy = exports.RelativeViewStrategy = (_dec = viewStrategy(), _dec(_class2 = function () {
    function RelativeViewStrategy(path) {
      

      this.path = path;
      this.absolutePath = null;
    }

    RelativeViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
      if (this.absolutePath === null && this.moduleId) {
        this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, this.moduleId);
      }

      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext, target);
    };

    RelativeViewStrategy.prototype.makeRelativeTo = function makeRelativeTo(file) {
      if (this.absolutePath === null) {
        this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, file);
      }
    };

    return RelativeViewStrategy;
  }()) || _class2);
  var ConventionalViewStrategy = exports.ConventionalViewStrategy = (_dec2 = viewStrategy(), _dec2(_class3 = function () {
    function ConventionalViewStrategy(viewLocator, origin) {
      

      this.moduleId = origin.moduleId;
      this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
    }

    ConventionalViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext, target);
    };

    return ConventionalViewStrategy;
  }()) || _class3);
  var NoViewStrategy = exports.NoViewStrategy = (_dec3 = viewStrategy(), _dec3(_class4 = function () {
    function NoViewStrategy(dependencies, dependencyBaseUrl) {
      

      this.dependencies = dependencies || null;
      this.dependencyBaseUrl = dependencyBaseUrl || '';
    }

    NoViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
      var entry = this.entry;
      var dependencies = this.dependencies;

      if (entry && entry.factoryIsReady) {
        return Promise.resolve(null);
      }

      this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);

      entry.dependencies = [];
      entry.templateIsLoaded = true;

      if (dependencies !== null) {
        for (var i = 0, ii = dependencies.length; i < ii; ++i) {
          var current = dependencies[i];

          if (typeof current === 'string' || typeof current === 'function') {
            entry.addDependency(current);
          } else {
            entry.addDependency(current.from, current.as);
          }
        }
      }

      compileInstruction.associatedModuleId = this.moduleId;

      return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    };

    return NoViewStrategy;
  }()) || _class4);
  var TemplateRegistryViewStrategy = exports.TemplateRegistryViewStrategy = (_dec4 = viewStrategy(), _dec4(_class5 = function () {
    function TemplateRegistryViewStrategy(moduleId, entry) {
      

      this.moduleId = moduleId;
      this.entry = entry;
    }

    TemplateRegistryViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
      var entry = this.entry;

      if (entry.factoryIsReady) {
        return Promise.resolve(entry.factory);
      }

      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    };

    return TemplateRegistryViewStrategy;
  }()) || _class5);
  var InlineViewStrategy = exports.InlineViewStrategy = (_dec5 = viewStrategy(), _dec5(_class6 = function () {
    function InlineViewStrategy(markup, dependencies, dependencyBaseUrl) {
      

      this.markup = markup;
      this.dependencies = dependencies || null;
      this.dependencyBaseUrl = dependencyBaseUrl || '';
    }

    InlineViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
      var entry = this.entry;
      var dependencies = this.dependencies;

      if (entry && entry.factoryIsReady) {
        return Promise.resolve(entry.factory);
      }

      this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
      entry.template = _aureliaPal.DOM.createTemplateFromMarkup(this.markup);

      if (dependencies !== null) {
        for (var i = 0, ii = dependencies.length; i < ii; ++i) {
          var current = dependencies[i];

          if (typeof current === 'string' || typeof current === 'function') {
            entry.addDependency(current);
          } else {
            entry.addDependency(current.from, current.as);
          }
        }
      }

      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    };

    return InlineViewStrategy;
  }()) || _class6);
  var ViewLocator = exports.ViewLocator = (_temp2 = _class7 = function () {
    function ViewLocator() {
      
    }

    ViewLocator.prototype.getViewStrategy = function getViewStrategy(value) {
      if (!value) {
        return null;
      }

      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && 'getViewStrategy' in value) {
        var _origin = _aureliaMetadata.Origin.get(value.constructor);

        value = value.getViewStrategy();

        if (typeof value === 'string') {
          value = new RelativeViewStrategy(value);
        }

        viewStrategy.assert(value);

        if (_origin.moduleId) {
          value.makeRelativeTo(_origin.moduleId);
        }

        return value;
      }

      if (typeof value === 'string') {
        value = new RelativeViewStrategy(value);
      }

      if (viewStrategy.validate(value)) {
        return value;
      }

      if (typeof value !== 'function') {
        value = value.constructor;
      }

      var origin = _aureliaMetadata.Origin.get(value);
      var strategy = _aureliaMetadata.metadata.get(ViewLocator.viewStrategyMetadataKey, value);

      if (!strategy) {
        if (!origin.moduleId) {
          throw new Error('Cannot determine default view strategy for object.', value);
        }

        strategy = this.createFallbackViewStrategy(origin);
      } else if (origin.moduleId) {
        strategy.moduleId = origin.moduleId;
      }

      return strategy;
    };

    ViewLocator.prototype.createFallbackViewStrategy = function createFallbackViewStrategy(origin) {
      return new ConventionalViewStrategy(this, origin);
    };

    ViewLocator.prototype.convertOriginToViewUrl = function convertOriginToViewUrl(origin) {
      var moduleId = origin.moduleId;
      var id = moduleId.endsWith('.js') || moduleId.endsWith('.ts') ? moduleId.substring(0, moduleId.length - 3) : moduleId;
      return id + '.html';
    };

    return ViewLocator;
  }(), _class7.viewStrategyMetadataKey = 'aurelia:view-strategy', _temp2);


  function mi(name) {
    throw new Error('BindingLanguage must implement ' + name + '().');
  }

  var BindingLanguage = exports.BindingLanguage = function () {
    function BindingLanguage() {
      
    }

    BindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
      mi('inspectAttribute');
    };

    BindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, info, existingInstruction) {
      mi('createAttributeInstruction');
    };

    BindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
      mi('inspectTextContent');
    };

    return BindingLanguage;
  }();

  var noNodes = Object.freeze([]);

  var SlotCustomAttribute = exports.SlotCustomAttribute = (_dec6 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element), _dec6(_class8 = function () {
    function SlotCustomAttribute(element) {
      

      this.element = element;
      this.element.auSlotAttribute = this;
    }

    SlotCustomAttribute.prototype.valueChanged = function valueChanged(newValue, oldValue) {};

    return SlotCustomAttribute;
  }()) || _class8);

  var PassThroughSlot = exports.PassThroughSlot = function () {
    function PassThroughSlot(anchor, name, destinationName, fallbackFactory) {
      

      this.anchor = anchor;
      this.anchor.viewSlot = this;
      this.name = name;
      this.destinationName = destinationName;
      this.fallbackFactory = fallbackFactory;
      this.destinationSlot = null;
      this.projections = 0;
      this.contentView = null;

      var attr = new SlotCustomAttribute(this.anchor);
      attr.value = this.destinationName;
    }

    PassThroughSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
      if (this.contentView === null) {
        this.contentView = this.fallbackFactory.create(this.ownerView.container);
        this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);

        var slots = Object.create(null);
        slots[this.destinationSlot.name] = this.destinationSlot;

        ShadowDOM.distributeView(this.contentView, slots, projectionSource, index, this.destinationSlot.name);
      }
    };

    PassThroughSlot.prototype.passThroughTo = function passThroughTo(destinationSlot) {
      this.destinationSlot = destinationSlot;
    };

    PassThroughSlot.prototype.addNode = function addNode(view, node, projectionSource, index) {
      if (this.contentView !== null) {
        this.contentView.removeNodes();
        this.contentView.detached();
        this.contentView.unbind();
        this.contentView = null;
      }

      if (node.viewSlot instanceof PassThroughSlot) {
        node.viewSlot.passThroughTo(this);
        return;
      }

      this.projections++;
      this.destinationSlot.addNode(view, node, projectionSource, index);
    };

    PassThroughSlot.prototype.removeView = function removeView(view, projectionSource) {
      this.projections--;
      this.destinationSlot.removeView(view, projectionSource);

      if (this.needsFallbackRendering) {
        this.renderFallbackContent(null, noNodes, projectionSource);
      }
    };

    PassThroughSlot.prototype.removeAll = function removeAll(projectionSource) {
      this.projections = 0;
      this.destinationSlot.removeAll(projectionSource);

      if (this.needsFallbackRendering) {
        this.renderFallbackContent(null, noNodes, projectionSource);
      }
    };

    PassThroughSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
      this.destinationSlot.projectFrom(view, projectionSource);
    };

    PassThroughSlot.prototype.created = function created(ownerView) {
      this.ownerView = ownerView;
    };

    PassThroughSlot.prototype.bind = function bind(view) {
      if (this.contentView) {
        this.contentView.bind(view.bindingContext, view.overrideContext);
      }
    };

    PassThroughSlot.prototype.attached = function attached() {
      if (this.contentView) {
        this.contentView.attached();
      }
    };

    PassThroughSlot.prototype.detached = function detached() {
      if (this.contentView) {
        this.contentView.detached();
      }
    };

    PassThroughSlot.prototype.unbind = function unbind() {
      if (this.contentView) {
        this.contentView.unbind();
      }
    };

    _createClass(PassThroughSlot, [{
      key: 'needsFallbackRendering',
      get: function get() {
        return this.fallbackFactory && this.projections === 0;
      }
    }]);

    return PassThroughSlot;
  }();

  var ShadowSlot = exports.ShadowSlot = function () {
    function ShadowSlot(anchor, name, fallbackFactory) {
      

      this.anchor = anchor;
      this.anchor.isContentProjectionSource = true;
      this.anchor.viewSlot = this;
      this.name = name;
      this.fallbackFactory = fallbackFactory;
      this.contentView = null;
      this.projections = 0;
      this.children = [];
      this.projectFromAnchors = null;
      this.destinationSlots = null;
    }

    ShadowSlot.prototype.addNode = function addNode(view, node, projectionSource, index, destination) {
      if (this.contentView !== null) {
        this.contentView.removeNodes();
        this.contentView.detached();
        this.contentView.unbind();
        this.contentView = null;
      }

      if (node.viewSlot instanceof PassThroughSlot) {
        node.viewSlot.passThroughTo(this);
        return;
      }

      if (this.destinationSlots !== null) {
        ShadowDOM.distributeNodes(view, [node], this.destinationSlots, this, index);
      } else {
        node.auOwnerView = view;
        node.auProjectionSource = projectionSource;
        node.auAssignedSlot = this;

        var anchor = this._findAnchor(view, node, projectionSource, index);
        var parent = anchor.parentNode;

        parent.insertBefore(node, anchor);
        this.children.push(node);
        this.projections++;
      }
    };

    ShadowSlot.prototype.removeView = function removeView(view, projectionSource) {
      if (this.destinationSlots !== null) {
        ShadowDOM.undistributeView(view, this.destinationSlots, this);
      } else if (this.contentView && this.contentView.hasSlots) {
        ShadowDOM.undistributeView(view, this.contentView.slots, projectionSource);
      } else {
        var found = this.children.find(function (x) {
          return x.auSlotProjectFrom === projectionSource;
        });
        if (found) {
          var _children = found.auProjectionChildren;

          for (var i = 0, ii = _children.length; i < ii; ++i) {
            var _child = _children[i];

            if (_child.auOwnerView === view) {
              _children.splice(i, 1);
              view.fragment.appendChild(_child);
              i--;ii--;
              this.projections--;
            }
          }

          if (this.needsFallbackRendering) {
            this.renderFallbackContent(view, noNodes, projectionSource);
          }
        }
      }
    };

    ShadowSlot.prototype.removeAll = function removeAll(projectionSource) {
      if (this.destinationSlots !== null) {
        ShadowDOM.undistributeAll(this.destinationSlots, this);
      } else if (this.contentView && this.contentView.hasSlots) {
        ShadowDOM.undistributeAll(this.contentView.slots, projectionSource);
      } else {
        var found = this.children.find(function (x) {
          return x.auSlotProjectFrom === projectionSource;
        });

        if (found) {
          var _children2 = found.auProjectionChildren;
          for (var i = 0, ii = _children2.length; i < ii; ++i) {
            var _child2 = _children2[i];
            _child2.auOwnerView.fragment.appendChild(_child2);
            this.projections--;
          }

          found.auProjectionChildren = [];

          if (this.needsFallbackRendering) {
            this.renderFallbackContent(null, noNodes, projectionSource);
          }
        }
      }
    };

    ShadowSlot.prototype._findAnchor = function _findAnchor(view, node, projectionSource, index) {
      if (projectionSource) {
        var found = this.children.find(function (x) {
          return x.auSlotProjectFrom === projectionSource;
        });
        if (found) {
          if (index !== undefined) {
            var _children3 = found.auProjectionChildren;
            var viewIndex = -1;
            var lastView = void 0;

            for (var i = 0, ii = _children3.length; i < ii; ++i) {
              var current = _children3[i];

              if (current.auOwnerView !== lastView) {
                viewIndex++;
                lastView = current.auOwnerView;

                if (viewIndex >= index && lastView !== view) {
                  _children3.splice(i, 0, node);
                  return current;
                }
              }
            }
          }

          found.auProjectionChildren.push(node);
          return found;
        }
      }

      return this.anchor;
    };

    ShadowSlot.prototype.projectTo = function projectTo(slots) {
      this.destinationSlots = slots;
    };

    ShadowSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
      var anchor = _aureliaPal.DOM.createComment('anchor');
      var parent = this.anchor.parentNode;
      anchor.auSlotProjectFrom = projectionSource;
      anchor.auOwnerView = view;
      anchor.auProjectionChildren = [];
      parent.insertBefore(anchor, this.anchor);
      this.children.push(anchor);

      if (this.projectFromAnchors === null) {
        this.projectFromAnchors = [];
      }

      this.projectFromAnchors.push(anchor);
    };

    ShadowSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
      if (this.contentView === null) {
        this.contentView = this.fallbackFactory.create(this.ownerView.container);
        this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
        this.contentView.insertNodesBefore(this.anchor);
      }

      if (this.contentView.hasSlots) {
        var slots = this.contentView.slots;
        var projectFromAnchors = this.projectFromAnchors;

        if (projectFromAnchors !== null) {
          for (var slotName in slots) {
            var slot = slots[slotName];

            for (var i = 0, ii = projectFromAnchors.length; i < ii; ++i) {
              var anchor = projectFromAnchors[i];
              slot.projectFrom(anchor.auOwnerView, anchor.auSlotProjectFrom);
            }
          }
        }

        this.fallbackSlots = slots;
        ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index);
      }
    };

    ShadowSlot.prototype.created = function created(ownerView) {
      this.ownerView = ownerView;
    };

    ShadowSlot.prototype.bind = function bind(view) {
      if (this.contentView) {
        this.contentView.bind(view.bindingContext, view.overrideContext);
      }
    };

    ShadowSlot.prototype.attached = function attached() {
      if (this.contentView) {
        this.contentView.attached();
      }
    };

    ShadowSlot.prototype.detached = function detached() {
      if (this.contentView) {
        this.contentView.detached();
      }
    };

    ShadowSlot.prototype.unbind = function unbind() {
      if (this.contentView) {
        this.contentView.unbind();
      }
    };

    _createClass(ShadowSlot, [{
      key: 'needsFallbackRendering',
      get: function get() {
        return this.fallbackFactory && this.projections === 0;
      }
    }]);

    return ShadowSlot;
  }();

  var ShadowDOM = exports.ShadowDOM = (_temp3 = _class9 = function () {
    function ShadowDOM() {
      
    }

    ShadowDOM.getSlotName = function getSlotName(node) {
      if (node.auSlotAttribute === undefined) {
        return ShadowDOM.defaultSlotKey;
      }

      return node.auSlotAttribute.value;
    };

    ShadowDOM.distributeView = function distributeView(view, slots, projectionSource, index, destinationOverride) {
      var nodes = void 0;

      if (view === null) {
        nodes = noNodes;
      } else {
        var childNodes = view.fragment.childNodes;
        var ii = childNodes.length;
        nodes = new Array(ii);

        for (var i = 0; i < ii; ++i) {
          nodes[i] = childNodes[i];
        }
      }

      ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride);
    };

    ShadowDOM.undistributeView = function undistributeView(view, slots, projectionSource) {
      for (var slotName in slots) {
        slots[slotName].removeView(view, projectionSource);
      }
    };

    ShadowDOM.undistributeAll = function undistributeAll(slots, projectionSource) {
      for (var slotName in slots) {
        slots[slotName].removeAll(projectionSource);
      }
    };

    ShadowDOM.distributeNodes = function distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride) {
      for (var i = 0, ii = nodes.length; i < ii; ++i) {
        var currentNode = nodes[i];
        var nodeType = currentNode.nodeType;

        if (currentNode.isContentProjectionSource) {
          currentNode.viewSlot.projectTo(slots);

          for (var slotName in slots) {
            slots[slotName].projectFrom(view, currentNode.viewSlot);
          }

          nodes.splice(i, 1);
          ii--;i--;
        } else if (nodeType === 1 || nodeType === 3 || currentNode.viewSlot instanceof PassThroughSlot) {
          if (nodeType === 3 && _isAllWhitespace(currentNode)) {
            nodes.splice(i, 1);
            ii--;i--;
          } else {
            var found = slots[destinationOverride || ShadowDOM.getSlotName(currentNode)];

            if (found) {
              found.addNode(view, currentNode, projectionSource, index);
              nodes.splice(i, 1);
              ii--;i--;
            }
          }
        } else {
          nodes.splice(i, 1);
          ii--;i--;
        }
      }

      for (var _slotName in slots) {
        var slot = slots[_slotName];

        if (slot.needsFallbackRendering) {
          slot.renderFallbackContent(view, nodes, projectionSource, index);
        }
      }
    };

    return ShadowDOM;
  }(), _class9.defaultSlotKey = '__au-default-slot-key__', _temp3);


  function register(lookup, name, resource, type) {
    if (!name) {
      return;
    }

    var existing = lookup[name];
    if (existing) {
      if (existing !== resource) {
        throw new Error('Attempted to register ' + type + ' when one with the same name already exists. Name: ' + name + '.');
      }

      return;
    }

    lookup[name] = resource;
  }

  var ViewResources = exports.ViewResources = function () {
    function ViewResources(parent, viewUrl) {
      

      this.bindingLanguage = null;

      this.parent = parent || null;
      this.hasParent = this.parent !== null;
      this.viewUrl = viewUrl || '';
      this.lookupFunctions = {
        valueConverters: this.getValueConverter.bind(this),
        bindingBehaviors: this.getBindingBehavior.bind(this)
      };
      this.attributes = Object.create(null);
      this.elements = Object.create(null);
      this.valueConverters = Object.create(null);
      this.bindingBehaviors = Object.create(null);
      this.attributeMap = Object.create(null);
      this.values = Object.create(null);
      this.beforeCompile = this.afterCompile = this.beforeCreate = this.afterCreate = this.beforeBind = this.beforeUnbind = false;
    }

    ViewResources.prototype._tryAddHook = function _tryAddHook(obj, name) {
      if (typeof obj[name] === 'function') {
        var func = obj[name].bind(obj);
        var counter = 1;
        var callbackName = void 0;

        while (this[callbackName = name + counter.toString()] !== undefined) {
          counter++;
        }

        this[name] = true;
        this[callbackName] = func;
      }
    };

    ViewResources.prototype._invokeHook = function _invokeHook(name, one, two, three, four) {
      if (this.hasParent) {
        this.parent._invokeHook(name, one, two, three, four);
      }

      if (this[name]) {
        this[name + '1'](one, two, three, four);

        var callbackName = name + '2';
        if (this[callbackName]) {
          this[callbackName](one, two, three, four);

          callbackName = name + '3';
          if (this[callbackName]) {
            this[callbackName](one, two, three, four);

            var counter = 4;

            while (this[callbackName = name + counter.toString()] !== undefined) {
              this[callbackName](one, two, three, four);
              counter++;
            }
          }
        }
      }
    };

    ViewResources.prototype.registerViewEngineHooks = function registerViewEngineHooks(hooks) {
      this._tryAddHook(hooks, 'beforeCompile');
      this._tryAddHook(hooks, 'afterCompile');
      this._tryAddHook(hooks, 'beforeCreate');
      this._tryAddHook(hooks, 'afterCreate');
      this._tryAddHook(hooks, 'beforeBind');
      this._tryAddHook(hooks, 'beforeUnbind');
    };

    ViewResources.prototype.getBindingLanguage = function getBindingLanguage(bindingLanguageFallback) {
      return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
    };

    ViewResources.prototype.patchInParent = function patchInParent(newParent) {
      var originalParent = this.parent;

      this.parent = newParent || null;
      this.hasParent = this.parent !== null;

      if (newParent.parent === null) {
        newParent.parent = originalParent;
        newParent.hasParent = originalParent !== null;
      }
    };

    ViewResources.prototype.relativeToView = function relativeToView(path) {
      return (0, _aureliaPath.relativeToFile)(path, this.viewUrl);
    };

    ViewResources.prototype.registerElement = function registerElement(tagName, behavior) {
      register(this.elements, tagName, behavior, 'an Element');
    };

    ViewResources.prototype.getElement = function getElement(tagName) {
      return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
    };

    ViewResources.prototype.mapAttribute = function mapAttribute(attribute) {
      return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
    };

    ViewResources.prototype.registerAttribute = function registerAttribute(attribute, behavior, knownAttribute) {
      this.attributeMap[attribute] = knownAttribute;
      register(this.attributes, attribute, behavior, 'an Attribute');
    };

    ViewResources.prototype.getAttribute = function getAttribute(attribute) {
      return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
    };

    ViewResources.prototype.registerValueConverter = function registerValueConverter(name, valueConverter) {
      register(this.valueConverters, name, valueConverter, 'a ValueConverter');
    };

    ViewResources.prototype.getValueConverter = function getValueConverter(name) {
      return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
    };

    ViewResources.prototype.registerBindingBehavior = function registerBindingBehavior(name, bindingBehavior) {
      register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
    };

    ViewResources.prototype.getBindingBehavior = function getBindingBehavior(name) {
      return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
    };

    ViewResources.prototype.registerValue = function registerValue(name, value) {
      register(this.values, name, value, 'a value');
    };

    ViewResources.prototype.getValue = function getValue(name) {
      return this.values[name] || (this.hasParent ? this.parent.getValue(name) : null);
    };

    return ViewResources;
  }();

  var View = exports.View = function () {
    function View(container, viewFactory, fragment, controllers, bindings, children, slots) {
      

      this.container = container;
      this.viewFactory = viewFactory;
      this.resources = viewFactory.resources;
      this.fragment = fragment;
      this.firstChild = fragment.firstChild;
      this.lastChild = fragment.lastChild;
      this.controllers = controllers;
      this.bindings = bindings;
      this.children = children;
      this.slots = slots;
      this.hasSlots = false;
      this.fromCache = false;
      this.isBound = false;
      this.isAttached = false;
      this.bindingContext = null;
      this.overrideContext = null;
      this.controller = null;
      this.viewModelScope = null;
      this.animatableElement = undefined;
      this._isUserControlled = false;
      this.contentView = null;

      for (var key in slots) {
        this.hasSlots = true;
        break;
      }
    }

    View.prototype.returnToCache = function returnToCache() {
      this.viewFactory.returnViewToCache(this);
    };

    View.prototype.created = function created() {
      var i = void 0;
      var ii = void 0;
      var controllers = this.controllers;

      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].created(this);
      }
    };

    View.prototype.bind = function bind(bindingContext, overrideContext, _systemUpdate) {
      var controllers = void 0;
      var bindings = void 0;
      var children = void 0;
      var i = void 0;
      var ii = void 0;

      if (_systemUpdate && this._isUserControlled) {
        return;
      }

      if (this.isBound) {
        if (this.bindingContext === bindingContext) {
          return;
        }

        this.unbind();
      }

      this.isBound = true;
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(bindingContext);

      this.resources._invokeHook('beforeBind', this);

      bindings = this.bindings;
      for (i = 0, ii = bindings.length; i < ii; ++i) {
        bindings[i].bind(this);
      }

      if (this.viewModelScope !== null) {
        bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
        this.viewModelScope = null;
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].bind(this);
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].bind(bindingContext, overrideContext, true);
      }

      if (this.hasSlots) {
        ShadowDOM.distributeView(this.contentView, this.slots);
      }
    };

    View.prototype.addBinding = function addBinding(binding) {
      this.bindings.push(binding);

      if (this.isBound) {
        binding.bind(this);
      }
    };

    View.prototype.unbind = function unbind() {
      var controllers = void 0;
      var bindings = void 0;
      var children = void 0;
      var i = void 0;
      var ii = void 0;

      if (this.isBound) {
        this.isBound = false;
        this.resources._invokeHook('beforeUnbind', this);

        if (this.controller !== null) {
          this.controller.unbind();
        }

        bindings = this.bindings;
        for (i = 0, ii = bindings.length; i < ii; ++i) {
          bindings[i].unbind();
        }

        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].unbind();
        }

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].unbind();
        }

        this.bindingContext = null;
        this.overrideContext = null;
      }
    };

    View.prototype.insertNodesBefore = function insertNodesBefore(refNode) {
      refNode.parentNode.insertBefore(this.fragment, refNode);
    };

    View.prototype.appendNodesTo = function appendNodesTo(parent) {
      parent.appendChild(this.fragment);
    };

    View.prototype.removeNodes = function removeNodes() {
      var fragment = this.fragment;
      var current = this.firstChild;
      var end = this.lastChild;
      var next = void 0;

      while (current) {
        next = current.nextSibling;
        fragment.appendChild(current);

        if (current === end) {
          break;
        }

        current = next;
      }
    };

    View.prototype.attached = function attached() {
      var controllers = void 0;
      var children = void 0;
      var i = void 0;
      var ii = void 0;

      if (this.isAttached) {
        return;
      }

      this.isAttached = true;

      if (this.controller !== null) {
        this.controller.attached();
      }

      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].attached();
      }

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].attached();
      }
    };

    View.prototype.detached = function detached() {
      var controllers = void 0;
      var children = void 0;
      var i = void 0;
      var ii = void 0;

      if (this.isAttached) {
        this.isAttached = false;

        if (this.controller !== null) {
          this.controller.detached();
        }

        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].detached();
        }

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].detached();
        }
      }
    };

    return View;
  }();

  function getAnimatableElement(view) {
    if (view.animatableElement !== undefined) {
      return view.animatableElement;
    }

    var current = view.firstChild;

    while (current && current.nodeType !== 1) {
      current = current.nextSibling;
    }

    if (current && current.nodeType === 1) {
      return view.animatableElement = current.classList.contains('au-animate') ? current : null;
    }

    return view.animatableElement = null;
  }

  var ViewSlot = exports.ViewSlot = function () {
    function ViewSlot(anchor, anchorIsContainer) {
      var animator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Animator.instance;

      

      this.anchor = anchor;
      this.anchorIsContainer = anchorIsContainer;
      this.bindingContext = null;
      this.overrideContext = null;
      this.animator = animator;
      this.children = [];
      this.isBound = false;
      this.isAttached = false;
      this.contentSelectors = null;
      anchor.viewSlot = this;
      anchor.isContentProjectionSource = false;
    }

    ViewSlot.prototype.animateView = function animateView(view) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'enter';

      var animatableElement = getAnimatableElement(view);

      if (animatableElement !== null) {
        switch (direction) {
          case 'enter':
            return this.animator.enter(animatableElement);
          case 'leave':
            return this.animator.leave(animatableElement);
          default:
            throw new Error('Invalid animation direction: ' + direction);
        }
      }
    };

    ViewSlot.prototype.transformChildNodesIntoView = function transformChildNodesIntoView() {
      var parent = this.anchor;

      this.children.push({
        fragment: parent,
        firstChild: parent.firstChild,
        lastChild: parent.lastChild,
        returnToCache: function returnToCache() {},
        removeNodes: function removeNodes() {
          var last = void 0;

          while (last = parent.lastChild) {
            parent.removeChild(last);
          }
        },
        created: function created() {},
        bind: function bind() {},
        unbind: function unbind() {},
        attached: function attached() {},
        detached: function detached() {}
      });
    };

    ViewSlot.prototype.bind = function bind(bindingContext, overrideContext) {
      var i = void 0;
      var ii = void 0;
      var children = void 0;

      if (this.isBound) {
        if (this.bindingContext === bindingContext) {
          return;
        }

        this.unbind();
      }

      this.isBound = true;
      this.bindingContext = bindingContext = bindingContext || this.bindingContext;
      this.overrideContext = overrideContext = overrideContext || this.overrideContext;

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].bind(bindingContext, overrideContext, true);
      }
    };

    ViewSlot.prototype.unbind = function unbind() {
      if (this.isBound) {
        var i = void 0;
        var ii = void 0;
        var _children4 = this.children;

        this.isBound = false;
        this.bindingContext = null;
        this.overrideContext = null;

        for (i = 0, ii = _children4.length; i < ii; ++i) {
          _children4[i].unbind();
        }
      }
    };

    ViewSlot.prototype.add = function add(view) {
      if (this.anchorIsContainer) {
        view.appendNodesTo(this.anchor);
      } else {
        view.insertNodesBefore(this.anchor);
      }

      this.children.push(view);

      if (this.isAttached) {
        view.attached();
        return this.animateView(view, 'enter');
      }
    };

    ViewSlot.prototype.insert = function insert(index, view) {
      var children = this.children;
      var length = children.length;

      if (index === 0 && length === 0 || index >= length) {
        return this.add(view);
      }

      view.insertNodesBefore(children[index].firstChild);
      children.splice(index, 0, view);

      if (this.isAttached) {
        view.attached();
        return this.animateView(view, 'enter');
      }
    };

    ViewSlot.prototype.move = function move(sourceIndex, targetIndex) {
      if (sourceIndex === targetIndex) {
        return;
      }

      var children = this.children;
      var view = children[sourceIndex];

      view.removeNodes();
      view.insertNodesBefore(children[targetIndex].firstChild);
      children.splice(sourceIndex, 1);
      children.splice(targetIndex, 0, view);
    };

    ViewSlot.prototype.remove = function remove(view, returnToCache, skipAnimation) {
      return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
    };

    ViewSlot.prototype.removeMany = function removeMany(viewsToRemove, returnToCache, skipAnimation) {
      var _this2 = this;

      var children = this.children;
      var ii = viewsToRemove.length;
      var i = void 0;
      var rmPromises = [];

      viewsToRemove.forEach(function (child) {
        if (skipAnimation) {
          child.removeNodes();
          return;
        }

        var animation = _this2.animateView(child, 'leave');
        if (animation) {
          rmPromises.push(animation.then(function () {
            return child.removeNodes();
          }));
        } else {
          child.removeNodes();
        }
      });

      var removeAction = function removeAction() {
        if (_this2.isAttached) {
          for (i = 0; i < ii; ++i) {
            viewsToRemove[i].detached();
          }
        }

        if (returnToCache) {
          for (i = 0; i < ii; ++i) {
            viewsToRemove[i].returnToCache();
          }
        }

        for (i = 0; i < ii; ++i) {
          var index = children.indexOf(viewsToRemove[i]);
          if (index >= 0) {
            children.splice(index, 1);
          }
        }
      };

      if (rmPromises.length > 0) {
        return Promise.all(rmPromises).then(function () {
          return removeAction();
        });
      }

      return removeAction();
    };

    ViewSlot.prototype.removeAt = function removeAt(index, returnToCache, skipAnimation) {
      var _this3 = this;

      var view = this.children[index];

      var removeAction = function removeAction() {
        index = _this3.children.indexOf(view);
        view.removeNodes();
        _this3.children.splice(index, 1);

        if (_this3.isAttached) {
          view.detached();
        }

        if (returnToCache) {
          view.returnToCache();
        }

        return view;
      };

      if (!skipAnimation) {
        var animation = this.animateView(view, 'leave');
        if (animation) {
          return animation.then(function () {
            return removeAction();
          });
        }
      }

      return removeAction();
    };

    ViewSlot.prototype.removeAll = function removeAll(returnToCache, skipAnimation) {
      var _this4 = this;

      var children = this.children;
      var ii = children.length;
      var i = void 0;
      var rmPromises = [];

      children.forEach(function (child) {
        if (skipAnimation) {
          child.removeNodes();
          return;
        }

        var animation = _this4.animateView(child, 'leave');
        if (animation) {
          rmPromises.push(animation.then(function () {
            return child.removeNodes();
          }));
        } else {
          child.removeNodes();
        }
      });

      var removeAction = function removeAction() {
        if (_this4.isAttached) {
          for (i = 0; i < ii; ++i) {
            children[i].detached();
          }
        }

        if (returnToCache) {
          for (i = 0; i < ii; ++i) {
            var _child3 = children[i];

            if (_child3) {
              _child3.returnToCache();
            }
          }
        }

        _this4.children = [];
      };

      if (rmPromises.length > 0) {
        return Promise.all(rmPromises).then(function () {
          return removeAction();
        });
      }

      return removeAction();
    };

    ViewSlot.prototype.attached = function attached() {
      var i = void 0;
      var ii = void 0;
      var children = void 0;
      var child = void 0;

      if (this.isAttached) {
        return;
      }

      this.isAttached = true;

      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        child = children[i];
        child.attached();
        this.animateView(child, 'enter');
      }
    };

    ViewSlot.prototype.detached = function detached() {
      var i = void 0;
      var ii = void 0;
      var children = void 0;

      if (this.isAttached) {
        this.isAttached = false;
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].detached();
        }
      }
    };

    ViewSlot.prototype.projectTo = function projectTo(slots) {
      var _this5 = this;

      this.projectToSlots = slots;
      this.add = this._projectionAdd;
      this.insert = this._projectionInsert;
      this.move = this._projectionMove;
      this.remove = this._projectionRemove;
      this.removeAt = this._projectionRemoveAt;
      this.removeMany = this._projectionRemoveMany;
      this.removeAll = this._projectionRemoveAll;
      this.children.forEach(function (view) {
        return ShadowDOM.distributeView(view, slots, _this5);
      });
    };

    ViewSlot.prototype._projectionAdd = function _projectionAdd(view) {
      ShadowDOM.distributeView(view, this.projectToSlots, this);

      this.children.push(view);

      if (this.isAttached) {
        view.attached();
      }
    };

    ViewSlot.prototype._projectionInsert = function _projectionInsert(index, view) {
      if (index === 0 && !this.children.length || index >= this.children.length) {
        this.add(view);
      } else {
        ShadowDOM.distributeView(view, this.projectToSlots, this, index);

        this.children.splice(index, 0, view);

        if (this.isAttached) {
          view.attached();
        }
      }
    };

    ViewSlot.prototype._projectionMove = function _projectionMove(sourceIndex, targetIndex) {
      if (sourceIndex === targetIndex) {
        return;
      }

      var children = this.children;
      var view = children[sourceIndex];

      ShadowDOM.undistributeView(view, this.projectToSlots, this);
      ShadowDOM.distributeView(view, this.projectToSlots, this, targetIndex);

      children.splice(sourceIndex, 1);
      children.splice(targetIndex, 0, view);
    };

    ViewSlot.prototype._projectionRemove = function _projectionRemove(view, returnToCache) {
      ShadowDOM.undistributeView(view, this.projectToSlots, this);
      this.children.splice(this.children.indexOf(view), 1);

      if (this.isAttached) {
        view.detached();
      }
    };

    ViewSlot.prototype._projectionRemoveAt = function _projectionRemoveAt(index, returnToCache) {
      var view = this.children[index];

      ShadowDOM.undistributeView(view, this.projectToSlots, this);
      this.children.splice(index, 1);

      if (this.isAttached) {
        view.detached();
      }
    };

    ViewSlot.prototype._projectionRemoveMany = function _projectionRemoveMany(viewsToRemove, returnToCache) {
      var _this6 = this;

      viewsToRemove.forEach(function (view) {
        return _this6.remove(view, returnToCache);
      });
    };

    ViewSlot.prototype._projectionRemoveAll = function _projectionRemoveAll(returnToCache) {
      ShadowDOM.undistributeAll(this.projectToSlots, this);

      var children = this.children;

      if (this.isAttached) {
        for (var i = 0, ii = children.length; i < ii; ++i) {
          children[i].detached();
        }
      }

      this.children = [];
    };

    return ViewSlot;
  }();

  var ProviderResolver = (0, _aureliaDependencyInjection.resolver)(_class11 = function () {
    function ProviderResolver() {
      
    }

    ProviderResolver.prototype.get = function get(container, key) {
      var id = key.__providerId__;
      return id in container ? container[id] : container[id] = container.invoke(key);
    };

    return ProviderResolver;
  }()) || _class11;

  var providerResolverInstance = new ProviderResolver();

  function elementContainerGet(key) {
    if (key === _aureliaPal.DOM.Element) {
      return this.element;
    }

    if (key === BoundViewFactory) {
      if (this.boundViewFactory) {
        return this.boundViewFactory;
      }

      var factory = this.instruction.viewFactory;
      var _partReplacements = this.partReplacements;

      if (_partReplacements) {
        factory = _partReplacements[factory.part] || factory;
      }

      this.boundViewFactory = new BoundViewFactory(this, factory, _partReplacements);
      return this.boundViewFactory;
    }

    if (key === ViewSlot) {
      if (this.viewSlot === undefined) {
        this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
        this.element.isContentProjectionSource = this.instruction.lifting;
        this.children.push(this.viewSlot);
      }

      return this.viewSlot;
    }

    if (key === ElementEvents) {
      return this.elementEvents || (this.elementEvents = new ElementEvents(this.element));
    }

    if (key === CompositionTransaction) {
      return this.compositionTransaction || (this.compositionTransaction = this.parent.get(key));
    }

    if (key === ViewResources) {
      return this.viewResources;
    }

    if (key === TargetInstruction) {
      return this.instruction;
    }

    return this.superGet(key);
  }

  function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
    var container = parent.createChild();
    var providers = void 0;
    var i = void 0;

    container.element = element;
    container.instruction = instruction;
    container.children = children;
    container.viewResources = resources;
    container.partReplacements = partReplacements;

    providers = instruction.providers;
    i = providers.length;

    while (i--) {
      container._resolvers.set(providers[i], providerResolverInstance);
    }

    container.superGet = container.get;
    container.get = elementContainerGet;

    return container;
  }

  function hasAttribute(name) {
    return this._element.hasAttribute(name);
  }

  function getAttribute(name) {
    return this._element.getAttribute(name);
  }

  function setAttribute(name, value) {
    this._element.setAttribute(name, value);
  }

  function makeElementIntoAnchor(element, elementInstruction) {
    var anchor = _aureliaPal.DOM.createComment('anchor');

    if (elementInstruction) {
      var firstChild = element.firstChild;

      if (firstChild && firstChild.tagName === 'AU-CONTENT') {
        anchor.contentElement = firstChild;
      }

      anchor._element = element;

      anchor.hasAttribute = hasAttribute;
      anchor.getAttribute = getAttribute;
      anchor.setAttribute = setAttribute;
    }

    _aureliaPal.DOM.replaceNode(anchor, element);

    return anchor;
  }

  function applyInstructions(containers, element, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources) {
    var behaviorInstructions = instruction.behaviorInstructions;
    var expressions = instruction.expressions;
    var elementContainer = void 0;
    var i = void 0;
    var ii = void 0;
    var current = void 0;
    var instance = void 0;

    if (instruction.contentExpression) {
      bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
      element.nextSibling.auInterpolationTarget = true;
      element.parentNode.removeChild(element);
      return;
    }

    if (instruction.shadowSlot) {
      var commentAnchor = _aureliaPal.DOM.createComment('slot');
      var slot = void 0;

      if (instruction.slotDestination) {
        slot = new PassThroughSlot(commentAnchor, instruction.slotName, instruction.slotDestination, instruction.slotFallbackFactory);
      } else {
        slot = new ShadowSlot(commentAnchor, instruction.slotName, instruction.slotFallbackFactory);
      }

      _aureliaPal.DOM.replaceNode(commentAnchor, element);
      shadowSlots[instruction.slotName] = slot;
      controllers.push(slot);
      return;
    }

    if (behaviorInstructions.length) {
      if (!instruction.anchorIsContainer) {
        element = makeElementIntoAnchor(element, instruction.elementInstruction);
      }

      containers[instruction.injectorId] = elementContainer = createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);

      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        current = behaviorInstructions[i];
        instance = current.type.create(elementContainer, current, element, bindings);
        controllers.push(instance);
      }
    }

    for (i = 0, ii = expressions.length; i < ii; ++i) {
      bindings.push(expressions[i].createBinding(element));
    }
  }

  function styleStringToObject(style, target) {
    var attributes = style.split(';');
    var firstIndexOfColon = void 0;
    var i = void 0;
    var current = void 0;
    var key = void 0;
    var value = void 0;

    target = target || {};

    for (i = 0; i < attributes.length; i++) {
      current = attributes[i];
      firstIndexOfColon = current.indexOf(':');
      key = current.substring(0, firstIndexOfColon).trim();
      value = current.substring(firstIndexOfColon + 1).trim();
      target[key] = value;
    }

    return target;
  }

  function styleObjectToString(obj) {
    var result = '';

    for (var key in obj) {
      result += key + ':' + obj[key] + ';';
    }

    return result;
  }

  function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
    var behaviorInstructions = instruction.behaviorInstructions;
    var expressions = instruction.expressions;
    var providers = instruction.providers;
    var values = instruction.values;
    var i = void 0;
    var ii = void 0;
    var current = void 0;
    var instance = void 0;
    var currentAttributeValue = void 0;

    i = providers.length;
    while (i--) {
      container._resolvers.set(providers[i], providerResolverInstance);
    }

    for (var key in values) {
      currentAttributeValue = element.getAttribute(key);

      if (currentAttributeValue) {
        if (key === 'class') {
          element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
        } else if (key === 'style') {
          var styleObject = styleStringToObject(values[key]);
          styleStringToObject(currentAttributeValue, styleObject);
          element.setAttribute('style', styleObjectToString(styleObject));
        }
      } else {
        element.setAttribute(key, values[key]);
      }
    }

    if (behaviorInstructions.length) {
      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        current = behaviorInstructions[i];
        instance = current.type.create(container, current, element, bindings);

        if (instance.contentView) {
          children.push(instance.contentView);
        }

        controllers.push(instance);
      }
    }

    for (i = 0, ii = expressions.length; i < ii; ++i) {
      bindings.push(expressions[i].createBinding(element));
    }
  }

  var BoundViewFactory = exports.BoundViewFactory = function () {
    function BoundViewFactory(parentContainer, viewFactory, partReplacements) {
      

      this.parentContainer = parentContainer;
      this.viewFactory = viewFactory;
      this.factoryCreateInstruction = { partReplacements: partReplacements };
    }

    BoundViewFactory.prototype.create = function create() {
      var view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
      view._isUserControlled = true;
      return view;
    };

    BoundViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    };

    BoundViewFactory.prototype.getCachedView = function getCachedView() {
      return this.viewFactory.getCachedView();
    };

    BoundViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      this.viewFactory.returnViewToCache(view);
    };

    _createClass(BoundViewFactory, [{
      key: 'isCaching',
      get: function get() {
        return this.viewFactory.isCaching;
      }
    }]);

    return BoundViewFactory;
  }();

  var ViewFactory = exports.ViewFactory = function () {
    function ViewFactory(template, instructions, resources) {
      

      this.isCaching = false;

      this.template = template;
      this.instructions = instructions;
      this.resources = resources;
      this.cacheSize = -1;
      this.cache = null;
    }

    ViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      if (size) {
        if (size === '*') {
          size = Number.MAX_VALUE;
        } else if (typeof size === 'string') {
          size = parseInt(size, 10);
        }
      }

      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this.cacheSize = size;
      }

      if (this.cacheSize > 0) {
        this.cache = [];
      } else {
        this.cache = null;
      }

      this.isCaching = this.cacheSize > 0;
    };

    ViewFactory.prototype.getCachedView = function getCachedView() {
      return this.cache !== null ? this.cache.pop() || null : null;
    };

    ViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      if (view.isAttached) {
        view.detached();
      }

      if (view.isBound) {
        view.unbind();
      }

      if (this.cache !== null && this.cache.length < this.cacheSize) {
        view.fromCache = true;
        this.cache.push(view);
      }
    };

    ViewFactory.prototype.create = function create(container, createInstruction, element) {
      createInstruction = createInstruction || BehaviorInstruction.normal;

      var cachedView = this.getCachedView();
      if (cachedView !== null) {
        return cachedView;
      }

      var fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
      var instructables = fragment.querySelectorAll('.au-target');
      var instructions = this.instructions;
      var resources = this.resources;
      var controllers = [];
      var bindings = [];
      var children = [];
      var shadowSlots = Object.create(null);
      var containers = { root: container };
      var partReplacements = createInstruction.partReplacements;
      var i = void 0;
      var ii = void 0;
      var view = void 0;
      var instructable = void 0;
      var instruction = void 0;

      this.resources._invokeHook('beforeCreate', this, container, fragment, createInstruction);

      if (element && this.surrogateInstruction !== null) {
        applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
      }

      if (createInstruction.enhance && fragment.hasAttribute('au-target-id')) {
        instructable = fragment;
        instruction = instructions[instructable.getAttribute('au-target-id')];
        applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
      }

      for (i = 0, ii = instructables.length; i < ii; ++i) {
        instructable = instructables[i];
        instruction = instructions[instructable.getAttribute('au-target-id')];
        applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
      }

      view = new View(container, this, fragment, controllers, bindings, children, shadowSlots);

      if (!createInstruction.initiatedByBehavior) {
        view.created();
      }

      this.resources._invokeHook('afterCreate', view);

      return view;
    };

    return ViewFactory;
  }();

  var nextInjectorId = 0;
  function getNextInjectorId() {
    return ++nextInjectorId;
  }

  var lastAUTargetID = 0;
  function getNextAUTargetID() {
    return (++lastAUTargetID).toString();
  }

  function makeIntoInstructionTarget(element) {
    var value = element.getAttribute('class');
    var auTargetID = getNextAUTargetID();

    element.setAttribute('class', value ? value + ' au-target' : 'au-target');
    element.setAttribute('au-target-id', auTargetID);

    return auTargetID;
  }

  function makeShadowSlot(compiler, resources, node, instructions, parentInjectorId) {
    var auShadowSlot = _aureliaPal.DOM.createElement('au-shadow-slot');
    _aureliaPal.DOM.replaceNode(auShadowSlot, node);

    var auTargetID = makeIntoInstructionTarget(auShadowSlot);
    var instruction = TargetInstruction.shadowSlot(parentInjectorId);

    instruction.slotName = node.getAttribute('name') || ShadowDOM.defaultSlotKey;
    instruction.slotDestination = node.getAttribute('slot');

    if (node.innerHTML.trim()) {
      var fragment = _aureliaPal.DOM.createDocumentFragment();
      var _child4 = void 0;

      while (_child4 = node.firstChild) {
        fragment.appendChild(_child4);
      }

      instruction.slotFallbackFactory = compiler.compile(fragment, resources);
    }

    instructions[auTargetID] = instruction;

    return auShadowSlot;
  }

  var ViewCompiler = exports.ViewCompiler = (_dec7 = (0, _aureliaDependencyInjection.inject)(BindingLanguage, ViewResources), _dec7(_class13 = function () {
    function ViewCompiler(bindingLanguage, resources) {
      

      this.bindingLanguage = bindingLanguage;
      this.resources = resources;
    }

    ViewCompiler.prototype.compile = function compile(source, resources, compileInstruction) {
      resources = resources || this.resources;
      compileInstruction = compileInstruction || ViewCompileInstruction.normal;
      source = typeof source === 'string' ? _aureliaPal.DOM.createTemplateFromMarkup(source) : source;

      var content = void 0;
      var part = void 0;
      var cacheSize = void 0;

      if (source.content) {
        part = source.getAttribute('part');
        cacheSize = source.getAttribute('view-cache');
        content = _aureliaPal.DOM.adoptNode(source.content);
      } else {
        content = source;
      }

      compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
      resources._invokeHook('beforeCompile', content, resources, compileInstruction);

      var instructions = {};
      this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);

      var firstChild = content.firstChild;
      if (firstChild && firstChild.nodeType === 1) {
        var targetId = firstChild.getAttribute('au-target-id');
        if (targetId) {
          var ins = instructions[targetId];

          if (ins.shadowSlot || ins.lifting || ins.elementInstruction && !ins.elementInstruction.anchorIsContainer) {
            content.insertBefore(_aureliaPal.DOM.createComment('view'), firstChild);
          }
        }
      }

      var factory = new ViewFactory(content, instructions, resources);

      factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
      factory.part = part;

      if (cacheSize) {
        factory.setCacheSize(cacheSize);
      }

      resources._invokeHook('afterCompile', factory);

      return factory;
    };

    ViewCompiler.prototype._compileNode = function _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
      switch (node.nodeType) {
        case 1:
          return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
        case 3:
          var expression = resources.getBindingLanguage(this.bindingLanguage).inspectTextContent(resources, node.wholeText);
          if (expression) {
            var marker = _aureliaPal.DOM.createElement('au-marker');
            var auTargetID = makeIntoInstructionTarget(marker);
            (node.parentNode || parentNode).insertBefore(marker, node);
            node.textContent = ' ';
            instructions[auTargetID] = TargetInstruction.contentExpression(expression);

            while (node.nextSibling && node.nextSibling.nodeType === 3) {
              (node.parentNode || parentNode).removeChild(node.nextSibling);
            }
          } else {
            while (node.nextSibling && node.nextSibling.nodeType === 3) {
              node = node.nextSibling;
            }
          }
          return node.nextSibling;
        case 11:
          var currentChild = node.firstChild;
          while (currentChild) {
            currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
          }
          break;
        default:
          break;
      }

      return node.nextSibling;
    };

    ViewCompiler.prototype._compileSurrogate = function _compileSurrogate(node, resources) {
      var tagName = node.tagName.toLowerCase();
      var attributes = node.attributes;
      var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
      var knownAttribute = void 0;
      var property = void 0;
      var instruction = void 0;
      var i = void 0;
      var ii = void 0;
      var attr = void 0;
      var attrName = void 0;
      var attrValue = void 0;
      var info = void 0;
      var type = void 0;
      var expressions = [];
      var expression = void 0;
      var behaviorInstructions = [];
      var values = {};
      var hasValues = false;
      var providers = [];

      for (i = 0, ii = attributes.length; i < ii; ++i) {
        attr = attributes[i];
        attrName = attr.name;
        attrValue = attr.value;

        info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
        type = resources.getAttribute(info.attrName);

        if (type) {
          knownAttribute = resources.mapAttribute(info.attrName);
          if (knownAttribute) {
            property = type.attributes[knownAttribute];

            if (property) {
              info.defaultBindingMode = property.defaultBindingMode;

              if (!info.command && !info.expression) {
                info.command = property.hasOptions ? 'options' : null;
              }

              if (info.command && info.command !== 'options' && type.primaryProperty) {
                var primaryProperty = type.primaryProperty;
                attrName = info.attrName = primaryProperty.attribute;

                info.defaultBindingMode = primaryProperty.defaultBindingMode;
              }
            }
          }
        }

        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);

        if (instruction) {
          if (instruction.alteredAttr) {
            type = resources.getAttribute(instruction.attrName);
          }

          if (instruction.discrete) {
            expressions.push(instruction);
          } else {
            if (type) {
              instruction.type = type;
              this._configureProperties(instruction, resources);

              if (type.liftsContent) {
                throw new Error('You cannot place a template controller on a surrogate element.');
              } else {
                behaviorInstructions.push(instruction);
              }
            } else {
              expressions.push(instruction.attributes[instruction.attrName]);
            }
          }
        } else {
          if (type) {
            instruction = BehaviorInstruction.attribute(attrName, type);
            instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

            if (type.liftsContent) {
              throw new Error('You cannot place a template controller on a surrogate element.');
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
            hasValues = true;
            values[attrName] = attrValue;
          }
        }
      }

      if (expressions.length || behaviorInstructions.length || hasValues) {
        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          instruction = behaviorInstructions[i];
          instruction.type.compile(this, resources, node, instruction);
          providers.push(instruction.type.target);
        }

        for (i = 0, ii = expressions.length; i < ii; ++i) {
          expression = expressions[i];
          if (expression.attrToRemove !== undefined) {
            node.removeAttribute(expression.attrToRemove);
          }
        }

        return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
      }

      return null;
    };

    ViewCompiler.prototype._compileElement = function _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
      var tagName = node.tagName.toLowerCase();
      var attributes = node.attributes;
      var expressions = [];
      var expression = void 0;
      var behaviorInstructions = [];
      var providers = [];
      var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
      var liftingInstruction = void 0;
      var viewFactory = void 0;
      var type = void 0;
      var elementInstruction = void 0;
      var elementProperty = void 0;
      var i = void 0;
      var ii = void 0;
      var attr = void 0;
      var attrName = void 0;
      var attrValue = void 0;
      var originalAttrName = void 0;
      var instruction = void 0;
      var info = void 0;
      var property = void 0;
      var knownAttribute = void 0;
      var auTargetID = void 0;
      var injectorId = void 0;

      if (tagName === 'slot') {
        if (targetLightDOM) {
          node = makeShadowSlot(this, resources, node, instructions, parentInjectorId);
        }
        return node.nextSibling;
      } else if (tagName === 'template') {
        if (!('content' in node)) {
          throw new Error('You cannot place a template element within ' + node.namespaceURI + ' namespace');
        }
        viewFactory = this.compile(node, resources);
        viewFactory.part = node.getAttribute('part');
      } else {
        type = resources.getElement(node.getAttribute('as-element') || tagName);
        if (type) {
          elementInstruction = BehaviorInstruction.element(node, type);
          type.processAttributes(this, resources, node, attributes, elementInstruction);
          behaviorInstructions.push(elementInstruction);
        }
      }

      for (i = 0, ii = attributes.length; i < ii; ++i) {
        attr = attributes[i];
        originalAttrName = attrName = attr.name;
        attrValue = attr.value;
        info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);

        if (targetLightDOM && info.attrName === 'slot') {
          info.attrName = attrName = 'au-slot';
        }

        type = resources.getAttribute(info.attrName);
        elementProperty = null;

        if (type) {
          knownAttribute = resources.mapAttribute(info.attrName);
          if (knownAttribute) {
            property = type.attributes[knownAttribute];

            if (property) {
              info.defaultBindingMode = property.defaultBindingMode;

              if (!info.command && !info.expression) {
                info.command = property.hasOptions ? 'options' : null;
              }

              if (info.command && info.command !== 'options' && type.primaryProperty) {
                var primaryProperty = type.primaryProperty;
                attrName = info.attrName = primaryProperty.attribute;

                info.defaultBindingMode = primaryProperty.defaultBindingMode;
              }
            }
          }
        } else if (elementInstruction) {
          elementProperty = elementInstruction.type.attributes[info.attrName];
          if (elementProperty) {
            info.defaultBindingMode = elementProperty.defaultBindingMode;
          }
        }

        if (elementProperty) {
          instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
        } else {
          instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
        }

        if (instruction) {
          if (instruction.alteredAttr) {
            type = resources.getAttribute(instruction.attrName);
          }

          if (instruction.discrete) {
            expressions.push(instruction);
          } else {
            if (type) {
              instruction.type = type;
              this._configureProperties(instruction, resources);

              if (type.liftsContent) {
                instruction.originalAttrName = originalAttrName;
                liftingInstruction = instruction;
                break;
              } else {
                behaviorInstructions.push(instruction);
              }
            } else if (elementProperty) {
              elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
            } else {
              expressions.push(instruction.attributes[instruction.attrName]);
            }
          }
        } else {
          if (type) {
            instruction = BehaviorInstruction.attribute(attrName, type);
            instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

            if (type.liftsContent) {
              instruction.originalAttrName = originalAttrName;
              liftingInstruction = instruction;
              break;
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (elementProperty) {
            elementInstruction.attributes[attrName] = attrValue;
          }
        }
      }

      if (liftingInstruction) {
        liftingInstruction.viewFactory = viewFactory;
        node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
        auTargetID = makeIntoInstructionTarget(node);
        instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
      } else {
        var skipContentProcessing = false;

        if (expressions.length || behaviorInstructions.length) {
          injectorId = behaviorInstructions.length ? getNextInjectorId() : false;

          for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
            instruction = behaviorInstructions[i];
            instruction.type.compile(this, resources, node, instruction, parentNode);
            providers.push(instruction.type.target);
            skipContentProcessing = skipContentProcessing || instruction.skipContentProcessing;
          }

          for (i = 0, ii = expressions.length; i < ii; ++i) {
            expression = expressions[i];
            if (expression.attrToRemove !== undefined) {
              node.removeAttribute(expression.attrToRemove);
            }
          }

          auTargetID = makeIntoInstructionTarget(node);
          instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
        }

        if (skipContentProcessing) {
          return node.nextSibling;
        }

        var currentChild = node.firstChild;
        while (currentChild) {
          currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
        }
      }

      return node.nextSibling;
    };

    ViewCompiler.prototype._configureProperties = function _configureProperties(instruction, resources) {
      var type = instruction.type;
      var attrName = instruction.attrName;
      var attributes = instruction.attributes;
      var property = void 0;
      var key = void 0;
      var value = void 0;

      var knownAttribute = resources.mapAttribute(attrName);
      if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
        attributes[knownAttribute] = attributes[attrName];
        delete attributes[attrName];
      }

      for (key in attributes) {
        value = attributes[key];

        if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          property = type.attributes[key];

          if (property !== undefined) {
            value.targetProperty = property.name;
          } else {
            value.targetProperty = key;
          }
        }
      }
    };

    return ViewCompiler;
  }()) || _class13);

  var ResourceModule = exports.ResourceModule = function () {
    function ResourceModule(moduleId) {
      

      this.id = moduleId;
      this.moduleInstance = null;
      this.mainResource = null;
      this.resources = null;
      this.viewStrategy = null;
      this.isInitialized = false;
      this.onLoaded = null;
      this.loadContext = null;
    }

    ResourceModule.prototype.initialize = function initialize(container) {
      var current = this.mainResource;
      var resources = this.resources;
      var vs = this.viewStrategy;

      if (this.isInitialized) {
        return;
      }

      this.isInitialized = true;

      if (current !== undefined) {
        current.metadata.viewStrategy = vs;
        current.initialize(container);
      }

      for (var i = 0, ii = resources.length; i < ii; ++i) {
        current = resources[i];
        current.metadata.viewStrategy = vs;
        current.initialize(container);
      }
    };

    ResourceModule.prototype.register = function register(registry, name) {
      var main = this.mainResource;
      var resources = this.resources;

      if (main !== undefined) {
        main.register(registry, name);
        name = null;
      }

      for (var i = 0, ii = resources.length; i < ii; ++i) {
        resources[i].register(registry, name);
        name = null;
      }
    };

    ResourceModule.prototype.load = function load(container, loadContext) {
      if (this.onLoaded !== null) {
        return this.loadContext === loadContext ? Promise.resolve() : this.onLoaded;
      }

      var main = this.mainResource;
      var resources = this.resources;
      var loads = void 0;

      if (main !== undefined) {
        loads = new Array(resources.length + 1);
        loads[0] = main.load(container, loadContext);
        for (var i = 0, ii = resources.length; i < ii; ++i) {
          loads[i + 1] = resources[i].load(container, loadContext);
        }
      } else {
        loads = new Array(resources.length);
        for (var _i = 0, _ii = resources.length; _i < _ii; ++_i) {
          loads[_i] = resources[_i].load(container, loadContext);
        }
      }

      this.loadContext = loadContext;
      this.onLoaded = Promise.all(loads);
      return this.onLoaded;
    };

    return ResourceModule;
  }();

  var ResourceDescription = exports.ResourceDescription = function () {
    function ResourceDescription(key, exportedValue, resourceTypeMeta) {
      

      if (!resourceTypeMeta) {
        resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

        if (!resourceTypeMeta) {
          resourceTypeMeta = new HtmlBehaviorResource();
          resourceTypeMeta.elementName = _hyphenate(key);
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, resourceTypeMeta, exportedValue);
        }
      }

      if (resourceTypeMeta instanceof HtmlBehaviorResource) {
        if (resourceTypeMeta.elementName === undefined) {
          resourceTypeMeta.elementName = _hyphenate(key);
        } else if (resourceTypeMeta.attributeName === undefined) {
          resourceTypeMeta.attributeName = _hyphenate(key);
        } else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          HtmlBehaviorResource.convention(key, resourceTypeMeta);
        }
      } else if (!resourceTypeMeta.name) {
        resourceTypeMeta.name = _hyphenate(key);
      }

      this.metadata = resourceTypeMeta;
      this.value = exportedValue;
    }

    ResourceDescription.prototype.initialize = function initialize(container) {
      this.metadata.initialize(container, this.value);
    };

    ResourceDescription.prototype.register = function register(registry, name) {
      this.metadata.register(registry, name);
    };

    ResourceDescription.prototype.load = function load(container, loadContext) {
      return this.metadata.load(container, this.value, loadContext);
    };

    return ResourceDescription;
  }();

  var ModuleAnalyzer = exports.ModuleAnalyzer = function () {
    function ModuleAnalyzer() {
      

      this.cache = Object.create(null);
    }

    ModuleAnalyzer.prototype.getAnalysis = function getAnalysis(moduleId) {
      return this.cache[moduleId];
    };

    ModuleAnalyzer.prototype.analyze = function analyze(moduleId, moduleInstance, mainResourceKey) {
      var mainResource = void 0;
      var fallbackValue = void 0;
      var fallbackKey = void 0;
      var resourceTypeMeta = void 0;
      var key = void 0;
      var exportedValue = void 0;
      var resources = [];
      var conventional = void 0;
      var vs = void 0;
      var resourceModule = void 0;

      resourceModule = this.cache[moduleId];
      if (resourceModule) {
        return resourceModule;
      }

      resourceModule = new ResourceModule(moduleId);
      this.cache[moduleId] = resourceModule;

      if (typeof moduleInstance === 'function') {
        moduleInstance = { 'default': moduleInstance };
      }

      if (mainResourceKey) {
        mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
      }

      for (key in moduleInstance) {
        exportedValue = moduleInstance[key];

        if (key === mainResourceKey || typeof exportedValue !== 'function') {
          continue;
        }

        resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

        if (resourceTypeMeta) {
          if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
            HtmlBehaviorResource.convention(key, resourceTypeMeta);
          }

          if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
            resourceTypeMeta.elementName = _hyphenate(key);
          }

          if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
            mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
          } else {
            resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
          }
        } else if (viewStrategy.decorates(exportedValue)) {
          vs = exportedValue;
        } else if (exportedValue instanceof _aureliaLoader.TemplateRegistryEntry) {
          vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
        } else {
          if (conventional = HtmlBehaviorResource.convention(key)) {
            if (conventional.elementName !== null && !mainResource) {
              mainResource = new ResourceDescription(key, exportedValue, conventional);
            } else {
              resources.push(new ResourceDescription(key, exportedValue, conventional));
            }

            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
          } else if (conventional = _aureliaBinding.ValueConverterResource.convention(key) || _aureliaBinding.BindingBehaviorResource.convention(key) || ViewEngineHooksResource.convention(key)) {
            resources.push(new ResourceDescription(key, exportedValue, conventional));
            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
          } else if (!fallbackValue) {
            fallbackValue = exportedValue;
            fallbackKey = key;
          }
        }
      }

      if (!mainResource && fallbackValue) {
        mainResource = new ResourceDescription(fallbackKey, fallbackValue);
      }

      resourceModule.moduleInstance = moduleInstance;
      resourceModule.mainResource = mainResource;
      resourceModule.resources = resources;
      resourceModule.viewStrategy = vs;

      return resourceModule;
    };

    return ModuleAnalyzer;
  }();

  var logger = LogManager.getLogger('templating');

  function ensureRegistryEntry(loader, urlOrRegistryEntry) {
    if (urlOrRegistryEntry instanceof _aureliaLoader.TemplateRegistryEntry) {
      return Promise.resolve(urlOrRegistryEntry);
    }

    return loader.loadTemplate(urlOrRegistryEntry);
  }

  var ProxyViewFactory = function () {
    function ProxyViewFactory(promise) {
      var _this7 = this;

      

      promise.then(function (x) {
        return _this7.viewFactory = x;
      });
    }

    ProxyViewFactory.prototype.create = function create(container, bindingContext, createInstruction, element) {
      return this.viewFactory.create(container, bindingContext, createInstruction, element);
    };

    ProxyViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    };

    ProxyViewFactory.prototype.getCachedView = function getCachedView() {
      return this.viewFactory.getCachedView();
    };

    ProxyViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      this.viewFactory.returnViewToCache(view);
    };

    _createClass(ProxyViewFactory, [{
      key: 'isCaching',
      get: function get() {
        return this.viewFactory.isCaching;
      }
    }]);

    return ProxyViewFactory;
  }();

  var auSlotBehavior = null;

  var ViewEngine = exports.ViewEngine = (_dec8 = (0, _aureliaDependencyInjection.inject)(_aureliaLoader.Loader, _aureliaDependencyInjection.Container, ViewCompiler, ModuleAnalyzer, ViewResources), _dec8(_class14 = (_temp4 = _class15 = function () {
    function ViewEngine(loader, container, viewCompiler, moduleAnalyzer, appResources) {
      

      this.loader = loader;
      this.container = container;
      this.viewCompiler = viewCompiler;
      this.moduleAnalyzer = moduleAnalyzer;
      this.appResources = appResources;
      this._pluginMap = {};

      if (auSlotBehavior === null) {
        auSlotBehavior = new HtmlBehaviorResource();
        auSlotBehavior.attributeName = 'au-slot';
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, auSlotBehavior, SlotCustomAttribute);
      }

      auSlotBehavior.initialize(container, SlotCustomAttribute);
      auSlotBehavior.register(appResources);
    }

    ViewEngine.prototype.addResourcePlugin = function addResourcePlugin(extension, implementation) {
      var name = extension.replace('.', '') + '-resource-plugin';
      this._pluginMap[extension] = name;
      this.loader.addPlugin(name, implementation);
    };

    ViewEngine.prototype.loadViewFactory = function loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext, target) {
      var _this8 = this;

      loadContext = loadContext || new ResourceLoadContext();

      return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(function (registryEntry) {
        var url = registryEntry.address;

        if (registryEntry.onReady) {
          if (!loadContext.hasDependency(url)) {
            loadContext.addDependency(url);
            return registryEntry.onReady;
          }

          if (registryEntry.template === null) {
            return registryEntry.onReady;
          }

          return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
        }

        loadContext.addDependency(url);

        registryEntry.onReady = _this8.loadTemplateResources(registryEntry, compileInstruction, loadContext, target).then(function (resources) {
          registryEntry.resources = resources;

          if (registryEntry.template === null) {
            return registryEntry.factory = null;
          }

          var viewFactory = _this8.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
          return registryEntry.factory = viewFactory;
        });

        return registryEntry.onReady;
      });
    };

    ViewEngine.prototype.loadTemplateResources = function loadTemplateResources(registryEntry, compileInstruction, loadContext, target) {
      var resources = new ViewResources(this.appResources, registryEntry.address);
      var dependencies = registryEntry.dependencies;
      var importIds = void 0;
      var names = void 0;

      compileInstruction = compileInstruction || ViewCompileInstruction.normal;

      if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
        return Promise.resolve(resources);
      }

      importIds = dependencies.map(function (x) {
        return x.src;
      });
      names = dependencies.map(function (x) {
        return x.name;
      });
      logger.debug('importing resources for ' + registryEntry.address, importIds);

      if (target) {
        var viewModelRequires = _aureliaMetadata.metadata.get(ViewEngine.viewModelRequireMetadataKey, target);
        if (viewModelRequires) {
          var templateImportCount = importIds.length;
          for (var i = 0, ii = viewModelRequires.length; i < ii; ++i) {
            var req = viewModelRequires[i];
            var importId = typeof req === 'function' ? _aureliaMetadata.Origin.get(req).moduleId : (0, _aureliaPath.relativeToFile)(req.src || req, registryEntry.address);

            if (importIds.indexOf(importId) === -1) {
              importIds.push(importId);
              names.push(req.as);
            }
          }
          logger.debug('importing ViewModel resources for ' + compileInstruction.associatedModuleId, importIds.slice(templateImportCount));
        }
      }

      return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
    };

    ViewEngine.prototype.importViewModelResource = function importViewModelResource(moduleImport, moduleMember) {
      var _this9 = this;

      return this.loader.loadModule(moduleImport).then(function (viewModelModule) {
        var normalizedId = _aureliaMetadata.Origin.get(viewModelModule).moduleId;
        var resourceModule = _this9.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);

        if (!resourceModule.mainResource) {
          throw new Error('No view model found in module "' + moduleImport + '".');
        }

        resourceModule.initialize(_this9.container);

        return resourceModule.mainResource;
      });
    };

    ViewEngine.prototype.importViewResources = function importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
      var _this10 = this;

      loadContext = loadContext || new ResourceLoadContext();
      compileInstruction = compileInstruction || ViewCompileInstruction.normal;

      moduleIds = moduleIds.map(function (x) {
        return _this10._applyLoaderPlugin(x);
      });

      return this.loader.loadAllModules(moduleIds).then(function (imports) {
        var i = void 0;
        var ii = void 0;
        var analysis = void 0;
        var normalizedId = void 0;
        var current = void 0;
        var associatedModule = void 0;
        var container = _this10.container;
        var moduleAnalyzer = _this10.moduleAnalyzer;
        var allAnalysis = new Array(imports.length);

        for (i = 0, ii = imports.length; i < ii; ++i) {
          current = imports[i];
          normalizedId = _aureliaMetadata.Origin.get(current).moduleId;

          analysis = moduleAnalyzer.analyze(normalizedId, current);
          analysis.initialize(container);
          analysis.register(resources, names[i]);

          allAnalysis[i] = analysis;
        }

        if (compileInstruction.associatedModuleId) {
          associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);

          if (associatedModule) {
            associatedModule.register(resources);
          }
        }

        for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
          allAnalysis[i] = allAnalysis[i].load(container, loadContext);
        }

        return Promise.all(allAnalysis).then(function () {
          return resources;
        });
      });
    };

    ViewEngine.prototype._applyLoaderPlugin = function _applyLoaderPlugin(id) {
      var index = id.lastIndexOf('.');
      if (index !== -1) {
        var ext = id.substring(index);
        var pluginName = this._pluginMap[ext];

        if (pluginName === undefined) {
          return id;
        }

        return this.loader.applyPluginToUrl(id, pluginName);
      }

      return id;
    };

    return ViewEngine;
  }(), _class15.viewModelRequireMetadataKey = 'aurelia:view-model-require', _temp4)) || _class14);

  var Controller = exports.Controller = function () {
    function Controller(behavior, instruction, viewModel, container) {
      

      this.behavior = behavior;
      this.instruction = instruction;
      this.viewModel = viewModel;
      this.isAttached = false;
      this.view = null;
      this.isBound = false;
      this.scope = null;
      this.container = container;
      this.elementEvents = container.elementEvents || null;

      var observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
      var handlesBind = behavior.handlesBind;
      var attributes = instruction.attributes;
      var boundProperties = this.boundProperties = [];
      var properties = behavior.properties;
      var i = void 0;
      var ii = void 0;

      behavior._ensurePropertiesDefined(viewModel, observerLookup);

      for (i = 0, ii = properties.length; i < ii; ++i) {
        properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
      }
    }

    Controller.prototype.created = function created(owningView) {
      if (this.behavior.handlesCreated) {
        this.viewModel.created(owningView, this.view);
      }
    };

    Controller.prototype.automate = function automate(overrideContext, owningView) {
      this.view.bindingContext = this.viewModel;
      this.view.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(this.viewModel);
      this.view._isUserControlled = true;

      if (this.behavior.handlesCreated) {
        this.viewModel.created(owningView || null, this.view);
      }

      this.bind(this.view);
    };

    Controller.prototype.bind = function bind(scope) {
      var skipSelfSubscriber = this.behavior.handlesBind;
      var boundProperties = this.boundProperties;
      var i = void 0;
      var ii = void 0;
      var x = void 0;
      var observer = void 0;
      var selfSubscriber = void 0;

      if (this.isBound) {
        if (this.scope === scope) {
          return;
        }

        this.unbind();
      }

      this.isBound = true;
      this.scope = scope;

      for (i = 0, ii = boundProperties.length; i < ii; ++i) {
        x = boundProperties[i];
        observer = x.observer;
        selfSubscriber = observer.selfSubscriber;
        observer.publishing = false;

        if (skipSelfSubscriber) {
          observer.selfSubscriber = null;
        }

        x.binding.bind(scope);
        observer.call();

        observer.publishing = true;
        observer.selfSubscriber = selfSubscriber;
      }

      var overrideContext = void 0;
      if (this.view !== null) {
        if (skipSelfSubscriber) {
          this.view.viewModelScope = scope;
        }

        if (this.viewModel === scope.overrideContext.bindingContext) {
          overrideContext = scope.overrideContext;
        } else if (this.instruction.inheritBindingContext) {
          overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel, scope.overrideContext);
        } else {
          overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel);
          overrideContext.__parentOverrideContext = scope.overrideContext;
        }

        this.view.bind(this.viewModel, overrideContext);
      } else if (skipSelfSubscriber) {
        overrideContext = scope.overrideContext;

        if (scope.overrideContext.__parentOverrideContext !== undefined && this.viewModel.viewFactory && this.viewModel.viewFactory.factoryCreateInstruction.partReplacements) {
          overrideContext = Object.assign({}, scope.overrideContext);
          overrideContext.parentOverrideContext = scope.overrideContext.__parentOverrideContext;
        }
        this.viewModel.bind(scope.bindingContext, overrideContext);
      }
    };

    Controller.prototype.unbind = function unbind() {
      if (this.isBound) {
        var _boundProperties = this.boundProperties;
        var _i2 = void 0;
        var _ii2 = void 0;

        this.isBound = false;
        this.scope = null;

        if (this.view !== null) {
          this.view.unbind();
        }

        if (this.behavior.handlesUnbind) {
          this.viewModel.unbind();
        }

        if (this.elementEvents !== null) {
          this.elementEvents.disposeAll();
        }

        for (_i2 = 0, _ii2 = _boundProperties.length; _i2 < _ii2; ++_i2) {
          _boundProperties[_i2].binding.unbind();
        }
      }
    };

    Controller.prototype.attached = function attached() {
      if (this.isAttached) {
        return;
      }

      this.isAttached = true;

      if (this.behavior.handlesAttached) {
        this.viewModel.attached();
      }

      if (this.view !== null) {
        this.view.attached();
      }
    };

    Controller.prototype.detached = function detached() {
      if (this.isAttached) {
        this.isAttached = false;

        if (this.view !== null) {
          this.view.detached();
        }

        if (this.behavior.handlesDetached) {
          this.viewModel.detached();
        }
      }
    };

    return Controller;
  }();

  var BehaviorPropertyObserver = exports.BehaviorPropertyObserver = (_dec9 = (0, _aureliaBinding.subscriberCollection)(), _dec9(_class16 = function () {
    function BehaviorPropertyObserver(taskQueue, obj, propertyName, selfSubscriber, initialValue) {
      

      this.taskQueue = taskQueue;
      this.obj = obj;
      this.propertyName = propertyName;
      this.notqueued = true;
      this.publishing = false;
      this.selfSubscriber = selfSubscriber;
      this.currentValue = this.oldValue = initialValue;
    }

    BehaviorPropertyObserver.prototype.getValue = function getValue() {
      return this.currentValue;
    };

    BehaviorPropertyObserver.prototype.setValue = function setValue(newValue) {
      var oldValue = this.currentValue;

      if (oldValue !== newValue) {
        this.oldValue = oldValue;
        this.currentValue = newValue;

        if (this.publishing && this.notqueued) {
          if (this.taskQueue.flushing) {
            this.call();
          } else {
            this.notqueued = false;
            this.taskQueue.queueMicroTask(this);
          }
        }
      }
    };

    BehaviorPropertyObserver.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.currentValue;

      this.notqueued = true;

      if (newValue === oldValue) {
        return;
      }

      if (this.selfSubscriber) {
        this.selfSubscriber(newValue, oldValue);
      }

      this.callSubscribers(newValue, oldValue);
      this.oldValue = newValue;
    };

    BehaviorPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };

    BehaviorPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };

    return BehaviorPropertyObserver;
  }()) || _class16);


  function getObserver(instance, name) {
    var lookup = instance.__observers__;

    if (lookup === undefined) {
      var ctor = Object.getPrototypeOf(instance).constructor;
      var _behavior = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, ctor);
      if (!_behavior.isInitialized) {
        _behavior.initialize(_aureliaDependencyInjection.Container.instance || new _aureliaDependencyInjection.Container(), instance.constructor);
      }

      lookup = _behavior.observerLocator.getOrCreateObserversLookup(instance);
      _behavior._ensurePropertiesDefined(instance, lookup);
    }

    return lookup[name];
  }

  var BindableProperty = exports.BindableProperty = function () {
    function BindableProperty(nameOrConfig) {
      

      if (typeof nameOrConfig === 'string') {
        this.name = nameOrConfig;
      } else {
        Object.assign(this, nameOrConfig);
      }

      this.attribute = this.attribute || _hyphenate(this.name);
      if (this.defaultBindingMode === null || this.defaultBindingMode === undefined) {
        this.defaultBindingMode = _aureliaBinding.bindingMode.oneWay;
      }
      this.changeHandler = this.changeHandler || null;
      this.owner = null;
      this.descriptor = null;
    }

    BindableProperty.prototype.registerWith = function registerWith(target, behavior, descriptor) {
      behavior.properties.push(this);
      behavior.attributes[this.attribute] = this;
      this.owner = behavior;

      if (descriptor) {
        this.descriptor = descriptor;
        return this._configureDescriptor(descriptor);
      }

      return undefined;
    };

    BindableProperty.prototype._configureDescriptor = function _configureDescriptor(descriptor) {
      var name = this.name;

      descriptor.configurable = true;
      descriptor.enumerable = true;

      if ('initializer' in descriptor) {
        this.defaultValue = descriptor.initializer;
        delete descriptor.initializer;
        delete descriptor.writable;
      }

      if ('value' in descriptor) {
        this.defaultValue = descriptor.value;
        delete descriptor.value;
        delete descriptor.writable;
      }

      descriptor.get = function () {
        return getObserver(this, name).getValue();
      };

      descriptor.set = function (value) {
        getObserver(this, name).setValue(value);
      };

      descriptor.get.getObserver = function (obj) {
        return getObserver(obj, name);
      };

      return descriptor;
    };

    BindableProperty.prototype.defineOn = function defineOn(target, behavior) {
      var name = this.name;
      var handlerName = void 0;

      if (this.changeHandler === null) {
        handlerName = name + 'Changed';
        if (handlerName in target.prototype) {
          this.changeHandler = handlerName;
        }
      }

      if (this.descriptor === null) {
        Object.defineProperty(target.prototype, name, this._configureDescriptor(behavior, {}));
      }
    };

    BindableProperty.prototype.createObserver = function createObserver(viewModel) {
      var selfSubscriber = null;
      var defaultValue = this.defaultValue;
      var changeHandlerName = this.changeHandler;
      var name = this.name;
      var initialValue = void 0;

      if (this.hasOptions) {
        return undefined;
      }

      if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            viewModel[changeHandlerName](newValue, oldValue);
            viewModel.propertyChanged(name, newValue, oldValue);
          };
        } else {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            return viewModel[changeHandlerName](newValue, oldValue);
          };
        }
      } else if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else if (changeHandlerName !== null) {
        throw new Error('Change handler ' + changeHandlerName + ' was specified but not declared on the class.');
      }

      if (defaultValue !== undefined) {
        initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
      }

      return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
    };

    BindableProperty.prototype._initialize = function _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
      var selfSubscriber = void 0;
      var observer = void 0;
      var attribute = void 0;
      var defaultValue = this.defaultValue;

      if (this.isDynamic) {
        for (var key in attributes) {
          this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
        }
      } else if (!this.hasOptions) {
        observer = observerLookup[this.name];

        if (attributes !== null) {
          selfSubscriber = observer.selfSubscriber;
          attribute = attributes[this.attribute];

          if (behaviorHandlesBind) {
            observer.selfSubscriber = null;
          }

          if (typeof attribute === 'string') {
            viewModel[this.name] = attribute;
            observer.call();
          } else if (attribute) {
            boundProperties.push({ observer: observer, binding: attribute.createBinding(viewModel) });
          } else if (defaultValue !== undefined) {
            observer.call();
          }

          observer.selfSubscriber = selfSubscriber;
        }

        observer.publishing = true;
      }
    };

    BindableProperty.prototype._createDynamicProperty = function _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
      var changeHandlerName = name + 'Changed';
      var selfSubscriber = null;
      var observer = void 0;
      var info = void 0;

      if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            viewModel[changeHandlerName](newValue, oldValue);
            viewModel.propertyChanged(name, newValue, oldValue);
          };
        } else {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            return viewModel[changeHandlerName](newValue, oldValue);
          };
        }
      } else if ('propertyChanged' in viewModel) {
        selfSubscriber = function selfSubscriber(newValue, oldValue) {
          return viewModel.propertyChanged(name, newValue, oldValue);
        };
      }

      observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);

      Object.defineProperty(viewModel, name, {
        configurable: true,
        enumerable: true,
        get: observer.getValue.bind(observer),
        set: observer.setValue.bind(observer)
      });

      if (behaviorHandlesBind) {
        observer.selfSubscriber = null;
      }

      if (typeof attribute === 'string') {
        viewModel[name] = attribute;
        observer.call();
      } else if (attribute) {
        info = { observer: observer, binding: attribute.createBinding(viewModel) };
        boundProperties.push(info);
      }

      observer.publishing = true;
      observer.selfSubscriber = selfSubscriber;
    };

    return BindableProperty;
  }();

  var lastProviderId = 0;

  function nextProviderId() {
    return ++lastProviderId;
  }

  function doProcessContent() {
    return true;
  }
  function doProcessAttributes() {}

  var HtmlBehaviorResource = exports.HtmlBehaviorResource = function () {
    function HtmlBehaviorResource() {
      

      this.elementName = null;
      this.attributeName = null;
      this.attributeDefaultBindingMode = undefined;
      this.liftsContent = false;
      this.targetShadowDOM = false;
      this.shadowDOMOptions = null;
      this.processAttributes = doProcessAttributes;
      this.processContent = doProcessContent;
      this.usesShadowDOM = false;
      this.childBindings = null;
      this.hasDynamicOptions = false;
      this.containerless = false;
      this.properties = [];
      this.attributes = {};
      this.isInitialized = false;
      this.primaryProperty = null;
    }

    HtmlBehaviorResource.convention = function convention(name, existing) {
      var behavior = void 0;

      if (name.endsWith('CustomAttribute')) {
        behavior = existing || new HtmlBehaviorResource();
        behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
      }

      if (name.endsWith('CustomElement')) {
        behavior = existing || new HtmlBehaviorResource();
        behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
      }

      return behavior;
    };

    HtmlBehaviorResource.prototype.addChildBinding = function addChildBinding(behavior) {
      if (this.childBindings === null) {
        this.childBindings = [];
      }

      this.childBindings.push(behavior);
    };

    HtmlBehaviorResource.prototype.initialize = function initialize(container, target) {
      var proto = target.prototype;
      var properties = this.properties;
      var attributeName = this.attributeName;
      var attributeDefaultBindingMode = this.attributeDefaultBindingMode;
      var i = void 0;
      var ii = void 0;
      var current = void 0;

      if (this.isInitialized) {
        return;
      }

      this.isInitialized = true;
      target.__providerId__ = nextProviderId();

      this.observerLocator = container.get(_aureliaBinding.ObserverLocator);
      this.taskQueue = container.get(_aureliaTaskQueue.TaskQueue);

      this.target = target;
      this.usesShadowDOM = this.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
      this.handlesCreated = 'created' in proto;
      this.handlesBind = 'bind' in proto;
      this.handlesUnbind = 'unbind' in proto;
      this.handlesAttached = 'attached' in proto;
      this.handlesDetached = 'detached' in proto;
      this.htmlName = this.elementName || this.attributeName;

      if (attributeName !== null) {
        if (properties.length === 0) {
          new BindableProperty({
            name: 'value',
            changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
            attribute: attributeName,
            defaultBindingMode: attributeDefaultBindingMode
          }).registerWith(target, this);
        }

        current = properties[0];

        if (properties.length === 1 && current.name === 'value') {
          current.isDynamic = current.hasOptions = this.hasDynamicOptions;
          current.defineOn(target, this);
        } else {
          for (i = 0, ii = properties.length; i < ii; ++i) {
            properties[i].defineOn(target, this);
            if (properties[i].primaryProperty) {
              if (this.primaryProperty) {
                throw new Error('Only one bindable property on a custom element can be defined as the default');
              }
              this.primaryProperty = properties[i];
            }
          }

          current = new BindableProperty({
            name: 'value',
            changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
            attribute: attributeName,
            defaultBindingMode: attributeDefaultBindingMode
          });

          current.hasOptions = true;
          current.registerWith(target, this);
        }
      } else {
        for (i = 0, ii = properties.length; i < ii; ++i) {
          properties[i].defineOn(target, this);
        }

        this._copyInheritedProperties(container, target);
      }
    };

    HtmlBehaviorResource.prototype.register = function register(registry, name) {
      var _this11 = this;

      if (this.attributeName !== null) {
        registry.registerAttribute(name || this.attributeName, this, this.attributeName);

        if (Array.isArray(this.aliases)) {
          this.aliases.forEach(function (alias) {
            registry.registerAttribute(alias, _this11, _this11.attributeName);
          });
        }
      }

      if (this.elementName !== null) {
        registry.registerElement(name || this.elementName, this);
      }
    };

    HtmlBehaviorResource.prototype.load = function load(container, target, loadContext, viewStrategy, transientView) {
      var _this12 = this;

      var options = void 0;

      if (this.elementName !== null) {
        viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
        options = new ViewCompileInstruction(this.targetShadowDOM, true);

        if (!viewStrategy.moduleId) {
          viewStrategy.moduleId = _aureliaMetadata.Origin.get(target).moduleId;
        }

        return viewStrategy.loadViewFactory(container.get(ViewEngine), options, loadContext, target).then(function (viewFactory) {
          if (!transientView || !_this12.viewFactory) {
            _this12.viewFactory = viewFactory;
          }

          return viewFactory;
        });
      }

      return Promise.resolve(this);
    };

    HtmlBehaviorResource.prototype.compile = function compile(compiler, resources, node, instruction, parentNode) {
      if (this.liftsContent) {
        if (!instruction.viewFactory) {
          var template = _aureliaPal.DOM.createElement('template');
          var fragment = _aureliaPal.DOM.createDocumentFragment();
          var cacheSize = node.getAttribute('view-cache');
          var part = node.getAttribute('part');

          node.removeAttribute(instruction.originalAttrName);
          _aureliaPal.DOM.replaceNode(template, node, parentNode);
          fragment.appendChild(node);
          instruction.viewFactory = compiler.compile(fragment, resources);

          if (part) {
            instruction.viewFactory.part = part;
            node.removeAttribute('part');
          }

          if (cacheSize) {
            instruction.viewFactory.setCacheSize(cacheSize);
            node.removeAttribute('view-cache');
          }

          node = template;
        }
      } else if (this.elementName !== null) {
        var _partReplacements2 = {};

        if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
          var currentChild = node.firstChild;
          var contentElement = this.usesShadowDOM ? null : _aureliaPal.DOM.createElement('au-content');
          var nextSibling = void 0;
          var toReplace = void 0;

          while (currentChild) {
            nextSibling = currentChild.nextSibling;

            if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
              _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
              _aureliaPal.DOM.removeNode(currentChild, parentNode);
              instruction.partReplacements = _partReplacements2;
            } else if (contentElement !== null) {
              if (currentChild.nodeType === 3 && _isAllWhitespace(currentChild)) {
                _aureliaPal.DOM.removeNode(currentChild, parentNode);
              } else {
                contentElement.appendChild(currentChild);
              }
            }

            currentChild = nextSibling;
          }

          if (contentElement !== null && contentElement.hasChildNodes()) {
            node.appendChild(contentElement);
          }

          instruction.skipContentProcessing = false;
        } else {
          instruction.skipContentProcessing = true;
        }
      } else if (!this.processContent(compiler, resources, node, instruction)) {
        instruction.skipContentProcessing = true;
      }

      return node;
    };

    HtmlBehaviorResource.prototype.create = function create(container, instruction, element, bindings) {
      var viewHost = void 0;
      var au = null;

      instruction = instruction || BehaviorInstruction.normal;
      element = element || null;
      bindings = bindings || null;

      if (this.elementName !== null && element) {
        if (this.usesShadowDOM) {
          viewHost = element.attachShadow(this.shadowDOMOptions);
          container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
        } else {
          viewHost = element;
          if (this.targetShadowDOM) {
            container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
          }
        }
      }

      if (element !== null) {
        element.au = au = element.au || {};
      }

      var viewModel = instruction.viewModel || container.get(this.target);
      var controller = new Controller(this, instruction, viewModel, container);
      var childBindings = this.childBindings;
      var viewFactory = void 0;

      if (this.liftsContent) {
        au.controller = controller;
      } else if (this.elementName !== null) {
        viewFactory = instruction.viewFactory || this.viewFactory;
        container.viewModel = viewModel;

        if (viewFactory) {
          controller.view = viewFactory.create(container, instruction, element);
        }

        if (element !== null) {
          au.controller = controller;

          if (controller.view) {
            if (!this.usesShadowDOM && (element.childNodes.length === 1 || element.contentElement)) {
              var contentElement = element.childNodes[0] || element.contentElement;
              controller.view.contentView = { fragment: contentElement };
              contentElement.parentNode && _aureliaPal.DOM.removeNode(contentElement);
            }

            if (instruction.anchorIsContainer) {
              if (childBindings !== null) {
                for (var _i3 = 0, _ii3 = childBindings.length; _i3 < _ii3; ++_i3) {
                  controller.view.addBinding(childBindings[_i3].create(element, viewModel, controller));
                }
              }

              controller.view.appendNodesTo(viewHost);
            } else {
              controller.view.insertNodesBefore(viewHost);
            }
          } else if (childBindings !== null) {
            for (var _i4 = 0, _ii4 = childBindings.length; _i4 < _ii4; ++_i4) {
              bindings.push(childBindings[_i4].create(element, viewModel, controller));
            }
          }
        } else if (controller.view) {
          controller.view.controller = controller;

          if (childBindings !== null) {
            for (var _i5 = 0, _ii5 = childBindings.length; _i5 < _ii5; ++_i5) {
              controller.view.addBinding(childBindings[_i5].create(instruction.host, viewModel, controller));
            }
          }
        } else if (childBindings !== null) {
          for (var _i6 = 0, _ii6 = childBindings.length; _i6 < _ii6; ++_i6) {
            bindings.push(childBindings[_i6].create(instruction.host, viewModel, controller));
          }
        }
      } else if (childBindings !== null) {
        for (var _i7 = 0, _ii7 = childBindings.length; _i7 < _ii7; ++_i7) {
          bindings.push(childBindings[_i7].create(element, viewModel, controller));
        }
      }

      if (au !== null) {
        au[this.htmlName] = controller;
      }

      if (instruction.initiatedByBehavior && viewFactory) {
        controller.view.created();
      }

      return controller;
    };

    HtmlBehaviorResource.prototype._ensurePropertiesDefined = function _ensurePropertiesDefined(instance, lookup) {
      var properties = void 0;
      var i = void 0;
      var ii = void 0;
      var observer = void 0;

      if ('__propertiesDefined__' in lookup) {
        return;
      }

      lookup.__propertiesDefined__ = true;
      properties = this.properties;

      for (i = 0, ii = properties.length; i < ii; ++i) {
        observer = properties[i].createObserver(instance);

        if (observer !== undefined) {
          lookup[observer.propertyName] = observer;
        }
      }
    };

    HtmlBehaviorResource.prototype._copyInheritedProperties = function _copyInheritedProperties(container, target) {
      var _this13 = this;

      var behavior = void 0;
      var derived = target;

      while (true) {
        var proto = Object.getPrototypeOf(target.prototype);
        target = proto && proto.constructor;
        if (!target) {
          return;
        }
        behavior = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.resource, target);
        if (behavior) {
          break;
        }
      }
      behavior.initialize(container, target);

      var _loop = function _loop(_i8, _ii8) {
        var prop = behavior.properties[_i8];

        if (_this13.properties.some(function (p) {
          return p.name === prop.name;
        })) {
          return 'continue';
        }

        new BindableProperty(prop).registerWith(derived, _this13);
      };

      for (var _i8 = 0, _ii8 = behavior.properties.length; _i8 < _ii8; ++_i8) {
        var _ret = _loop(_i8, _ii8);

        if (_ret === 'continue') continue;
      }
    };

    return HtmlBehaviorResource;
  }();

  function createChildObserverDecorator(selectorOrConfig, all) {
    return function (target, key, descriptor) {
      var actualTarget = typeof key === 'string' ? target.constructor : target;
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);

      if (typeof selectorOrConfig === 'string') {
        selectorOrConfig = {
          selector: selectorOrConfig,
          name: key
        };
      }

      if (descriptor) {
        descriptor.writable = true;
        descriptor.configurable = true;
      }

      selectorOrConfig.all = all;
      r.addChildBinding(new ChildObserver(selectorOrConfig));
    };
  }

  function children(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, true);
  }

  function child(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, false);
  }

  var ChildObserver = function () {
    function ChildObserver(config) {
      

      this.name = config.name;
      this.changeHandler = config.changeHandler || this.name + 'Changed';
      this.selector = config.selector;
      this.all = config.all;
    }

    ChildObserver.prototype.create = function create(viewHost, viewModel, controller) {
      return new ChildObserverBinder(this.selector, viewHost, this.name, viewModel, controller, this.changeHandler, this.all);
    };

    return ChildObserver;
  }();

  var noMutations = [];

  function trackMutation(groupedMutations, binder, record) {
    var mutations = groupedMutations.get(binder);

    if (!mutations) {
      mutations = [];
      groupedMutations.set(binder, mutations);
    }

    mutations.push(record);
  }

  function onChildChange(mutations, observer) {
    var binders = observer.binders;
    var bindersLength = binders.length;
    var groupedMutations = new Map();

    for (var _i9 = 0, _ii9 = mutations.length; _i9 < _ii9; ++_i9) {
      var record = mutations[_i9];
      var added = record.addedNodes;
      var removed = record.removedNodes;

      for (var j = 0, jj = removed.length; j < jj; ++j) {
        var node = removed[j];
        if (node.nodeType === 1) {
          for (var k = 0; k < bindersLength; ++k) {
            var binder = binders[k];
            if (binder.onRemove(node)) {
              trackMutation(groupedMutations, binder, record);
            }
          }
        }
      }

      for (var _j = 0, _jj = added.length; _j < _jj; ++_j) {
        var _node = added[_j];
        if (_node.nodeType === 1) {
          for (var _k = 0; _k < bindersLength; ++_k) {
            var _binder = binders[_k];
            if (_binder.onAdd(_node)) {
              trackMutation(groupedMutations, _binder, record);
            }
          }
        }
      }
    }

    groupedMutations.forEach(function (value, key) {
      if (key.changeHandler !== null) {
        key.viewModel[key.changeHandler](value);
      }
    });
  }

  var ChildObserverBinder = function () {
    function ChildObserverBinder(selector, viewHost, property, viewModel, controller, changeHandler, all) {
      

      this.selector = selector;
      this.viewHost = viewHost;
      this.property = property;
      this.viewModel = viewModel;
      this.controller = controller;
      this.changeHandler = changeHandler in viewModel ? changeHandler : null;
      this.usesShadowDOM = controller.behavior.usesShadowDOM;
      this.all = all;

      if (!this.usesShadowDOM && controller.view && controller.view.contentView) {
        this.contentView = controller.view.contentView;
      } else {
        this.contentView = null;
      }
    }

    ChildObserverBinder.prototype.matches = function matches(element) {
      if (element.matches(this.selector)) {
        if (this.contentView === null) {
          return true;
        }

        var contentView = this.contentView;
        var assignedSlot = element.auAssignedSlot;

        if (assignedSlot && assignedSlot.projectFromAnchors) {
          var anchors = assignedSlot.projectFromAnchors;

          for (var _i10 = 0, _ii10 = anchors.length; _i10 < _ii10; ++_i10) {
            if (anchors[_i10].auOwnerView === contentView) {
              return true;
            }
          }

          return false;
        }

        return element.auOwnerView === contentView;
      }

      return false;
    };

    ChildObserverBinder.prototype.bind = function bind(source) {
      var viewHost = this.viewHost;
      var viewModel = this.viewModel;
      var observer = viewHost.__childObserver__;

      if (!observer) {
        observer = viewHost.__childObserver__ = _aureliaPal.DOM.createMutationObserver(onChildChange);

        var options = {
          childList: true,
          subtree: !this.usesShadowDOM
        };

        observer.observe(viewHost, options);
        observer.binders = [];
      }

      observer.binders.push(this);

      if (this.usesShadowDOM) {
        var current = viewHost.firstElementChild;

        if (this.all) {
          var items = viewModel[this.property];
          if (!items) {
            items = viewModel[this.property] = [];
          } else {
            items.length = 0;
          }

          while (current) {
            if (this.matches(current)) {
              items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
            }

            current = current.nextElementSibling;
          }

          if (this.changeHandler !== null) {
            this.viewModel[this.changeHandler](noMutations);
          }
        } else {
          while (current) {
            if (this.matches(current)) {
              var value = current.au && current.au.controller ? current.au.controller.viewModel : current;
              this.viewModel[this.property] = value;

              if (this.changeHandler !== null) {
                this.viewModel[this.changeHandler](value);
              }

              break;
            }

            current = current.nextElementSibling;
          }
        }
      }
    };

    ChildObserverBinder.prototype.onRemove = function onRemove(element) {
      if (this.matches(element)) {
        var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

        if (this.all) {
          var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);
          var index = items.indexOf(value);

          if (index !== -1) {
            items.splice(index, 1);
          }

          return true;
        }

        return false;
      }

      return false;
    };

    ChildObserverBinder.prototype.onAdd = function onAdd(element) {
      if (this.matches(element)) {
        var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

        if (this.all) {
          var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);

          if (this.selector === '*') {
            items.push(value);
            return true;
          }

          var index = 0;
          var prev = element.previousElementSibling;

          while (prev) {
            if (this.matches(prev)) {
              index++;
            }

            prev = prev.previousElementSibling;
          }

          items.splice(index, 0, value);
          return true;
        }

        this.viewModel[this.property] = value;

        if (this.changeHandler !== null) {
          this.viewModel[this.changeHandler](value);
        }
      }

      return false;
    };

    ChildObserverBinder.prototype.unbind = function unbind() {
      if (this.viewHost.__childObserver__) {
        this.viewHost.__childObserver__.disconnect();
        this.viewHost.__childObserver__ = null;
      }
    };

    return ChildObserverBinder;
  }();

  function remove(viewSlot, previous) {
    return Array.isArray(previous) ? viewSlot.removeMany(previous, true) : viewSlot.remove(previous, true);
  }

  var SwapStrategies = exports.SwapStrategies = {
    before: function before(viewSlot, previous, callback) {
      return previous === undefined ? callback() : callback().then(function () {
        return remove(viewSlot, previous);
      });
    },
    with: function _with(viewSlot, previous, callback) {
      return previous === undefined ? callback() : Promise.all([remove(viewSlot, previous), callback()]);
    },
    after: function after(viewSlot, previous, callback) {
      return Promise.resolve(viewSlot.removeAll(true)).then(callback);
    }
  };

  function tryActivateViewModel(context) {
    if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
      return Promise.resolve();
    }

    return context.viewModel.activate(context.model) || Promise.resolve();
  }

  var CompositionEngine = exports.CompositionEngine = (_dec10 = (0, _aureliaDependencyInjection.inject)(ViewEngine, ViewLocator), _dec10(_class17 = function () {
    function CompositionEngine(viewEngine, viewLocator) {
      

      this.viewEngine = viewEngine;
      this.viewLocator = viewLocator;
    }

    CompositionEngine.prototype._swap = function _swap(context, view) {
      var swapStrategy = SwapStrategies[context.swapOrder] || SwapStrategies.after;
      var previousViews = context.viewSlot.children.slice();

      return swapStrategy(context.viewSlot, previousViews, function () {
        return Promise.resolve(context.viewSlot.add(view)).then(function () {
          if (context.currentController) {
            context.currentController.unbind();
          }
        });
      }).then(function () {
        if (context.compositionTransactionNotifier) {
          context.compositionTransactionNotifier.done();
        }
      });
    };

    CompositionEngine.prototype._createControllerAndSwap = function _createControllerAndSwap(context) {
      var _this14 = this;

      return this.createController(context).then(function (controller) {
        controller.automate(context.overrideContext, context.owningView);

        if (context.compositionTransactionOwnershipToken) {
          return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
            return _this14._swap(context, controller.view);
          }).then(function () {
            return controller;
          });
        }

        return _this14._swap(context, controller.view).then(function () {
          return controller;
        });
      });
    };

    CompositionEngine.prototype.createController = function createController(context) {
      var _this15 = this;

      var childContainer = void 0;
      var viewModel = void 0;
      var viewModelResource = void 0;
      var m = void 0;

      return this.ensureViewModel(context).then(tryActivateViewModel).then(function () {
        childContainer = context.childContainer;
        viewModel = context.viewModel;
        viewModelResource = context.viewModelResource;
        m = viewModelResource.metadata;

        var viewStrategy = _this15.viewLocator.getViewStrategy(context.view || viewModel);

        if (context.viewResources) {
          viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
        }

        return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
      }).then(function (viewFactory) {
        return m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory));
      });
    };

    CompositionEngine.prototype.ensureViewModel = function ensureViewModel(context) {
      var childContainer = context.childContainer = context.childContainer || context.container.createChild();

      if (typeof context.viewModel === 'string') {
        context.viewModel = context.viewResources ? context.viewResources.relativeToView(context.viewModel) : context.viewModel;

        return this.viewEngine.importViewModelResource(context.viewModel).then(function (viewModelResource) {
          childContainer.autoRegister(viewModelResource.value);

          if (context.host) {
            childContainer.registerInstance(_aureliaPal.DOM.Element, context.host);
          }

          context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
          context.viewModelResource = viewModelResource;
          return context;
        });
      }

      var m = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, context.viewModel.constructor);
      m.elementName = m.elementName || 'dynamic-element';
      m.initialize(context.container || childContainer, context.viewModel.constructor);
      context.viewModelResource = { metadata: m, value: context.viewModel.constructor };
      childContainer.viewModel = context.viewModel;
      return Promise.resolve(context);
    };

    CompositionEngine.prototype.compose = function compose(context) {
      var _this16 = this;

      context.childContainer = context.childContainer || context.container.createChild();
      context.view = this.viewLocator.getViewStrategy(context.view);

      var transaction = context.childContainer.get(CompositionTransaction);
      var compositionTransactionOwnershipToken = transaction.tryCapture();

      if (compositionTransactionOwnershipToken) {
        context.compositionTransactionOwnershipToken = compositionTransactionOwnershipToken;
      } else {
        context.compositionTransactionNotifier = transaction.enlist();
      }

      if (context.viewModel) {
        return this._createControllerAndSwap(context);
      } else if (context.view) {
        if (context.viewResources) {
          context.view.makeRelativeTo(context.viewResources.viewUrl);
        }

        return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(function (viewFactory) {
          var result = viewFactory.create(context.childContainer);
          result.bind(context.bindingContext, context.overrideContext);

          if (context.compositionTransactionOwnershipToken) {
            return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
              return _this16._swap(context, result);
            }).then(function () {
              return result;
            });
          }

          return _this16._swap(context, result).then(function () {
            return result;
          });
        });
      } else if (context.viewSlot) {
        context.viewSlot.removeAll();

        if (context.compositionTransactionNotifier) {
          context.compositionTransactionNotifier.done();
        }

        return Promise.resolve(null);
      }

      return Promise.resolve(null);
    };

    return CompositionEngine;
  }()) || _class17);

  var ElementConfigResource = exports.ElementConfigResource = function () {
    function ElementConfigResource() {
      
    }

    ElementConfigResource.prototype.initialize = function initialize(container, target) {};

    ElementConfigResource.prototype.register = function register(registry, name) {};

    ElementConfigResource.prototype.load = function load(container, target) {
      var config = new target();
      var eventManager = container.get(_aureliaBinding.EventManager);
      eventManager.registerElementConfig(config);
    };

    return ElementConfigResource;
  }();

  function validateBehaviorName(name, type) {
    if (/[A-Z]/.test(name)) {
      var newName = _hyphenate(name);
      LogManager.getLogger('templating').warn('\'' + name + '\' is not a valid ' + type + ' name and has been converted to \'' + newName + '\'. Upper-case letters are not allowed because the DOM is not case-sensitive.');
      return newName;
    }
    return name;
  }

  function resource(instance) {
    return function (target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, instance, target);
    };
  }

  function behavior(override) {
    return function (target) {
      if (override instanceof HtmlBehaviorResource) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, override, target);
      } else {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
        Object.assign(r, override);
      }
    };
  }

  function customElement(name) {
    return function (target) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      r.elementName = validateBehaviorName(name, 'custom element');
    };
  }

  function customAttribute(name, defaultBindingMode, aliases) {
    return function (target) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      r.attributeName = validateBehaviorName(name, 'custom attribute');
      r.attributeDefaultBindingMode = defaultBindingMode;
      r.aliases = aliases;
    };
  }

  function templateController(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.liftsContent = true;
    };

    return target ? deco(target) : deco;
  }

  function bindable(nameOrConfigOrTarget, key, descriptor) {
    var deco = function deco(target, key2, descriptor2) {
      var actualTarget = key2 ? target.constructor : target;
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
      var prop = void 0;

      if (key2) {
        nameOrConfigOrTarget = nameOrConfigOrTarget || {};
        nameOrConfigOrTarget.name = key2;
      }

      prop = new BindableProperty(nameOrConfigOrTarget);
      return prop.registerWith(actualTarget, r, descriptor2);
    };

    if (!nameOrConfigOrTarget) {
      return deco;
    }

    if (key) {
      var _target = nameOrConfigOrTarget;
      nameOrConfigOrTarget = null;
      return deco(_target, key, descriptor);
    }

    return deco;
  }

  function dynamicOptions(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.hasDynamicOptions = true;
    };

    return target ? deco(target) : deco;
  }

  var defaultShadowDOMOptions = { mode: 'open' };
  function useShadowDOM(targetOrOptions) {
    var options = typeof targetOrOptions === 'function' || !targetOrOptions ? defaultShadowDOMOptions : targetOrOptions;

    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.targetShadowDOM = true;
      r.shadowDOMOptions = options;
    };

    return typeof targetOrOptions === 'function' ? deco(targetOrOptions) : deco;
  }

  function processAttributes(processor) {
    return function (t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.processAttributes = function (compiler, resources, node, attributes, elementInstruction) {
        try {
          processor(compiler, resources, node, attributes, elementInstruction);
        } catch (error) {
          LogManager.getLogger('templating').error(error);
        }
      };
    };
  }

  function doNotProcessContent() {
    return false;
  }

  function processContent(processor) {
    return function (t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.processContent = processor ? function (compiler, resources, node, instruction) {
        try {
          return processor(compiler, resources, node, instruction);
        } catch (error) {
          LogManager.getLogger('templating').error(error);
          return false;
        }
      } : doNotProcessContent;
    };
  }

  function containerless(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.containerless = true;
    };

    return target ? deco(target) : deco;
  }

  function useViewStrategy(strategy) {
    return function (target) {
      _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
    };
  }

  function useView(path) {
    return useViewStrategy(new RelativeViewStrategy(path));
  }

  function inlineView(markup, dependencies, dependencyBaseUrl) {
    return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
  }

  function noView(targetOrDependencies, dependencyBaseUrl) {
    var target = void 0;
    var dependencies = void 0;
    if (typeof targetOrDependencies === 'function') {
      target = targetOrDependencies;
    } else {
      dependencies = targetOrDependencies;
      target = undefined;
    }

    var deco = function deco(t) {
      _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(dependencies, dependencyBaseUrl), t);
    };

    return target ? deco(target) : deco;
  }

  function elementConfig(target) {
    var deco = function deco(t) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ElementConfigResource(), t);
    };

    return target ? deco(target) : deco;
  }

  function viewResources() {
    for (var _len = arguments.length, resources = Array(_len), _key = 0; _key < _len; _key++) {
      resources[_key] = arguments[_key];
    }

    return function (target) {
      _aureliaMetadata.metadata.define(ViewEngine.viewModelRequireMetadataKey, resources, target);
    };
  }

  var TemplatingEngine = exports.TemplatingEngine = (_dec11 = (0, _aureliaDependencyInjection.inject)(_aureliaDependencyInjection.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine), _dec11(_class18 = function () {
    function TemplatingEngine(container, moduleAnalyzer, viewCompiler, compositionEngine) {
      

      this._container = container;
      this._moduleAnalyzer = moduleAnalyzer;
      this._viewCompiler = viewCompiler;
      this._compositionEngine = compositionEngine;
      container.registerInstance(Animator, Animator.instance = new Animator());
    }

    TemplatingEngine.prototype.configureAnimator = function configureAnimator(animator) {
      this._container.unregister(Animator);
      this._container.registerInstance(Animator, Animator.instance = animator);
    };

    TemplatingEngine.prototype.compose = function compose(context) {
      return this._compositionEngine.compose(context);
    };

    TemplatingEngine.prototype.enhance = function enhance(instruction) {
      if (instruction instanceof _aureliaPal.DOM.Element) {
        instruction = { element: instruction };
      }

      var compilerInstructions = {};
      var resources = instruction.resources || this._container.get(ViewResources);

      this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);

      var factory = new ViewFactory(instruction.element, compilerInstructions, resources);
      var container = instruction.container || this._container.createChild();
      var view = factory.create(container, BehaviorInstruction.enhance());

      view.bind(instruction.bindingContext || {}, instruction.overrideContext);

      view.firstChild = view.lastChild = view.fragment;
      view.fragment = _aureliaPal.DOM.createDocumentFragment();
      view.attached();

      return view;
    };

    return TemplatingEngine;
  }()) || _class18);
});
define('aurelia-templating-resources/compose',['exports', 'aurelia-dependency-injection', 'aurelia-logging', 'aurelia-task-queue', 'aurelia-templating', 'aurelia-pal'], function (exports, _aureliaDependencyInjection, _aureliaLogging, _aureliaTaskQueue, _aureliaTemplating, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Compose = undefined;

  var LogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _initDefineProp(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
  }

  var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

  var logger = LogManager.getLogger('templating-resources');

  var Compose = exports.Compose = (_dec = (0, _aureliaTemplating.customElement)('compose'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.CompositionEngine, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaTaskQueue.TaskQueue), _dec(_class = (0, _aureliaTemplating.noView)(_class = _dec2(_class = (_class2 = function () {
    function Compose(element, container, compositionEngine, viewSlot, viewResources, taskQueue) {
      

      _initDefineProp(this, 'model', _descriptor, this);

      _initDefineProp(this, 'view', _descriptor2, this);

      _initDefineProp(this, 'viewModel', _descriptor3, this);

      _initDefineProp(this, 'swapOrder', _descriptor4, this);

      this.element = element;
      this.container = container;
      this.compositionEngine = compositionEngine;
      this.viewSlot = viewSlot;
      this.viewResources = viewResources;
      this.taskQueue = taskQueue;
      this.currentController = null;
      this.currentViewModel = null;
      this.changes = Object.create(null);
    }

    Compose.prototype.created = function created(owningView) {
      this.owningView = owningView;
    };

    Compose.prototype.bind = function bind(bindingContext, overrideContext) {
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext;
      this.changes.view = this.view;
      this.changes.viewModel = this.viewModel;
      this.changes.model = this.model;
      processChanges(this);
    };

    Compose.prototype.unbind = function unbind() {
      this.changes = Object.create(null);
      this.pendingTask = null;
      this.bindingContext = null;
      this.overrideContext = null;
      var returnToCache = true;
      var skipAnimation = true;
      this.viewSlot.removeAll(returnToCache, skipAnimation);
    };

    Compose.prototype.modelChanged = function modelChanged(newValue, oldValue) {
      this.changes.model = newValue;
      requestUpdate(this);
    };

    Compose.prototype.viewChanged = function viewChanged(newValue, oldValue) {
      this.changes.view = newValue;
      requestUpdate(this);
    };

    Compose.prototype.viewModelChanged = function viewModelChanged(newValue, oldValue) {
      this.changes.viewModel = newValue;
      requestUpdate(this);
    };

    return Compose;
  }(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'model', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'view', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'viewModel', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  })), _class2)) || _class) || _class) || _class);


  function isEmpty(obj) {
    for (var key in obj) {
      return false;
    }
    return true;
  }

  function tryActivateViewModel(vm, model) {
    if (vm && typeof vm.activate === 'function') {
      return Promise.resolve(vm.activate(model));
    }
  }

  function createInstruction(composer, instruction) {
    return Object.assign(instruction, {
      bindingContext: composer.bindingContext,
      overrideContext: composer.overrideContext,
      owningView: composer.owningView,
      container: composer.container,
      viewSlot: composer.viewSlot,
      viewResources: composer.viewResources,
      currentController: composer.currentController,
      host: composer.element,
      swapOrder: composer.swapOrder
    });
  }

  function processChanges(composer) {
    var changes = composer.changes;
    composer.changes = Object.create(null);

    if (!('view' in changes) && !('viewModel' in changes) && 'model' in changes) {
      composer.pendingTask = tryActivateViewModel(composer.currentViewModel, changes.model);
      if (!composer.pendingTask) {
        return;
      }
    } else {
      var instruction = {
        view: composer.view,
        viewModel: composer.currentViewModel || composer.viewModel,
        model: composer.model
      };

      instruction = Object.assign(instruction, changes);

      instruction = createInstruction(composer, instruction);
      composer.pendingTask = composer.compositionEngine.compose(instruction).then(function (controller) {
        composer.currentController = controller;
        composer.currentViewModel = controller ? controller.viewModel : null;
      });
    }

    composer.pendingTask = composer.pendingTask.catch(function (e) {
      logger.error(e);
    }).then(function () {
      if (!composer.pendingTask) {
        return;
      }

      composer.pendingTask = null;
      if (!isEmpty(composer.changes)) {
        processChanges(composer);
      }
    });
  }

  function requestUpdate(composer) {
    if (composer.pendingTask || composer.updateRequested) {
      return;
    }
    composer.updateRequested = true;
    composer.taskQueue.queueMicroTask(function () {
      composer.updateRequested = false;
      processChanges(composer);
    });
  }
});
define('aurelia-templating-resources/if',['exports', 'aurelia-templating', 'aurelia-dependency-injection', './if-core'], function (exports, _aureliaTemplating, _aureliaDependencyInjection, _ifCore) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.If = undefined;

  function _initDefineProp(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
  }

  var _dec, _dec2, _dec3, _class, _desc, _value, _class2, _descriptor, _descriptor2;

  var If = exports.If = (_dec = (0, _aureliaTemplating.customAttribute)('if'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec3 = (0, _aureliaTemplating.bindable)({ primaryProperty: true }), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_IfCore) {
    _inherits(If, _IfCore);

    function If() {
      var _temp, _this, _ret;

      

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _IfCore.call.apply(_IfCore, [this].concat(args))), _this), _initDefineProp(_this, 'condition', _descriptor, _this), _initDefineProp(_this, 'swapOrder', _descriptor2, _this), _temp), _possibleConstructorReturn(_this, _ret);
    }

    If.prototype.bind = function bind(bindingContext, overrideContext) {
      _IfCore.prototype.bind.call(this, bindingContext, overrideContext);
      if (this.condition) {
        this._show();
      } else {
        this._hide();
      }
    };

    If.prototype.conditionChanged = function conditionChanged(newValue) {
      this._update(newValue);
    };

    If.prototype._update = function _update(show) {
      var _this2 = this;

      if (this.animating) {
        return;
      }

      var promise = void 0;
      if (this.elseVm) {
        promise = show ? this._swap(this.elseVm, this) : this._swap(this, this.elseVm);
      } else {
        promise = show ? this._show() : this._hide();
      }

      if (promise) {
        this.animating = true;
        promise.then(function () {
          _this2.animating = false;
          if (_this2.condition !== _this2.showing) {
            _this2._update(_this2.condition);
          }
        });
      }
    };

    If.prototype._swap = function _swap(remove, add) {
      switch (this.swapOrder) {
        case 'before':
          return Promise.resolve(add._show()).then(function () {
            return remove._hide();
          });
        case 'with':
          return Promise.all([remove._hide(), add._show()]);
        default:
          var promise = remove._hide();
          return promise ? promise.then(function () {
            return add._show();
          }) : add._show();
      }
    };

    return If;
  }(_ifCore.IfCore), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'condition', [_dec3], {
    enumerable: true,
    initializer: null
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'swapOrder', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  })), _class2)) || _class) || _class) || _class);
});
define('aurelia-templating-resources/if-core',["exports"], function (exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  

  var IfCore = exports.IfCore = function () {
    function IfCore(viewFactory, viewSlot) {
      

      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.view = null;
      this.bindingContext = null;
      this.overrideContext = null;

      this.showing = false;
    }

    IfCore.prototype.bind = function bind(bindingContext, overrideContext) {
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext;
    };

    IfCore.prototype.unbind = function unbind() {
      if (this.view === null) {
        return;
      }

      this.view.unbind();

      if (!this.viewFactory.isCaching) {
        return;
      }

      if (this.showing) {
        this.showing = false;
        this.viewSlot.remove(this.view, true, true);
      } else {
        this.view.returnToCache();
      }

      this.view = null;
    };

    IfCore.prototype._show = function _show() {
      if (this.showing) {
        if (!this.view.isBound) {
          this.view.bind(this.bindingContext, this.overrideContext);
        }
        return;
      }

      if (this.view === null) {
        this.view = this.viewFactory.create();
      }

      if (!this.view.isBound) {
        this.view.bind(this.bindingContext, this.overrideContext);
      }

      this.showing = true;
      return this.viewSlot.add(this.view);
    };

    IfCore.prototype._hide = function _hide() {
      var _this = this;

      if (!this.showing) {
        return;
      }

      this.showing = false;
      var removed = this.viewSlot.remove(this.view);

      if (removed instanceof Promise) {
        return removed.then(function () {
          return _this.view.unbind();
        });
      }

      this.view.unbind();
    };

    return IfCore;
  }();
});
define('aurelia-templating-resources/else',['exports', 'aurelia-templating', 'aurelia-dependency-injection', './if-core'], function (exports, _aureliaTemplating, _aureliaDependencyInjection, _ifCore) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Else = undefined;

  

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var _dec, _dec2, _class;

  var Else = exports.Else = (_dec = (0, _aureliaTemplating.customAttribute)('else'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function (_IfCore) {
    _inherits(Else, _IfCore);

    function Else(viewFactory, viewSlot) {
      

      var _this = _possibleConstructorReturn(this, _IfCore.call(this, viewFactory, viewSlot));

      _this._registerInIf();
      return _this;
    }

    Else.prototype.bind = function bind(bindingContext, overrideContext) {
      _IfCore.prototype.bind.call(this, bindingContext, overrideContext);

      if (this.ifVm.condition) {
        this._hide();
      } else {
        this._show();
      }
    };

    Else.prototype._registerInIf = function _registerInIf() {
      var previous = this.viewSlot.anchor.previousSibling;
      while (previous && !previous.au) {
        previous = previous.previousSibling;
      }
      if (!previous || !previous.au.if) {
        throw new Error("Can't find matching If for Else custom attribute.");
      }
      this.ifVm = previous.au.if.viewModel;
      this.ifVm.elseVm = this;
    };

    return Else;
  }(_ifCore.IfCore)) || _class) || _class) || _class);
});
define('aurelia-templating-resources/with',['exports', 'aurelia-dependency-injection', 'aurelia-templating', 'aurelia-binding'], function (exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.With = undefined;

  

  var _dec, _dec2, _class;

  var With = exports.With = (_dec = (0, _aureliaTemplating.customAttribute)('with'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
    function With(viewFactory, viewSlot) {
      

      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.parentOverrideContext = null;
      this.view = null;
    }

    With.prototype.bind = function bind(bindingContext, overrideContext) {
      this.parentOverrideContext = overrideContext;
      this.valueChanged(this.value);
    };

    With.prototype.valueChanged = function valueChanged(newValue) {
      var overrideContext = (0, _aureliaBinding.createOverrideContext)(newValue, this.parentOverrideContext);
      if (!this.view) {
        this.view = this.viewFactory.create();
        this.view.bind(newValue, overrideContext);
        this.viewSlot.add(this.view);
      } else {
        this.view.bind(newValue, overrideContext);
      }
    };

    With.prototype.unbind = function unbind() {
      this.parentOverrideContext = null;

      if (this.view) {
        this.view.unbind();
      }
    };

    return With;
  }()) || _class) || _class) || _class);
});
define('aurelia-templating-resources/repeat',['exports', 'aurelia-dependency-injection', 'aurelia-binding', 'aurelia-templating', './repeat-strategy-locator', './repeat-utilities', './analyze-view-factory', './abstract-repeater'], function (exports, _aureliaDependencyInjection, _aureliaBinding, _aureliaTemplating, _repeatStrategyLocator, _repeatUtilities, _analyzeViewFactory, _abstractRepeater) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Repeat = undefined;

  function _initDefineProp(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
  }

  var _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

  var Repeat = exports.Repeat = (_dec = (0, _aureliaTemplating.customAttribute)('repeat'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _repeatStrategyLocator.RepeatStrategyLocator), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = (_class2 = function (_AbstractRepeater) {
    _inherits(Repeat, _AbstractRepeater);

    function Repeat(viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
      

      var _this = _possibleConstructorReturn(this, _AbstractRepeater.call(this, {
        local: 'item',
        viewsRequireLifecycle: (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory)
      }));

      _initDefineProp(_this, 'items', _descriptor, _this);

      _initDefineProp(_this, 'local', _descriptor2, _this);

      _initDefineProp(_this, 'key', _descriptor3, _this);

      _initDefineProp(_this, 'value', _descriptor4, _this);

      _this.viewFactory = viewFactory;
      _this.instruction = instruction;
      _this.viewSlot = viewSlot;
      _this.lookupFunctions = viewResources.lookupFunctions;
      _this.observerLocator = observerLocator;
      _this.key = 'key';
      _this.value = 'value';
      _this.strategyLocator = strategyLocator;
      _this.ignoreMutation = false;
      _this.sourceExpression = (0, _repeatUtilities.getItemsSourceExpression)(_this.instruction, 'repeat.for');
      _this.isOneTime = (0, _repeatUtilities.isOneTime)(_this.sourceExpression);
      _this.viewsRequireLifecycle = (0, _analyzeViewFactory.viewsRequireLifecycle)(viewFactory);
      return _this;
    }

    Repeat.prototype.call = function call(context, changes) {
      this[context](this.items, changes);
    };

    Repeat.prototype.bind = function bind(bindingContext, overrideContext) {
      this.scope = { bindingContext: bindingContext, overrideContext: overrideContext };
      this.matcherBinding = this._captureAndRemoveMatcherBinding();
      this.itemsChanged();
    };

    Repeat.prototype.unbind = function unbind() {
      this.scope = null;
      this.items = null;
      this.matcherBinding = null;
      this.viewSlot.removeAll(true, true);
      this._unsubscribeCollection();
    };

    Repeat.prototype._unsubscribeCollection = function _unsubscribeCollection() {
      if (this.collectionObserver) {
        this.collectionObserver.unsubscribe(this.callContext, this);
        this.collectionObserver = null;
        this.callContext = null;
      }
    };

    Repeat.prototype.itemsChanged = function itemsChanged() {
      this._unsubscribeCollection();

      if (!this.scope) {
        return;
      }

      var items = this.items;
      this.strategy = this.strategyLocator.getStrategy(items);
      if (!this.strategy) {
        throw new Error('Value for \'' + this.sourceExpression + '\' is non-repeatable');
      }

      if (!this.isOneTime && !this._observeInnerCollection()) {
        this._observeCollection();
      }
      this.strategy.instanceChanged(this, items);
    };

    Repeat.prototype._getInnerCollection = function _getInnerCollection() {
      var expression = (0, _repeatUtilities.unwrapExpression)(this.sourceExpression);
      if (!expression) {
        return null;
      }
      return expression.evaluate(this.scope, null);
    };

    Repeat.prototype.handleCollectionMutated = function handleCollectionMutated(collection, changes) {
      if (!this.collectionObserver) {
        return;
      }
      this.strategy.instanceMutated(this, collection, changes);
    };

    Repeat.prototype.handleInnerCollectionMutated = function handleInnerCollectionMutated(collection, changes) {
      var _this2 = this;

      if (!this.collectionObserver) {
        return;
      }

      if (this.ignoreMutation) {
        return;
      }
      this.ignoreMutation = true;
      var newItems = this.sourceExpression.evaluate(this.scope, this.lookupFunctions);
      this.observerLocator.taskQueue.queueMicroTask(function () {
        return _this2.ignoreMutation = false;
      });

      if (newItems === this.items) {
        this.itemsChanged();
      } else {
        this.items = newItems;
      }
    };

    Repeat.prototype._observeInnerCollection = function _observeInnerCollection() {
      var items = this._getInnerCollection();
      var strategy = this.strategyLocator.getStrategy(items);
      if (!strategy) {
        return false;
      }
      this.collectionObserver = strategy.getCollectionObserver(this.observerLocator, items);
      if (!this.collectionObserver) {
        return false;
      }
      this.callContext = 'handleInnerCollectionMutated';
      this.collectionObserver.subscribe(this.callContext, this);
      return true;
    };

    Repeat.prototype._observeCollection = function _observeCollection() {
      var items = this.items;
      this.collectionObserver = this.strategy.getCollectionObserver(this.observerLocator, items);
      if (this.collectionObserver) {
        this.callContext = 'handleCollectionMutated';
        this.collectionObserver.subscribe(this.callContext, this);
      }
    };

    Repeat.prototype._captureAndRemoveMatcherBinding = function _captureAndRemoveMatcherBinding() {
      if (this.viewFactory.viewFactory) {
        var instructions = this.viewFactory.viewFactory.instructions;
        var instructionIds = Object.keys(instructions);
        for (var i = 0; i < instructionIds.length; i++) {
          var expressions = instructions[instructionIds[i]].expressions;
          if (expressions) {
            for (var ii = 0; i < expressions.length; i++) {
              if (expressions[ii].targetProperty === 'matcher') {
                var matcherBinding = expressions[ii];
                expressions.splice(ii, 1);
                return matcherBinding;
              }
            }
          }
        }
      }

      return undefined;
    };

    Repeat.prototype.viewCount = function viewCount() {
      return this.viewSlot.children.length;
    };

    Repeat.prototype.views = function views() {
      return this.viewSlot.children;
    };

    Repeat.prototype.view = function view(index) {
      return this.viewSlot.children[index];
    };

    Repeat.prototype.matcher = function matcher() {
      return this.matcherBinding ? this.matcherBinding.sourceExpression.evaluate(this.scope, this.matcherBinding.lookupFunctions) : null;
    };

    Repeat.prototype.addView = function addView(bindingContext, overrideContext) {
      var view = this.viewFactory.create();
      view.bind(bindingContext, overrideContext);
      this.viewSlot.add(view);
    };

    Repeat.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
      var view = this.viewFactory.create();
      view.bind(bindingContext, overrideContext);
      this.viewSlot.insert(index, view);
    };

    Repeat.prototype.moveView = function moveView(sourceIndex, targetIndex) {
      this.viewSlot.move(sourceIndex, targetIndex);
    };

    Repeat.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
      return this.viewSlot.removeAll(returnToCache, skipAnimation);
    };

    Repeat.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
      return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
    };

    Repeat.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
      return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
    };

    Repeat.prototype.updateBindings = function updateBindings(view) {
      var j = view.bindings.length;
      while (j--) {
        (0, _repeatUtilities.updateOneTimeBinding)(view.bindings[j]);
      }
      j = view.controllers.length;
      while (j--) {
        var k = view.controllers[j].boundProperties.length;
        while (k--) {
          var binding = view.controllers[j].boundProperties[k].binding;
          (0, _repeatUtilities.updateOneTimeBinding)(binding);
        }
      }
    };

    return Repeat;
  }(_abstractRepeater.AbstractRepeater), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'items', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'local', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'key', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, 'value', [_aureliaTemplating.bindable], {
    enumerable: true,
    initializer: null
  })), _class2)) || _class) || _class) || _class);
});
define('aurelia-templating-resources/repeat-strategy-locator',['exports', './null-repeat-strategy', './array-repeat-strategy', './map-repeat-strategy', './set-repeat-strategy', './number-repeat-strategy'], function (exports, _nullRepeatStrategy, _arrayRepeatStrategy, _mapRepeatStrategy, _setRepeatStrategy, _numberRepeatStrategy) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RepeatStrategyLocator = undefined;

  

  var RepeatStrategyLocator = exports.RepeatStrategyLocator = function () {
    function RepeatStrategyLocator() {
      

      this.matchers = [];
      this.strategies = [];

      this.addStrategy(function (items) {
        return items === null || items === undefined;
      }, new _nullRepeatStrategy.NullRepeatStrategy());
      this.addStrategy(function (items) {
        return items instanceof Array;
      }, new _arrayRepeatStrategy.ArrayRepeatStrategy());
      this.addStrategy(function (items) {
        return items instanceof Map;
      }, new _mapRepeatStrategy.MapRepeatStrategy());
      this.addStrategy(function (items) {
        return items instanceof Set;
      }, new _setRepeatStrategy.SetRepeatStrategy());
      this.addStrategy(function (items) {
        return typeof items === 'number';
      }, new _numberRepeatStrategy.NumberRepeatStrategy());
    }

    RepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
      this.matchers.push(matcher);
      this.strategies.push(strategy);
    };

    RepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
      var matchers = this.matchers;

      for (var i = 0, ii = matchers.length; i < ii; ++i) {
        if (matchers[i](items)) {
          return this.strategies[i];
        }
      }

      return null;
    };

    return RepeatStrategyLocator;
  }();
});
define('aurelia-templating-resources/null-repeat-strategy',["exports"], function (exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  

  var NullRepeatStrategy = exports.NullRepeatStrategy = function () {
    function NullRepeatStrategy() {
      
    }

    NullRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      repeat.removeAllViews(true);
    };

    NullRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {};

    return NullRepeatStrategy;
  }();
});
define('aurelia-templating-resources/array-repeat-strategy',['exports', './repeat-utilities', 'aurelia-binding'], function (exports, _repeatUtilities, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ArrayRepeatStrategy = undefined;

  

  var ArrayRepeatStrategy = exports.ArrayRepeatStrategy = function () {
    function ArrayRepeatStrategy() {
      
    }

    ArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getArrayObserver(items);
    };

    ArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;

      var itemsLength = items.length;

      if (!items || itemsLength === 0) {
        repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        return;
      }

      var children = repeat.views();
      var viewsLength = children.length;

      if (viewsLength === 0) {
        this._standardProcessInstanceChanged(repeat, items);
        return;
      }

      if (repeat.viewsRequireLifecycle) {
        var childrenSnapshot = children.slice(0);
        var itemNameInBindingContext = repeat.local;
        var matcher = repeat.matcher();

        var itemsPreviouslyInViews = [];
        var viewsToRemove = [];

        for (var index = 0; index < viewsLength; index++) {
          var view = childrenSnapshot[index];
          var oldItem = view.bindingContext[itemNameInBindingContext];

          if ((0, _repeatUtilities.indexOf)(items, oldItem, matcher) === -1) {
            viewsToRemove.push(view);
          } else {
            itemsPreviouslyInViews.push(oldItem);
          }
        }

        var updateViews = void 0;
        var removePromise = void 0;

        if (itemsPreviouslyInViews.length > 0) {
          removePromise = repeat.removeViews(viewsToRemove, true, !repeat.viewsRequireLifecycle);
          updateViews = function updateViews() {
            for (var _index = 0; _index < itemsLength; _index++) {
              var item = items[_index];
              var indexOfView = (0, _repeatUtilities.indexOf)(itemsPreviouslyInViews, item, matcher, _index);
              var _view = void 0;

              if (indexOfView === -1) {
                var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_index], _index, itemsLength);
                repeat.insertView(_index, overrideContext.bindingContext, overrideContext);

                itemsPreviouslyInViews.splice(_index, 0, undefined);
              } else if (indexOfView === _index) {
                _view = children[indexOfView];
                itemsPreviouslyInViews[indexOfView] = undefined;
              } else {
                _view = children[indexOfView];
                repeat.moveView(indexOfView, _index);
                itemsPreviouslyInViews.splice(indexOfView, 1);
                itemsPreviouslyInViews.splice(_index, 0, undefined);
              }

              if (_view) {
                (0, _repeatUtilities.updateOverrideContext)(_view.overrideContext, _index, itemsLength);
              }
            }

            _this._inPlaceProcessItems(repeat, items);
          };
        } else {
          removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
          updateViews = function updateViews() {
            return _this._standardProcessInstanceChanged(repeat, items);
          };
        }

        if (removePromise instanceof Promise) {
          removePromise.then(updateViews);
        } else {
          updateViews();
        }
      } else {
        this._inPlaceProcessItems(repeat, items);
      }
    };

    ArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
      for (var i = 0, ii = items.length; i < ii; i++) {
        var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[i], i, ii);
        repeat.addView(overrideContext.bindingContext, overrideContext);
      }
    };

    ArrayRepeatStrategy.prototype._inPlaceProcessItems = function _inPlaceProcessItems(repeat, items) {
      var itemsLength = items.length;
      var viewsLength = repeat.viewCount();

      while (viewsLength > itemsLength) {
        viewsLength--;
        repeat.removeView(viewsLength, true, !repeat.viewsRequireLifecycle);
      }

      var local = repeat.local;

      for (var i = 0; i < viewsLength; i++) {
        var view = repeat.view(i);
        var last = i === itemsLength - 1;
        var middle = i !== 0 && !last;

        if (view.bindingContext[local] === items[i] && view.overrideContext.$middle === middle && view.overrideContext.$last === last) {
          continue;
        }

        view.bindingContext[local] = items[i];
        view.overrideContext.$middle = middle;
        view.overrideContext.$last = last;
        repeat.updateBindings(view);
      }

      for (var _i = viewsLength; _i < itemsLength; _i++) {
        var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, items[_i], _i, itemsLength);
        repeat.addView(overrideContext.bindingContext, overrideContext);
      }
    };

    ArrayRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, array, splices) {
      var _this2 = this;

      if (repeat.__queuedSplices) {
        for (var i = 0, ii = splices.length; i < ii; ++i) {
          var _splices$i = splices[i],
              index = _splices$i.index,
              removed = _splices$i.removed,
              addedCount = _splices$i.addedCount;

          (0, _aureliaBinding.mergeSplice)(repeat.__queuedSplices, index, removed, addedCount);
        }

        repeat.__array = array.slice(0);
        return;
      }

      var maybePromise = this._runSplices(repeat, array.slice(0), splices);
      if (maybePromise instanceof Promise) {
        var queuedSplices = repeat.__queuedSplices = [];

        var runQueuedSplices = function runQueuedSplices() {
          if (!queuedSplices.length) {
            repeat.__queuedSplices = undefined;
            repeat.__array = undefined;
            return;
          }

          var nextPromise = _this2._runSplices(repeat, repeat.__array, queuedSplices) || Promise.resolve();
          queuedSplices = repeat.__queuedSplices = [];
          nextPromise.then(runQueuedSplices);
        };

        maybePromise.then(runQueuedSplices);
      }
    };

    ArrayRepeatStrategy.prototype._runSplices = function _runSplices(repeat, array, splices) {
      var _this3 = this;

      var removeDelta = 0;
      var rmPromises = [];

      for (var i = 0, ii = splices.length; i < ii; ++i) {
        var splice = splices[i];
        var removed = splice.removed;

        for (var j = 0, jj = removed.length; j < jj; ++j) {
          var viewOrPromise = repeat.removeView(splice.index + removeDelta + rmPromises.length, true);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
        }
        removeDelta -= splice.addedCount;
      }

      if (rmPromises.length > 0) {
        return Promise.all(rmPromises).then(function () {
          var spliceIndexLow = _this3._handleAddedSplices(repeat, array, splices);
          (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);
        });
      }

      var spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), spliceIndexLow);

      return undefined;
    };

    ArrayRepeatStrategy.prototype._handleAddedSplices = function _handleAddedSplices(repeat, array, splices) {
      var spliceIndex = void 0;
      var spliceIndexLow = void 0;
      var arrayLength = array.length;
      for (var i = 0, ii = splices.length; i < ii; ++i) {
        var splice = splices[i];
        var addIndex = spliceIndex = splice.index;
        var end = splice.index + splice.addedCount;

        if (typeof spliceIndexLow === 'undefined' || spliceIndexLow === null || spliceIndexLow > splice.index) {
          spliceIndexLow = spliceIndex;
        }

        for (; addIndex < end; ++addIndex) {
          var overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, array[addIndex], addIndex, arrayLength);
          repeat.insertView(addIndex, overrideContext.bindingContext, overrideContext);
        }
      }

      return spliceIndexLow;
    };

    return ArrayRepeatStrategy;
  }();
});
define('aurelia-templating-resources/repeat-utilities',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.updateOverrideContexts = updateOverrideContexts;
  exports.createFullOverrideContext = createFullOverrideContext;
  exports.updateOverrideContext = updateOverrideContext;
  exports.getItemsSourceExpression = getItemsSourceExpression;
  exports.unwrapExpression = unwrapExpression;
  exports.isOneTime = isOneTime;
  exports.updateOneTimeBinding = updateOneTimeBinding;
  exports.indexOf = indexOf;


  var oneTime = _aureliaBinding.bindingMode.oneTime;

  function updateOverrideContexts(views, startIndex) {
    var length = views.length;

    if (startIndex > 0) {
      startIndex = startIndex - 1;
    }

    for (; startIndex < length; ++startIndex) {
      updateOverrideContext(views[startIndex].overrideContext, startIndex, length);
    }
  }

  function createFullOverrideContext(repeat, data, index, length, key) {
    var bindingContext = {};
    var overrideContext = (0, _aureliaBinding.createOverrideContext)(bindingContext, repeat.scope.overrideContext);

    if (typeof key !== 'undefined') {
      bindingContext[repeat.key] = key;
      bindingContext[repeat.value] = data;
    } else {
      bindingContext[repeat.local] = data;
    }
    updateOverrideContext(overrideContext, index, length);
    return overrideContext;
  }

  function updateOverrideContext(overrideContext, index, length) {
    var first = index === 0;
    var last = index === length - 1;
    var even = index % 2 === 0;

    overrideContext.$index = index;
    overrideContext.$first = first;
    overrideContext.$last = last;
    overrideContext.$middle = !(first || last);
    overrideContext.$odd = !even;
    overrideContext.$even = even;
  }

  function getItemsSourceExpression(instruction, attrName) {
    return instruction.behaviorInstructions.filter(function (bi) {
      return bi.originalAttrName === attrName;
    })[0].attributes.items.sourceExpression;
  }

  function unwrapExpression(expression) {
    var unwrapped = false;
    while (expression instanceof _aureliaBinding.BindingBehavior) {
      expression = expression.expression;
    }
    while (expression instanceof _aureliaBinding.ValueConverter) {
      expression = expression.expression;
      unwrapped = true;
    }
    return unwrapped ? expression : null;
  }

  function isOneTime(expression) {
    while (expression instanceof _aureliaBinding.BindingBehavior) {
      if (expression.name === 'oneTime') {
        return true;
      }
      expression = expression.expression;
    }
    return false;
  }

  function updateOneTimeBinding(binding) {
    if (binding.call && binding.mode === oneTime) {
      binding.call(_aureliaBinding.sourceContext);
    } else if (binding.updateOneTimeBindings) {
      binding.updateOneTimeBindings();
    }
  }

  function indexOf(array, item, matcher, startIndex) {
    if (!matcher) {
      return array.indexOf(item);
    }
    var length = array.length;
    for (var index = startIndex || 0; index < length; index++) {
      if (matcher(array[index], item)) {
        return index;
      }
    }
    return -1;
  }
});
define('aurelia-templating-resources/map-repeat-strategy',['exports', './repeat-utilities'], function (exports, _repeatUtilities) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MapRepeatStrategy = undefined;

  

  var MapRepeatStrategy = exports.MapRepeatStrategy = function () {
    function MapRepeatStrategy() {
      
    }

    MapRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getMapObserver(items);
    };

    MapRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;

      var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
      if (removePromise instanceof Promise) {
        removePromise.then(function () {
          return _this._standardProcessItems(repeat, items);
        });
        return;
      }
      this._standardProcessItems(repeat, items);
    };

    MapRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
      var index = 0;
      var overrideContext = void 0;

      items.forEach(function (value, key) {
        overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size, key);
        repeat.addView(overrideContext.bindingContext, overrideContext);
        ++index;
      });
    };

    MapRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, map, records) {
      var key = void 0;
      var i = void 0;
      var ii = void 0;
      var overrideContext = void 0;
      var removeIndex = void 0;
      var addIndex = void 0;
      var record = void 0;
      var rmPromises = [];
      var viewOrPromise = void 0;

      for (i = 0, ii = records.length; i < ii; ++i) {
        record = records[i];
        key = record.key;
        switch (record.type) {
          case 'update':
            removeIndex = this._getViewIndexByKey(repeat, key);
            viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), removeIndex, map.size, key);
            repeat.insertView(removeIndex, overrideContext.bindingContext, overrideContext);
            break;
          case 'add':
            addIndex = repeat.viewCount() <= map.size - 1 ? repeat.viewCount() : map.size - 1;
            overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, map.get(key), addIndex, map.size, key);
            repeat.insertView(map.size - 1, overrideContext.bindingContext, overrideContext);
            break;
          case 'delete':
            if (record.oldValue === undefined) {
              return;
            }
            removeIndex = this._getViewIndexByKey(repeat, key);
            viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            break;
          case 'clear':
            repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
            break;
          default:
            continue;
        }
      }

      if (rmPromises.length > 0) {
        Promise.all(rmPromises).then(function () {
          (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
        });
      } else {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      }
    };

    MapRepeatStrategy.prototype._getViewIndexByKey = function _getViewIndexByKey(repeat, key) {
      var i = void 0;
      var ii = void 0;
      var child = void 0;

      for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
        child = repeat.view(i);
        if (child.bindingContext[repeat.key] === key) {
          return i;
        }
      }

      return undefined;
    };

    return MapRepeatStrategy;
  }();
});
define('aurelia-templating-resources/set-repeat-strategy',['exports', './repeat-utilities'], function (exports, _repeatUtilities) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SetRepeatStrategy = undefined;

  

  var SetRepeatStrategy = exports.SetRepeatStrategy = function () {
    function SetRepeatStrategy() {
      
    }

    SetRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getSetObserver(items);
    };

    SetRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;

      var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
      if (removePromise instanceof Promise) {
        removePromise.then(function () {
          return _this._standardProcessItems(repeat, items);
        });
        return;
      }
      this._standardProcessItems(repeat, items);
    };

    SetRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
      var index = 0;
      var overrideContext = void 0;

      items.forEach(function (value) {
        overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, index, items.size);
        repeat.addView(overrideContext.bindingContext, overrideContext);
        ++index;
      });
    };

    SetRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, set, records) {
      var value = void 0;
      var i = void 0;
      var ii = void 0;
      var overrideContext = void 0;
      var removeIndex = void 0;
      var record = void 0;
      var rmPromises = [];
      var viewOrPromise = void 0;

      for (i = 0, ii = records.length; i < ii; ++i) {
        record = records[i];
        value = record.value;
        switch (record.type) {
          case 'add':
            var size = Math.max(set.size - 1, 0);
            overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, value, size, set.size);
            repeat.insertView(size, overrideContext.bindingContext, overrideContext);
            break;
          case 'delete':
            removeIndex = this._getViewIndexByValue(repeat, value);
            viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            break;
          case 'clear':
            repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
            break;
          default:
            continue;
        }
      }

      if (rmPromises.length > 0) {
        Promise.all(rmPromises).then(function () {
          (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
        });
      } else {
        (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
      }
    };

    SetRepeatStrategy.prototype._getViewIndexByValue = function _getViewIndexByValue(repeat, value) {
      var i = void 0;
      var ii = void 0;
      var child = void 0;

      for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
        child = repeat.view(i);
        if (child.bindingContext[repeat.local] === value) {
          return i;
        }
      }

      return undefined;
    };

    return SetRepeatStrategy;
  }();
});
define('aurelia-templating-resources/number-repeat-strategy',['exports', './repeat-utilities'], function (exports, _repeatUtilities) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NumberRepeatStrategy = undefined;

  

  var NumberRepeatStrategy = exports.NumberRepeatStrategy = function () {
    function NumberRepeatStrategy() {
      
    }

    NumberRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver() {
      return null;
    };

    NumberRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, value) {
      var _this = this;

      var removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
      if (removePromise instanceof Promise) {
        removePromise.then(function () {
          return _this._standardProcessItems(repeat, value);
        });
        return;
      }
      this._standardProcessItems(repeat, value);
    };

    NumberRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, value) {
      var childrenLength = repeat.viewCount();
      var i = void 0;
      var ii = void 0;
      var overrideContext = void 0;
      var viewsToRemove = void 0;

      value = Math.floor(value);
      viewsToRemove = childrenLength - value;

      if (viewsToRemove > 0) {
        if (viewsToRemove > childrenLength) {
          viewsToRemove = childrenLength;
        }

        for (i = 0, ii = viewsToRemove; i < ii; ++i) {
          repeat.removeView(childrenLength - (i + 1), true, !repeat.viewsRequireLifecycle);
        }

        return;
      }

      for (i = childrenLength, ii = value; i < ii; ++i) {
        overrideContext = (0, _repeatUtilities.createFullOverrideContext)(repeat, i, i, ii);
        repeat.addView(overrideContext.bindingContext, overrideContext);
      }

      (0, _repeatUtilities.updateOverrideContexts)(repeat.views(), 0);
    };

    return NumberRepeatStrategy;
  }();
});
define('aurelia-templating-resources/analyze-view-factory',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.viewsRequireLifecycle = viewsRequireLifecycle;
  var lifecycleOptionalBehaviors = exports.lifecycleOptionalBehaviors = ['focus', 'if', 'repeat', 'show', 'with'];

  function behaviorRequiresLifecycle(instruction) {
    var t = instruction.type;
    var name = t.elementName !== null ? t.elementName : t.attributeName;
    return lifecycleOptionalBehaviors.indexOf(name) === -1 && (t.handlesAttached || t.handlesBind || t.handlesCreated || t.handlesDetached || t.handlesUnbind) || t.viewFactory && viewsRequireLifecycle(t.viewFactory) || instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
  }

  function targetRequiresLifecycle(instruction) {
    var behaviors = instruction.behaviorInstructions;
    if (behaviors) {
      var i = behaviors.length;
      while (i--) {
        if (behaviorRequiresLifecycle(behaviors[i])) {
          return true;
        }
      }
    }

    return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
  }

  function viewsRequireLifecycle(viewFactory) {
    if ('_viewsRequireLifecycle' in viewFactory) {
      return viewFactory._viewsRequireLifecycle;
    }

    viewFactory._viewsRequireLifecycle = false;

    if (viewFactory.viewFactory) {
      viewFactory._viewsRequireLifecycle = viewsRequireLifecycle(viewFactory.viewFactory);
      return viewFactory._viewsRequireLifecycle;
    }

    if (viewFactory.template.querySelector('.au-animate')) {
      viewFactory._viewsRequireLifecycle = true;
      return true;
    }

    for (var id in viewFactory.instructions) {
      if (targetRequiresLifecycle(viewFactory.instructions[id])) {
        viewFactory._viewsRequireLifecycle = true;
        return true;
      }
    }

    viewFactory._viewsRequireLifecycle = false;
    return false;
  }
});
define('aurelia-templating-resources/abstract-repeater',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  

  var AbstractRepeater = exports.AbstractRepeater = function () {
    function AbstractRepeater(options) {
      

      Object.assign(this, {
        local: 'items',
        viewsRequireLifecycle: true
      }, options);
    }

    AbstractRepeater.prototype.viewCount = function viewCount() {
      throw new Error('subclass must implement `viewCount`');
    };

    AbstractRepeater.prototype.views = function views() {
      throw new Error('subclass must implement `views`');
    };

    AbstractRepeater.prototype.view = function view(index) {
      throw new Error('subclass must implement `view`');
    };

    AbstractRepeater.prototype.matcher = function matcher() {
      throw new Error('subclass must implement `matcher`');
    };

    AbstractRepeater.prototype.addView = function addView(bindingContext, overrideContext) {
      throw new Error('subclass must implement `addView`');
    };

    AbstractRepeater.prototype.insertView = function insertView(index, bindingContext, overrideContext) {
      throw new Error('subclass must implement `insertView`');
    };

    AbstractRepeater.prototype.moveView = function moveView(sourceIndex, targetIndex) {
      throw new Error('subclass must implement `moveView`');
    };

    AbstractRepeater.prototype.removeAllViews = function removeAllViews(returnToCache, skipAnimation) {
      throw new Error('subclass must implement `removeAllViews`');
    };

    AbstractRepeater.prototype.removeViews = function removeViews(viewsToRemove, returnToCache, skipAnimation) {
      throw new Error('subclass must implement `removeView`');
    };

    AbstractRepeater.prototype.removeView = function removeView(index, returnToCache, skipAnimation) {
      throw new Error('subclass must implement `removeView`');
    };

    AbstractRepeater.prototype.updateBindings = function updateBindings(view) {
      throw new Error('subclass must implement `updateBindings`');
    };

    return AbstractRepeater;
  }();
});
define('aurelia-templating-resources/show',['exports', 'aurelia-dependency-injection', 'aurelia-templating', 'aurelia-pal', './aurelia-hide-style'], function (exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaPal, _aureliaHideStyle) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Show = undefined;

  

  var _dec, _dec2, _class;

  var Show = exports.Show = (_dec = (0, _aureliaTemplating.customAttribute)('show'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
    function Show(element, animator, domBoundary) {
      

      this.element = element;
      this.animator = animator;
      this.domBoundary = domBoundary;
    }

    Show.prototype.created = function created() {
      (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
    };

    Show.prototype.valueChanged = function valueChanged(newValue) {
      if (newValue) {
        this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
      } else {
        this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
      }
    };

    Show.prototype.bind = function bind(bindingContext) {
      this.valueChanged(this.value);
    };

    return Show;
  }()) || _class) || _class);
});
define('aurelia-templating-resources/aurelia-hide-style',['exports', 'aurelia-pal'], function (exports, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.aureliaHideClassName = undefined;
  exports.injectAureliaHideStyleAtHead = injectAureliaHideStyleAtHead;
  exports.injectAureliaHideStyleAtBoundary = injectAureliaHideStyleAtBoundary;
  var aureliaHideClassName = exports.aureliaHideClassName = 'aurelia-hide';

  var aureliaHideClass = '.' + aureliaHideClassName + ' { display:none !important; }';

  function injectAureliaHideStyleAtHead() {
    _aureliaPal.DOM.injectStyles(aureliaHideClass);
  }

  function injectAureliaHideStyleAtBoundary(domBoundary) {
    if (_aureliaPal.FEATURE.shadowDOM && domBoundary && !domBoundary.hasAureliaHideStyle) {
      domBoundary.hasAureliaHideStyle = true;
      _aureliaPal.DOM.injectStyles(aureliaHideClass, domBoundary);
    }
  }
});
define('aurelia-templating-resources/hide',['exports', 'aurelia-dependency-injection', 'aurelia-templating', 'aurelia-pal', './aurelia-hide-style'], function (exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaPal, _aureliaHideStyle) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Hide = undefined;

  

  var _dec, _dec2, _class;

  var Hide = exports.Hide = (_dec = (0, _aureliaTemplating.customAttribute)('hide'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTemplating.Animator, _aureliaDependencyInjection.Optional.of(_aureliaPal.DOM.boundary, true)), _dec(_class = _dec2(_class = function () {
    function Hide(element, animator, domBoundary) {
      

      this.element = element;
      this.animator = animator;
      this.domBoundary = domBoundary;
    }

    Hide.prototype.created = function created() {
      (0, _aureliaHideStyle.injectAureliaHideStyleAtBoundary)(this.domBoundary);
    };

    Hide.prototype.valueChanged = function valueChanged(newValue) {
      if (newValue) {
        this.animator.addClass(this.element, _aureliaHideStyle.aureliaHideClassName);
      } else {
        this.animator.removeClass(this.element, _aureliaHideStyle.aureliaHideClassName);
      }
    };

    Hide.prototype.bind = function bind(bindingContext) {
      this.valueChanged(this.value);
    };

    return Hide;
  }()) || _class) || _class);
});
define('aurelia-templating-resources/sanitize-html',['exports', 'aurelia-binding', 'aurelia-dependency-injection', './html-sanitizer'], function (exports, _aureliaBinding, _aureliaDependencyInjection, _htmlSanitizer) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SanitizeHTMLValueConverter = undefined;

  

  var _dec, _dec2, _class;

  var SanitizeHTMLValueConverter = exports.SanitizeHTMLValueConverter = (_dec = (0, _aureliaBinding.valueConverter)('sanitizeHTML'), _dec2 = (0, _aureliaDependencyInjection.inject)(_htmlSanitizer.HTMLSanitizer), _dec(_class = _dec2(_class = function () {
    function SanitizeHTMLValueConverter(sanitizer) {
      

      this.sanitizer = sanitizer;
    }

    SanitizeHTMLValueConverter.prototype.toView = function toView(untrustedMarkup) {
      if (untrustedMarkup === null || untrustedMarkup === undefined) {
        return null;
      }

      return this.sanitizer.sanitize(untrustedMarkup);
    };

    return SanitizeHTMLValueConverter;
  }()) || _class) || _class);
});
define('aurelia-templating-resources/html-sanitizer',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  

  var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

  var HTMLSanitizer = exports.HTMLSanitizer = function () {
    function HTMLSanitizer() {
      
    }

    HTMLSanitizer.prototype.sanitize = function sanitize(input) {
      return input.replace(SCRIPT_REGEX, '');
    };

    return HTMLSanitizer;
  }();
});
define('aurelia-templating-resources/replaceable',['exports', 'aurelia-dependency-injection', 'aurelia-templating'], function (exports, _aureliaDependencyInjection, _aureliaTemplating) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Replaceable = undefined;

  

  var _dec, _dec2, _class;

  var Replaceable = exports.Replaceable = (_dec = (0, _aureliaTemplating.customAttribute)('replaceable'), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot), _dec(_class = (0, _aureliaTemplating.templateController)(_class = _dec2(_class = function () {
    function Replaceable(viewFactory, viewSlot) {
      

      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.view = null;
    }

    Replaceable.prototype.bind = function bind(bindingContext, overrideContext) {
      if (this.view === null) {
        this.view = this.viewFactory.create();
        this.viewSlot.add(this.view);
      }

      this.view.bind(bindingContext, overrideContext);
    };

    Replaceable.prototype.unbind = function unbind() {
      this.view.unbind();
    };

    return Replaceable;
  }()) || _class) || _class) || _class);
});
define('aurelia-templating-resources/focus',['exports', 'aurelia-templating', 'aurelia-binding', 'aurelia-dependency-injection', 'aurelia-task-queue', 'aurelia-pal'], function (exports, _aureliaTemplating, _aureliaBinding, _aureliaDependencyInjection, _aureliaTaskQueue, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Focus = undefined;

  

  var _dec, _dec2, _class;

  var Focus = exports.Focus = (_dec = (0, _aureliaTemplating.customAttribute)('focus', _aureliaBinding.bindingMode.twoWay), _dec2 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element, _aureliaTaskQueue.TaskQueue), _dec(_class = _dec2(_class = function () {
    function Focus(element, taskQueue) {
      

      this.element = element;
      this.taskQueue = taskQueue;
      this.isAttached = false;
      this.needsApply = false;
    }

    Focus.prototype.valueChanged = function valueChanged(newValue) {
      if (this.isAttached) {
        this._apply();
      } else {
        this.needsApply = true;
      }
    };

    Focus.prototype._apply = function _apply() {
      var _this = this;

      if (this.value) {
        this.taskQueue.queueMicroTask(function () {
          if (_this.value) {
            _this.element.focus();
          }
        });
      } else {
        this.element.blur();
      }
    };

    Focus.prototype.attached = function attached() {
      this.isAttached = true;
      if (this.needsApply) {
        this.needsApply = false;
        this._apply();
      }
      this.element.addEventListener('focus', this);
      this.element.addEventListener('blur', this);
    };

    Focus.prototype.detached = function detached() {
      this.isAttached = false;
      this.element.removeEventListener('focus', this);
      this.element.removeEventListener('blur', this);
    };

    Focus.prototype.handleEvent = function handleEvent(e) {
      if (e.type === 'focus') {
        this.value = true;
      } else if (_aureliaPal.DOM.activeElement !== this.element) {
        this.value = false;
      }
    };

    return Focus;
  }()) || _class) || _class);
});
define('aurelia-templating-resources/css-resource',['exports', 'aurelia-templating', 'aurelia-loader', 'aurelia-dependency-injection', 'aurelia-path', 'aurelia-pal'], function (exports, _aureliaTemplating, _aureliaLoader, _aureliaDependencyInjection, _aureliaPath, _aureliaPal) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._createCSSResource = _createCSSResource;

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  

  var cssUrlMatcher = /url\((?!['"]data)([^)]+)\)/gi;

  function fixupCSSUrls(address, css) {
    if (typeof css !== 'string') {
      throw new Error('Failed loading required CSS file: ' + address);
    }
    return css.replace(cssUrlMatcher, function (match, p1) {
      var quote = p1.charAt(0);
      if (quote === '\'' || quote === '"') {
        p1 = p1.substr(1, p1.length - 2);
      }
      return 'url(\'' + (0, _aureliaPath.relativeToFile)(p1, address) + '\')';
    });
  }

  var CSSResource = function () {
    function CSSResource(address) {
      

      this.address = address;
      this._scoped = null;
      this._global = false;
      this._alreadyGloballyInjected = false;
    }

    CSSResource.prototype.initialize = function initialize(container, target) {
      this._scoped = new target(this);
    };

    CSSResource.prototype.register = function register(registry, name) {
      if (name === 'scoped') {
        registry.registerViewEngineHooks(this._scoped);
      } else {
        this._global = true;
      }
    };

    CSSResource.prototype.load = function load(container) {
      var _this = this;

      return container.get(_aureliaLoader.Loader).loadText(this.address).catch(function (err) {
        return null;
      }).then(function (text) {
        text = fixupCSSUrls(_this.address, text);
        _this._scoped.css = text;
        if (_this._global) {
          _this._alreadyGloballyInjected = true;
          _aureliaPal.DOM.injectStyles(text);
        }
      });
    };

    return CSSResource;
  }();

  var CSSViewEngineHooks = function () {
    function CSSViewEngineHooks(owner) {
      

      this.owner = owner;
      this.css = null;
    }

    CSSViewEngineHooks.prototype.beforeCompile = function beforeCompile(content, resources, instruction) {
      if (instruction.targetShadowDOM) {
        _aureliaPal.DOM.injectStyles(this.css, content, true);
      } else if (_aureliaPal.FEATURE.scopedCSS) {
        var styleNode = _aureliaPal.DOM.injectStyles(this.css, content, true);
        styleNode.setAttribute('scoped', 'scoped');
      } else if (this._global && !this.owner._alreadyGloballyInjected) {
        _aureliaPal.DOM.injectStyles(this.css);
        this.owner._alreadyGloballyInjected = true;
      }
    };

    return CSSViewEngineHooks;
  }();

  function _createCSSResource(address) {
    var _dec, _class;

    var ViewCSS = (_dec = (0, _aureliaTemplating.resource)(new CSSResource(address)), _dec(_class = function (_CSSViewEngineHooks) {
      _inherits(ViewCSS, _CSSViewEngineHooks);

      function ViewCSS() {
        

        return _possibleConstructorReturn(this, _CSSViewEngineHooks.apply(this, arguments));
      }

      return ViewCSS;
    }(CSSViewEngineHooks)) || _class);

    return ViewCSS;
  }
});
define('aurelia-templating-resources/attr-binding-behavior',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AttrBindingBehavior = undefined;

  

  var AttrBindingBehavior = exports.AttrBindingBehavior = function () {
    function AttrBindingBehavior() {
      
    }

    AttrBindingBehavior.prototype.bind = function bind(binding, source) {
      binding.targetObserver = new _aureliaBinding.DataAttributeObserver(binding.target, binding.targetProperty);
    };

    AttrBindingBehavior.prototype.unbind = function unbind(binding, source) {};

    return AttrBindingBehavior;
  }();
});
define('aurelia-templating-resources/binding-mode-behaviors',['exports', 'aurelia-binding', 'aurelia-metadata'], function (exports, _aureliaBinding, _aureliaMetadata) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = undefined;

  

  var _dec, _class, _dec2, _class2, _dec3, _class3;

  var modeBindingBehavior = {
    bind: function bind(binding, source, lookupFunctions) {
      binding.originalMode = binding.mode;
      binding.mode = this.mode;
    },
    unbind: function unbind(binding, source) {
      binding.mode = binding.originalMode;
      binding.originalMode = null;
    }
  };

  var OneTimeBindingBehavior = exports.OneTimeBindingBehavior = (_dec = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec(_class = function OneTimeBindingBehavior() {
    

    this.mode = _aureliaBinding.bindingMode.oneTime;
  }) || _class);
  var OneWayBindingBehavior = exports.OneWayBindingBehavior = (_dec2 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec2(_class2 = function OneWayBindingBehavior() {
    

    this.mode = _aureliaBinding.bindingMode.oneWay;
  }) || _class2);
  var TwoWayBindingBehavior = exports.TwoWayBindingBehavior = (_dec3 = (0, _aureliaMetadata.mixin)(modeBindingBehavior), _dec3(_class3 = function TwoWayBindingBehavior() {
    

    this.mode = _aureliaBinding.bindingMode.twoWay;
  }) || _class3);
});
define('aurelia-templating-resources/throttle-binding-behavior',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ThrottleBindingBehavior = undefined;

  

  function throttle(newValue) {
    var _this = this;

    var state = this.throttleState;
    var elapsed = +new Date() - state.last;
    if (elapsed >= state.delay) {
      clearTimeout(state.timeoutId);
      state.timeoutId = null;
      state.last = +new Date();
      this.throttledMethod(newValue);
      return;
    }
    state.newValue = newValue;
    if (state.timeoutId === null) {
      state.timeoutId = setTimeout(function () {
        state.timeoutId = null;
        state.last = +new Date();
        _this.throttledMethod(state.newValue);
      }, state.delay - elapsed);
    }
  }

  var ThrottleBindingBehavior = exports.ThrottleBindingBehavior = function () {
    function ThrottleBindingBehavior() {
      
    }

    ThrottleBindingBehavior.prototype.bind = function bind(binding, source) {
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var methodToThrottle = 'updateTarget';
      if (binding.callSource) {
        methodToThrottle = 'callSource';
      } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
        methodToThrottle = 'updateSource';
      }

      binding.throttledMethod = binding[methodToThrottle];
      binding.throttledMethod.originalName = methodToThrottle;

      binding[methodToThrottle] = throttle;

      binding.throttleState = {
        delay: delay,
        last: 0,
        timeoutId: null
      };
    };

    ThrottleBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var methodToRestore = binding.throttledMethod.originalName;
      binding[methodToRestore] = binding.throttledMethod;
      binding.throttledMethod = null;
      clearTimeout(binding.throttleState.timeoutId);
      binding.throttleState = null;
    };

    return ThrottleBindingBehavior;
  }();
});
define('aurelia-templating-resources/debounce-binding-behavior',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DebounceBindingBehavior = undefined;

  

  function debounce(newValue) {
    var _this = this;

    var state = this.debounceState;
    if (state.immediate) {
      state.immediate = false;
      this.debouncedMethod(newValue);
      return;
    }
    clearTimeout(state.timeoutId);
    state.timeoutId = setTimeout(function () {
      return _this.debouncedMethod(newValue);
    }, state.delay);
  }

  var DebounceBindingBehavior = exports.DebounceBindingBehavior = function () {
    function DebounceBindingBehavior() {
      
    }

    DebounceBindingBehavior.prototype.bind = function bind(binding, source) {
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var methodToDebounce = 'updateTarget';
      if (binding.callSource) {
        methodToDebounce = 'callSource';
      } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
        methodToDebounce = 'updateSource';
      }

      binding.debouncedMethod = binding[methodToDebounce];
      binding.debouncedMethod.originalName = methodToDebounce;

      binding[methodToDebounce] = debounce;

      binding.debounceState = {
        delay: delay,
        timeoutId: null,
        immediate: methodToDebounce === 'updateTarget' };
    };

    DebounceBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var methodToRestore = binding.debouncedMethod.originalName;
      binding[methodToRestore] = binding.debouncedMethod;
      binding.debouncedMethod = null;
      clearTimeout(binding.debounceState.timeoutId);
      binding.debounceState = null;
    };

    return DebounceBindingBehavior;
  }();
});
define('aurelia-templating-resources/self-binding-behavior',['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  

  function findOriginalEventTarget(event) {
    return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
  }

  function handleSelfEvent(event) {
    var target = findOriginalEventTarget(event);
    if (this.target !== target) return;
    this.selfEventCallSource(event);
  }

  var SelfBindingBehavior = exports.SelfBindingBehavior = function () {
    function SelfBindingBehavior() {
      
    }

    SelfBindingBehavior.prototype.bind = function bind(binding, source) {
      if (!binding.callSource || !binding.targetEvent) throw new Error('Self binding behavior only supports event.');
      binding.selfEventCallSource = binding.callSource;
      binding.callSource = handleSelfEvent;
    };

    SelfBindingBehavior.prototype.unbind = function unbind(binding, source) {
      binding.callSource = binding.selfEventCallSource;
      binding.selfEventCallSource = null;
    };

    return SelfBindingBehavior;
  }();
});
define('aurelia-templating-resources/signal-binding-behavior',['exports', './binding-signaler'], function (exports, _bindingSignaler) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SignalBindingBehavior = undefined;

  

  var SignalBindingBehavior = exports.SignalBindingBehavior = function () {
    SignalBindingBehavior.inject = function inject() {
      return [_bindingSignaler.BindingSignaler];
    };

    function SignalBindingBehavior(bindingSignaler) {
      

      this.signals = bindingSignaler.signals;
    }

    SignalBindingBehavior.prototype.bind = function bind(binding, source) {
      if (!binding.updateTarget) {
        throw new Error('Only property bindings and string interpolation bindings can be signaled.  Trigger, delegate and call bindings cannot be signaled.');
      }
      if (arguments.length === 3) {
        var name = arguments[2];
        var bindings = this.signals[name] || (this.signals[name] = []);
        bindings.push(binding);
        binding.signalName = name;
      } else if (arguments.length > 3) {
        var names = Array.prototype.slice.call(arguments, 2);
        var i = names.length;
        while (i--) {
          var _name = names[i];
          var _bindings = this.signals[_name] || (this.signals[_name] = []);
          _bindings.push(binding);
        }
        binding.signalName = names;
      } else {
        throw new Error('Signal name is required.');
      }
    };

    SignalBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var name = binding.signalName;
      binding.signalName = null;
      if (Array.isArray(name)) {
        var names = name;
        var i = names.length;
        while (i--) {
          var n = names[i];
          var bindings = this.signals[n];
          bindings.splice(bindings.indexOf(binding), 1);
        }
      } else {
        var _bindings2 = this.signals[name];
        _bindings2.splice(_bindings2.indexOf(binding), 1);
      }
    };

    return SignalBindingBehavior;
  }();
});
define('aurelia-templating-resources/binding-signaler',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BindingSignaler = undefined;

  

  var BindingSignaler = exports.BindingSignaler = function () {
    function BindingSignaler() {
      

      this.signals = {};
    }

    BindingSignaler.prototype.signal = function signal(name) {
      var bindings = this.signals[name];
      if (!bindings) {
        return;
      }
      var i = bindings.length;
      while (i--) {
        bindings[i].call(_aureliaBinding.sourceContext);
      }
    };

    return BindingSignaler;
  }();
});
define('aurelia-templating-resources/update-trigger-binding-behavior',['exports', 'aurelia-binding'], function (exports, _aureliaBinding) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UpdateTriggerBindingBehavior = undefined;

  

  var _class, _temp;

  var eventNamesRequired = 'The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">';
  var notApplicableMessage = 'The updateTrigger binding behavior can only be applied to two-way bindings on input/select elements.';

  var UpdateTriggerBindingBehavior = exports.UpdateTriggerBindingBehavior = (_temp = _class = function () {
    function UpdateTriggerBindingBehavior(eventManager) {
      

      this.eventManager = eventManager;
    }

    UpdateTriggerBindingBehavior.prototype.bind = function bind(binding, source) {
      for (var _len = arguments.length, events = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        events[_key - 2] = arguments[_key];
      }

      if (events.length === 0) {
        throw new Error(eventNamesRequired);
      }
      if (binding.mode !== _aureliaBinding.bindingMode.twoWay) {
        throw new Error(notApplicableMessage);
      }

      var targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);
      if (!targetObserver.handler) {
        throw new Error(notApplicableMessage);
      }
      binding.targetObserver = targetObserver;

      targetObserver.originalHandler = binding.targetObserver.handler;

      var handler = this.eventManager.createElementHandler(events);
      targetObserver.handler = handler;
    };

    UpdateTriggerBindingBehavior.prototype.unbind = function unbind(binding, source) {
      binding.targetObserver.handler = binding.targetObserver.originalHandler;
      binding.targetObserver.originalHandler = null;
    };

    return UpdateTriggerBindingBehavior;
  }(), _class.inject = [_aureliaBinding.EventManager], _temp);
});
define('aurelia-templating-resources/html-resource-plugin',['exports', 'aurelia-templating', './dynamic-element'], function (exports, _aureliaTemplating, _dynamicElement) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getElementName = getElementName;
  exports.configure = configure;
  function getElementName(address) {
    return (/([^\/^\?]+)\.html/i.exec(address)[1].toLowerCase()
    );
  }

  function configure(config) {
    var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
    var loader = config.aurelia.loader;

    viewEngine.addResourcePlugin('.html', {
      'fetch': function fetch(address) {
        return loader.loadTemplate(address).then(function (registryEntry) {
          var _ref;

          var bindable = registryEntry.template.getAttribute('bindable');
          var elementName = getElementName(address);

          if (bindable) {
            bindable = bindable.split(',').map(function (x) {
              return x.trim();
            });
            registryEntry.template.removeAttribute('bindable');
          } else {
            bindable = [];
          }

          return _ref = {}, _ref[elementName] = (0, _dynamicElement._createDynamicElement)(elementName, address, bindable), _ref;
        });
      }
    });
  }
});
define('aurelia-templating-resources/dynamic-element',['exports', 'aurelia-templating'], function (exports, _aureliaTemplating) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._createDynamicElement = _createDynamicElement;

  

  function _createDynamicElement(name, viewUrl, bindableNames) {
    var _dec, _dec2, _class;

    var DynamicElement = (_dec = (0, _aureliaTemplating.customElement)(name), _dec2 = (0, _aureliaTemplating.useView)(viewUrl), _dec(_class = _dec2(_class = function () {
      function DynamicElement() {
        
      }

      DynamicElement.prototype.bind = function bind(bindingContext) {
        this.$parent = bindingContext;
      };

      return DynamicElement;
    }()) || _class) || _class);

    for (var i = 0, ii = bindableNames.length; i < ii; ++i) {
      (0, _aureliaTemplating.bindable)(bindableNames[i])(DynamicElement);
    }
    return DynamicElement;
  }
});
define('aurelia-templating-binding',['exports', 'aurelia-logging', 'aurelia-binding', 'aurelia-templating'], function (exports, _aureliaLogging, _aureliaBinding, _aureliaTemplating) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TemplatingBindingLanguage = exports.SyntaxInterpreter = exports.ChildInterpolationBinding = exports.InterpolationBinding = exports.InterpolationBindingExpression = exports.AttributeMap = undefined;
  exports.configure = configure;

  var LogManager = _interopRequireWildcard(_aureliaLogging);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  

  var _class, _temp, _dec, _class2, _class3, _temp2, _class4, _temp3;

  var AttributeMap = exports.AttributeMap = (_temp = _class = function () {
    function AttributeMap(svg) {
      

      this.elements = Object.create(null);
      this.allElements = Object.create(null);

      this.svg = svg;

      this.registerUniversal('accesskey', 'accessKey');
      this.registerUniversal('contenteditable', 'contentEditable');
      this.registerUniversal('tabindex', 'tabIndex');
      this.registerUniversal('textcontent', 'textContent');
      this.registerUniversal('innerhtml', 'innerHTML');
      this.registerUniversal('scrolltop', 'scrollTop');
      this.registerUniversal('scrollleft', 'scrollLeft');
      this.registerUniversal('readonly', 'readOnly');

      this.register('label', 'for', 'htmlFor');

      this.register('img', 'usemap', 'useMap');

      this.register('input', 'maxlength', 'maxLength');
      this.register('input', 'minlength', 'minLength');
      this.register('input', 'formaction', 'formAction');
      this.register('input', 'formenctype', 'formEncType');
      this.register('input', 'formmethod', 'formMethod');
      this.register('input', 'formnovalidate', 'formNoValidate');
      this.register('input', 'formtarget', 'formTarget');

      this.register('textarea', 'maxlength', 'maxLength');

      this.register('td', 'rowspan', 'rowSpan');
      this.register('td', 'colspan', 'colSpan');
      this.register('th', 'rowspan', 'rowSpan');
      this.register('th', 'colspan', 'colSpan');
    }

    AttributeMap.prototype.register = function register(elementName, attributeName, propertyName) {
      elementName = elementName.toLowerCase();
      attributeName = attributeName.toLowerCase();
      var element = this.elements[elementName] = this.elements[elementName] || Object.create(null);
      element[attributeName] = propertyName;
    };

    AttributeMap.prototype.registerUniversal = function registerUniversal(attributeName, propertyName) {
      attributeName = attributeName.toLowerCase();
      this.allElements[attributeName] = propertyName;
    };

    AttributeMap.prototype.map = function map(elementName, attributeName) {
      if (this.svg.isStandardSvgAttribute(elementName, attributeName)) {
        return attributeName;
      }
      elementName = elementName.toLowerCase();
      attributeName = attributeName.toLowerCase();
      var element = this.elements[elementName];
      if (element !== undefined && attributeName in element) {
        return element[attributeName];
      }
      if (attributeName in this.allElements) {
        return this.allElements[attributeName];
      }

      if (/(?:^data-)|(?:^aria-)|:/.test(attributeName)) {
        return attributeName;
      }
      return (0, _aureliaBinding.camelCase)(attributeName);
    };

    return AttributeMap;
  }(), _class.inject = [_aureliaBinding.SVGAnalyzer], _temp);

  var InterpolationBindingExpression = exports.InterpolationBindingExpression = function () {
    function InterpolationBindingExpression(observerLocator, targetProperty, parts, mode, lookupFunctions, attribute) {
      

      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.parts = parts;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.attribute = this.attrToRemove = attribute;
      this.discrete = false;
    }

    InterpolationBindingExpression.prototype.createBinding = function createBinding(target) {
      if (this.parts.length === 3) {
        return new ChildInterpolationBinding(target, this.observerLocator, this.parts[1], this.mode, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
      }
      return new InterpolationBinding(this.observerLocator, this.parts, target, this.targetProperty, this.mode, this.lookupFunctions);
    };

    return InterpolationBindingExpression;
  }();

  function validateTarget(target, propertyName) {
    if (propertyName === 'style') {
      LogManager.getLogger('templating-binding').info('Internet Explorer does not support interpolation in "style" attributes.  Use the style attribute\'s alias, "css" instead.');
    } else if (target.parentElement && target.parentElement.nodeName === 'TEXTAREA' && propertyName === 'textContent') {
      throw new Error('Interpolation binding cannot be used in the content of a textarea element.  Use <textarea value.bind="expression"></textarea> instead.');
    }
  }

  var InterpolationBinding = exports.InterpolationBinding = function () {
    function InterpolationBinding(observerLocator, parts, target, targetProperty, mode, lookupFunctions) {
      

      validateTarget(target, targetProperty);
      this.observerLocator = observerLocator;
      this.parts = parts;
      this.target = target;
      this.targetProperty = targetProperty;
      this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
    }

    InterpolationBinding.prototype.interpolate = function interpolate() {
      if (this.isBound) {
        var value = '';
        var parts = this.parts;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          value += i % 2 === 0 ? parts[i] : this['childBinding' + i].value;
        }
        this.targetAccessor.setValue(value, this.target, this.targetProperty);
      }
    };

    InterpolationBinding.prototype.updateOneTimeBindings = function updateOneTimeBindings() {
      for (var i = 1, ii = this.parts.length; i < ii; i += 2) {
        var child = this['childBinding' + i];
        if (child.mode === _aureliaBinding.bindingMode.oneTime) {
          child.call();
        }
      }
    };

    InterpolationBinding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.source = source;

      var parts = this.parts;
      for (var i = 1, ii = parts.length; i < ii; i += 2) {
        var binding = new ChildInterpolationBinding(this, this.observerLocator, parts[i], this.mode, this.lookupFunctions);
        binding.bind(source);
        this['childBinding' + i] = binding;
      }

      this.isBound = true;
      this.interpolate();
    };

    InterpolationBinding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      this.source = null;
      var parts = this.parts;
      for (var i = 1, ii = parts.length; i < ii; i += 2) {
        var name = 'childBinding' + i;
        this[name].unbind();
      }
    };

    return InterpolationBinding;
  }();

  var ChildInterpolationBinding = exports.ChildInterpolationBinding = (_dec = (0, _aureliaBinding.connectable)(), _dec(_class2 = function () {
    function ChildInterpolationBinding(target, observerLocator, sourceExpression, mode, lookupFunctions, targetProperty, left, right) {
      

      if (target instanceof InterpolationBinding) {
        this.parent = target;
      } else {
        validateTarget(target, targetProperty);
        this.target = target;
        this.targetProperty = targetProperty;
        this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
      }
      this.observerLocator = observerLocator;
      this.sourceExpression = sourceExpression;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.left = left;
      this.right = right;
    }

    ChildInterpolationBinding.prototype.updateTarget = function updateTarget(value) {
      value = value === null || value === undefined ? '' : value.toString();
      if (value !== this.value) {
        this.value = value;
        if (this.parent) {
          this.parent.interpolate();
        } else {
          this.targetAccessor.setValue(this.left + value + this.right, this.target, this.targetProperty);
        }
      }
    };

    ChildInterpolationBinding.prototype.call = function call() {
      if (!this.isBound) {
        return;
      }

      this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(this.rawValue);

      if (this.mode !== _aureliaBinding.bindingMode.oneTime) {
        this._version++;
        this.sourceExpression.connect(this, this.source);
        if (this.rawValue instanceof Array) {
          this.observeArray(this.rawValue);
        }
        this.unobserve(false);
      }
    };

    ChildInterpolationBinding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;

      var sourceExpression = this.sourceExpression;
      if (sourceExpression.bind) {
        sourceExpression.bind(this, source, this.lookupFunctions);
      }

      this.rawValue = sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(this.rawValue);

      if (this.mode === _aureliaBinding.bindingMode.oneWay) {
        (0, _aureliaBinding.enqueueBindingConnect)(this);
      }
    };

    ChildInterpolationBinding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.unbind) {
        sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this.value = null;
      this.rawValue = null;
      this.unobserve(true);
    };

    ChildInterpolationBinding.prototype.connect = function connect(evaluate) {
      if (!this.isBound) {
        return;
      }
      if (evaluate) {
        this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.updateTarget(this.rawValue);
      }
      this.sourceExpression.connect(this, this.source);
      if (this.rawValue instanceof Array) {
        this.observeArray(this.rawValue);
      }
    };

    return ChildInterpolationBinding;
  }()) || _class2);
  var SyntaxInterpreter = exports.SyntaxInterpreter = (_temp2 = _class3 = function () {
    function SyntaxInterpreter(parser, observerLocator, eventManager, attributeMap) {
      

      this.parser = parser;
      this.observerLocator = observerLocator;
      this.eventManager = eventManager;
      this.attributeMap = attributeMap;
    }

    SyntaxInterpreter.prototype.interpret = function interpret(resources, element, info, existingInstruction, context) {
      if (info.command in this) {
        return this[info.command](resources, element, info, existingInstruction, context);
      }

      return this.handleUnknownCommand(resources, element, info, existingInstruction, context);
    };

    SyntaxInterpreter.prototype.handleUnknownCommand = function handleUnknownCommand(resources, element, info, existingInstruction, context) {
      LogManager.getLogger('templating-binding').warn('Unknown binding command.', info);
      return existingInstruction;
    };

    SyntaxInterpreter.prototype.determineDefaultBindingMode = function determineDefaultBindingMode(element, attrName, context) {
      var tagName = element.tagName.toLowerCase();

      if (tagName === 'input' && (attrName === 'value' || attrName === 'files') && element.type !== 'checkbox' && element.type !== 'radio' || tagName === 'input' && attrName === 'checked' && (element.type === 'checkbox' || element.type === 'radio') || (tagName === 'textarea' || tagName === 'select') && attrName === 'value' || (attrName === 'textcontent' || attrName === 'innerhtml') && element.contentEditable === 'true' || attrName === 'scrolltop' || attrName === 'scrollleft') {
        return _aureliaBinding.bindingMode.twoWay;
      }

      if (context && attrName in context.attributes && context.attributes[attrName] && context.attributes[attrName].defaultBindingMode >= _aureliaBinding.bindingMode.oneTime) {
        return context.attributes[attrName].defaultBindingMode;
      }

      return _aureliaBinding.bindingMode.oneWay;
    };

    SyntaxInterpreter.prototype.bind = function bind(resources, element, info, existingInstruction, context) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), info.defaultBindingMode === undefined || info.defaultBindingMode === null ? this.determineDefaultBindingMode(element, info.attrName, context) : info.defaultBindingMode, resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype.trigger = function trigger(resources, element, info) {
      return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.none, true, resources.lookupFunctions);
    };

    SyntaxInterpreter.prototype.capture = function capture(resources, element, info) {
      return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.capturing, true, resources.lookupFunctions);
    };

    SyntaxInterpreter.prototype.delegate = function delegate(resources, element, info) {
      return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.delegationStrategy.bubbling, true, resources.lookupFunctions);
    };

    SyntaxInterpreter.prototype.call = function call(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.CallExpression(this.observerLocator, info.attrName, this.parser.parse(info.attrValue), resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype.options = function options(resources, element, info, existingInstruction, context) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      var attrValue = info.attrValue;
      var language = this.language;
      var name = null;
      var target = '';
      var current = void 0;
      var i = void 0;
      var ii = void 0;
      var inString = false;
      var inEscape = false;
      var foundName = false;

      for (i = 0, ii = attrValue.length; i < ii; ++i) {
        current = attrValue[i];

        if (current === ';' && !inString) {
          if (!foundName) {
            name = this._getPrimaryPropertyName(resources, context);
          }
          info = language.inspectAttribute(resources, '?', name, target.trim());
          language.createAttributeInstruction(resources, element, info, instruction, context);

          if (!instruction.attributes[info.attrName]) {
            instruction.attributes[info.attrName] = info.attrValue;
          }

          target = '';
          name = null;
        } else if (current === ':' && name === null) {
          foundName = true;
          name = target.trim();
          target = '';
        } else if (current === '\\') {
          target += current;
          inEscape = true;
          continue;
        } else {
          target += current;

          if (name !== null && inEscape === false && current === '\'') {
            inString = !inString;
          }
        }

        inEscape = false;
      }

      if (!foundName) {
        name = this._getPrimaryPropertyName(resources, context);
      }

      if (name !== null) {
        info = language.inspectAttribute(resources, '?', name, target.trim());
        language.createAttributeInstruction(resources, element, info, instruction, context);

        if (!instruction.attributes[info.attrName]) {
          instruction.attributes[info.attrName] = info.attrValue;
        }
      }

      return instruction;
    };

    SyntaxInterpreter.prototype._getPrimaryPropertyName = function _getPrimaryPropertyName(resources, context) {
      var type = resources.getAttribute(context.attributeName);
      if (type && type.primaryProperty) {
        return type.primaryProperty.name;
      }
      return null;
    };

    SyntaxInterpreter.prototype['for'] = function _for(resources, element, info, existingInstruction) {
      var parts = void 0;
      var keyValue = void 0;
      var instruction = void 0;
      var attrValue = void 0;
      var isDestructuring = void 0;

      attrValue = info.attrValue;
      isDestructuring = attrValue.match(/^ *[[].+[\]]/);
      parts = isDestructuring ? attrValue.split('of ') : attrValue.split(' of ');

      if (parts.length !== 2) {
        throw new Error('Incorrect syntax for "for". The form is: "$local of $items" or "[$key, $value] of $items".');
      }

      instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      if (isDestructuring) {
        keyValue = parts[0].replace(/[[\]]/g, '').replace(/,/g, ' ').replace(/\s+/g, ' ').trim().split(' ');
        instruction.attributes.key = keyValue[0];
        instruction.attributes.value = keyValue[1];
      } else {
        instruction.attributes.local = parts[0];
      }

      instruction.attributes.items = new _aureliaBinding.BindingExpression(this.observerLocator, 'items', this.parser.parse(parts[1]), _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype['two-way'] = function twoWay(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.twoWay, resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype['to-view'] = function toView(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.toView, resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype['from-view'] = function fromView(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.fromView, resources.lookupFunctions);

      return instruction;
    };

    SyntaxInterpreter.prototype['one-time'] = function oneTime(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);

      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.oneTime, resources.lookupFunctions);

      return instruction;
    };

    return SyntaxInterpreter;
  }(), _class3.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, _aureliaBinding.EventManager, AttributeMap], _temp2);


  SyntaxInterpreter.prototype['one-way'] = SyntaxInterpreter.prototype['to-view'];

  var info = {};

  var TemplatingBindingLanguage = exports.TemplatingBindingLanguage = (_temp3 = _class4 = function (_BindingLanguage) {
    _inherits(TemplatingBindingLanguage, _BindingLanguage);

    function TemplatingBindingLanguage(parser, observerLocator, syntaxInterpreter, attributeMap) {
      

      var _this = _possibleConstructorReturn(this, _BindingLanguage.call(this));

      _this.parser = parser;
      _this.observerLocator = observerLocator;
      _this.syntaxInterpreter = syntaxInterpreter;
      _this.emptyStringExpression = _this.parser.parse('\'\'');
      syntaxInterpreter.language = _this;
      _this.attributeMap = attributeMap;
      return _this;
    }

    TemplatingBindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
      var parts = attrName.split('.');

      info.defaultBindingMode = null;

      if (parts.length === 2) {
        info.attrName = parts[0].trim();
        info.attrValue = attrValue;
        info.command = parts[1].trim();

        if (info.command === 'ref') {
          info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), info.attrName, resources.lookupFunctions);
          info.command = null;
          info.attrName = 'ref';
        } else {
          info.expression = null;
        }
      } else if (attrName === 'ref') {
        info.attrName = attrName;
        info.attrValue = attrValue;
        info.command = null;
        info.expression = new _aureliaBinding.NameExpression(this.parser.parse(attrValue), 'element', resources.lookupFunctions);
      } else {
        info.attrName = attrName;
        info.attrValue = attrValue;
        info.command = null;
        var interpolationParts = this.parseInterpolation(resources, attrValue);
        if (interpolationParts === null) {
          info.expression = null;
        } else {
          info.expression = new InterpolationBindingExpression(this.observerLocator, this.attributeMap.map(elementName, attrName), interpolationParts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, attrName);
        }
      }

      return info;
    };

    TemplatingBindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, theInfo, existingInstruction, context) {
      var instruction = void 0;

      if (theInfo.expression) {
        if (theInfo.attrName === 'ref') {
          return theInfo.expression;
        }

        instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(theInfo.attrName);
        instruction.attributes[theInfo.attrName] = theInfo.expression;
      } else if (theInfo.command) {
        instruction = this.syntaxInterpreter.interpret(resources, element, theInfo, existingInstruction, context);
      }

      return instruction;
    };

    TemplatingBindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
      var parts = this.parseInterpolation(resources, value);
      if (parts === null) {
        return null;
      }
      return new InterpolationBindingExpression(this.observerLocator, 'textContent', parts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, 'textContent');
    };

    TemplatingBindingLanguage.prototype.parseInterpolation = function parseInterpolation(resources, value) {
      var i = value.indexOf('${', 0);
      var ii = value.length;
      var char = void 0;
      var pos = 0;
      var open = 0;
      var quote = null;
      var interpolationStart = void 0;
      var parts = void 0;
      var partIndex = 0;

      while (i >= 0 && i < ii - 2) {
        open = 1;
        interpolationStart = i;
        i += 2;

        do {
          char = value[i];
          i++;

          if (char === "'" || char === '"') {
            if (quote === null) {
              quote = char;
            } else if (quote === char) {
              quote = null;
            }
            continue;
          }

          if (char === '\\') {
            i++;
            continue;
          }

          if (quote !== null) {
            continue;
          }

          if (char === '{') {
            open++;
          } else if (char === '}') {
            open--;
          }
        } while (open > 0 && i < ii);

        if (open === 0) {
          parts = parts || [];
          if (value[interpolationStart - 1] === '\\' && value[interpolationStart - 2] !== '\\') {
            parts[partIndex] = value.substring(pos, interpolationStart - 1) + value.substring(interpolationStart, i);
            partIndex++;
            parts[partIndex] = this.emptyStringExpression;
            partIndex++;
          } else {
            parts[partIndex] = value.substring(pos, interpolationStart);
            partIndex++;
            parts[partIndex] = this.parser.parse(value.substring(interpolationStart + 2, i - 1));
            partIndex++;
          }
          pos = i;
          i = value.indexOf('${', i);
        } else {
          break;
        }
      }

      if (partIndex === 0) {
        return null;
      }

      parts[partIndex] = value.substr(pos);
      return parts;
    };

    return TemplatingBindingLanguage;
  }(_aureliaTemplating.BindingLanguage), _class4.inject = [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, SyntaxInterpreter, AttributeMap], _temp3);
  function configure(config) {
    config.container.registerSingleton(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
    config.container.registerAlias(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
  }
});
define('aurelia-templating-resources/aurelia-templating-resources',['exports', 'aurelia-pal', './compose', './if', './else', './with', './repeat', './show', './hide', './sanitize-html', './replaceable', './focus', 'aurelia-templating', './css-resource', './html-sanitizer', './attr-binding-behavior', './binding-mode-behaviors', './throttle-binding-behavior', './debounce-binding-behavior', './self-binding-behavior', './signal-binding-behavior', './binding-signaler', './update-trigger-binding-behavior', './abstract-repeater', './repeat-strategy-locator', './html-resource-plugin', './null-repeat-strategy', './array-repeat-strategy', './map-repeat-strategy', './set-repeat-strategy', './number-repeat-strategy', './repeat-utilities', './analyze-view-factory', './aurelia-hide-style'], function (exports, _aureliaPal, _compose, _if, _else, _with, _repeat, _show, _hide, _sanitizeHtml, _replaceable, _focus, _aureliaTemplating, _cssResource, _htmlSanitizer, _attrBindingBehavior, _bindingModeBehaviors, _throttleBindingBehavior, _debounceBindingBehavior, _selfBindingBehavior, _signalBindingBehavior, _bindingSignaler, _updateTriggerBindingBehavior, _abstractRepeater, _repeatStrategyLocator, _htmlResourcePlugin, _nullRepeatStrategy, _arrayRepeatStrategy, _mapRepeatStrategy, _setRepeatStrategy, _numberRepeatStrategy, _repeatUtilities, _analyzeViewFactory, _aureliaHideStyle) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.viewsRequireLifecycle = exports.unwrapExpression = exports.updateOneTimeBinding = exports.isOneTime = exports.getItemsSourceExpression = exports.updateOverrideContext = exports.createFullOverrideContext = exports.NumberRepeatStrategy = exports.SetRepeatStrategy = exports.MapRepeatStrategy = exports.ArrayRepeatStrategy = exports.NullRepeatStrategy = exports.RepeatStrategyLocator = exports.AbstractRepeater = exports.UpdateTriggerBindingBehavior = exports.BindingSignaler = exports.SignalBindingBehavior = exports.SelfBindingBehavior = exports.DebounceBindingBehavior = exports.ThrottleBindingBehavior = exports.TwoWayBindingBehavior = exports.OneWayBindingBehavior = exports.OneTimeBindingBehavior = exports.AttrBindingBehavior = exports.configure = exports.Focus = exports.Replaceable = exports.SanitizeHTMLValueConverter = exports.HTMLSanitizer = exports.Hide = exports.Show = exports.Repeat = exports.With = exports.Else = exports.If = exports.Compose = undefined;


  function configure(config) {
    (0, _aureliaHideStyle.injectAureliaHideStyleAtHead)();

    config.globalResources(_aureliaPal.PLATFORM.moduleName('./compose'), _aureliaPal.PLATFORM.moduleName('./if'), _aureliaPal.PLATFORM.moduleName('./else'), _aureliaPal.PLATFORM.moduleName('./with'), _aureliaPal.PLATFORM.moduleName('./repeat'), _aureliaPal.PLATFORM.moduleName('./show'), _aureliaPal.PLATFORM.moduleName('./hide'), _aureliaPal.PLATFORM.moduleName('./replaceable'), _aureliaPal.PLATFORM.moduleName('./sanitize-html'), _aureliaPal.PLATFORM.moduleName('./focus'), _aureliaPal.PLATFORM.moduleName('./binding-mode-behaviors'), _aureliaPal.PLATFORM.moduleName('./self-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./throttle-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./debounce-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./signal-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./update-trigger-binding-behavior'), _aureliaPal.PLATFORM.moduleName('./attr-binding-behavior'));

    (0, _htmlResourcePlugin.configure)(config);

    var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
    var styleResourcePlugin = {
      fetch: function fetch(address) {
        var _ref;

        return _ref = {}, _ref[address] = (0, _cssResource._createCSSResource)(address), _ref;
      }
    };
    ['.css', '.less', '.sass', '.scss', '.styl'].forEach(function (ext) {
      return viewEngine.addResourcePlugin(ext, styleResourcePlugin);
    });
  }

  exports.Compose = _compose.Compose;
  exports.If = _if.If;
  exports.Else = _else.Else;
  exports.With = _with.With;
  exports.Repeat = _repeat.Repeat;
  exports.Show = _show.Show;
  exports.Hide = _hide.Hide;
  exports.HTMLSanitizer = _htmlSanitizer.HTMLSanitizer;
  exports.SanitizeHTMLValueConverter = _sanitizeHtml.SanitizeHTMLValueConverter;
  exports.Replaceable = _replaceable.Replaceable;
  exports.Focus = _focus.Focus;
  exports.configure = configure;
  exports.AttrBindingBehavior = _attrBindingBehavior.AttrBindingBehavior;
  exports.OneTimeBindingBehavior = _bindingModeBehaviors.OneTimeBindingBehavior;
  exports.OneWayBindingBehavior = _bindingModeBehaviors.OneWayBindingBehavior;
  exports.TwoWayBindingBehavior = _bindingModeBehaviors.TwoWayBindingBehavior;
  exports.ThrottleBindingBehavior = _throttleBindingBehavior.ThrottleBindingBehavior;
  exports.DebounceBindingBehavior = _debounceBindingBehavior.DebounceBindingBehavior;
  exports.SelfBindingBehavior = _selfBindingBehavior.SelfBindingBehavior;
  exports.SignalBindingBehavior = _signalBindingBehavior.SignalBindingBehavior;
  exports.BindingSignaler = _bindingSignaler.BindingSignaler;
  exports.UpdateTriggerBindingBehavior = _updateTriggerBindingBehavior.UpdateTriggerBindingBehavior;
  exports.AbstractRepeater = _abstractRepeater.AbstractRepeater;
  exports.RepeatStrategyLocator = _repeatStrategyLocator.RepeatStrategyLocator;
  exports.NullRepeatStrategy = _nullRepeatStrategy.NullRepeatStrategy;
  exports.ArrayRepeatStrategy = _arrayRepeatStrategy.ArrayRepeatStrategy;
  exports.MapRepeatStrategy = _mapRepeatStrategy.MapRepeatStrategy;
  exports.SetRepeatStrategy = _setRepeatStrategy.SetRepeatStrategy;
  exports.NumberRepeatStrategy = _numberRepeatStrategy.NumberRepeatStrategy;
  exports.createFullOverrideContext = _repeatUtilities.createFullOverrideContext;
  exports.updateOverrideContext = _repeatUtilities.updateOverrideContext;
  exports.getItemsSourceExpression = _repeatUtilities.getItemsSourceExpression;
  exports.isOneTime = _repeatUtilities.isOneTime;
  exports.updateOneTimeBinding = _repeatUtilities.updateOneTimeBinding;
  exports.unwrapExpression = _repeatUtilities.unwrapExpression;
  exports.viewsRequireLifecycle = _analyzeViewFactory.viewsRequireLifecycle;
});
;define('aurelia-templating-resources', ['aurelia-templating-resources/aurelia-templating-resources'], function (main) { return main; });

var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        LOG_MAX_INT = Math.log(MAX_INT);

    function Integer(v, radix) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a,b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };

    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
            if (isPrecise(a.value * this.value)) {
                return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    function square(a) {
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            for (var j = 0; j < l; j++) {
                a_j = a[j];
                product = a_i * a_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        var value = n.value;
        if (value === 0) return false;
        if (value === 1) return true;
        if (value === 2) return this.isEven();
        return this.mod(n).equals(Integer[0]);
    };
    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(25)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    BigInteger.prototype.isPrime = function () {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs(),
            nPrev = n.prev();
        var a = [2, 3, 5, 7, 11, 13, 17, 19],
            b = nPrev,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2);
        for (i = 0; i < a.length; i++) {
            x = bigInt(a[i]).modPow(b, n);
            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {
                x = x.square().mod(n);
                if (x.equals(nPrev)) t = false;
            }
            if (t) return false;
        }
        return true;
    };
    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        // use the Fermat primality test
        for (var i = 0; i < t; i++) {
            var a = bigInt.randBetween(2, n.minus(2));
            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite
        }
        return true; // large chance of being prime
    };
    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.equals(bigInt.zero)) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||
            (n instanceof BigInteger && n.value.length <= 1);
    }

    BigInteger.prototype.shiftLeft = function (n) {
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (n) {
        var remQuo;
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = Math.min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(Math.random() * range));
        var length = range.value.length - 1;
        var result = [], restricted = true;
        for (var i = length; i >= 0; i--) {
            var top = restricted ? range.value[i] : BASE;
            var digit = truncate(Math.random() * top);
            result.unshift(digit);
            if (digit < top) restricted = false;
        }
        result = arrayToSmall(result);
        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
    }
    var parseBase = function (text, base) {
        var length = text.length;
		var i;
		var absBase = Math.abs(base);
		for(var i = 0; i < length; i++) {
			var c = text[i].toLowerCase();
			if(c === "-") continue;
			if(/[a-z0-9]/.test(c)) {
			    if(/[0-9]/.test(c) && +c >= absBase) {
					if(c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
				} else if(c.charCodeAt(0) - 87 >= absBase) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
			}
		}
        if (2 <= base && base <= 36) {
            if (length <= LOG_MAX_INT / Math.log(base)) {
				var result = parseInt(text, base);
				if(isNaN(result)) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
                return new SmallInteger(parseInt(text, base));
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i].toLowerCase(),
                charCode = c.charCodeAt(0);
            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">");
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit) {
        var v = digit.value;
        if (typeof v === "number") v = [v];
        if (v.length === 1 && v[0] <= 35) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(v[0]);
        }
        return "<" + v + ">";
    }
    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return "0";
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return "0";
            if (n.isNegative()) return new Array(1 - n).join("10");
            return "1" + new Array(+n).join("01");
        }
        var minusSign = "";
        if (n.isNegative() && base.isPositive()) {
            minusSign = "-";
            n = n.abs();
        }
        if (base.equals(1)) {
            if (n.isZero()) return "0";
            return minusSign + new Array(+n + 1).join(1);
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(stringify(digit));
        }
        out.push(stringify(left));
        return minusSign + out.reverse().join("");
    }

    BigInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBase(this, radix);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBase(this, radix);
        return String(this.value);
    };
    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return +this.toString();
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

    function parseStringValue(v) {
            if (isPrecise(+v)) {
                var x = +v;
                if (x === truncate(x))
                    return new SmallInteger(x);
                throw "Invalid integer: " + v;
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
                var exp = split[1];
                if (exp[0] === "+") exp = exp.slice(1);
                exp = +exp;
                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
                var text = split[0];
                var decimalPlace = text.indexOf(".");
                if (decimalPlace >= 0) {
                    exp -= text.length - decimalPlace - 1;
                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
                }
                if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
                text += (new Array(exp + 1)).join("0");
                v = text;
            }
            var isValid = /^([0-9][0-9]*)$/.test(v);
            if (!isValid) throw new Error("Invalid integer: " + v);
            var r = [], max = v.length, l = LOG_BASE, min = max - l;
            while (max > 0) {
                r.push(+v.slice(min, max));
                min -= l;
                if (min < 0) min = 0;
                max -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = new SmallInteger(i);
        if (i > 0) Integer[-i] = new SmallInteger(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if ( typeof define === "function" && define.amd ) {
  define( "big-integer", [], function() {
    return bigInt;
  });
}

/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if('object' === typeof exports) {
			factory(exports);
		} else if ('function' === typeof define && define.amd) {
			define('crc-32',[],function () {
				var module = {};
				factory(module);
				return module;
			});
		} else {
			factory(CRC32 = {});
		}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.0';
/* see perf/crc32table.js */
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T = signed_crc_table();
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1, L = bstr.length - 1;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
	}
	if(i === L) C = (C>>>8) ^ T[(C ^ bstr.charCodeAt(i))&0xFF];
	return C ^ -1;
}

function crc32_buf(buf, seed) {
	if(buf.length > 10000) return crc32_buf_8(buf, seed);
	var C = seed ^ -1, L = buf.length - 3;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+3) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_buf_8(buf, seed) {
	var C = seed ^ -1, L = buf.length - 7;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+7) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L=str.length, c, d; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T[(C ^ c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return C ^ -1;
}
CRC32.table = T;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",[],function(){return saveAs})}

define("file-saver/FileSaver.min", [],function(){});

;define('file-saver', ['file-saver/FileSaver.min'], function (main) { return main; });

define('crypto', [],function() { 
    var crypto = window.vantage.nodeModules.crypto; 
    delete crypto.createCredentials;
    delete crypto.Credentials;
    return crypto;
});
define('libvantage/vantage',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wind = window;
    var vantage = wind.vantage;
    // Restore allowed node modules.
    wind.Buffer = vantage.Buffer;
    function setEditor(editor) {
        vantage.setEditor(editor);
    }
    exports.setEditor = setEditor;
    function openDevTools() {
        vantage.openDevTools();
    }
    exports.openDevTools = openDevTools;
    // Open dev tools on Ctrl + Shift + D.
    document.addEventListener('keydown', function (e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'D') {
            openDevTools();
        }
    });
});

define('libvantage/crypto/index',["require", "exports", "tslib", "./adler32", "./aes", "./cipher", "./crc32", "./fnv0", "./hash", "./des", "./blowfish", "./rsa", "./crypto-stream"], function (require, exports, tslib_1, adler32_1, aes_1, cipher_1, crc32_1, fnv0_1, hash_1, des_1, blowfish_1, rsa_1, crypto_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tslib_1.__exportStar(adler32_1, exports);
    tslib_1.__exportStar(aes_1, exports);
    tslib_1.__exportStar(cipher_1, exports);
    tslib_1.__exportStar(crc32_1, exports);
    tslib_1.__exportStar(fnv0_1, exports);
    tslib_1.__exportStar(hash_1, exports);
    tslib_1.__exportStar(des_1, exports);
    tslib_1.__exportStar(blowfish_1, exports);
    tslib_1.__exportStar(rsa_1, exports);
    tslib_1.__exportStar(crypto_stream_1, exports);
});

define('libvantage/crypto/adler32',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function adler32(buffer, initial) {
        if (initial === void 0) { initial = 1; }
        var a = initial & 0xFFFF;
        var b = (initial >>> 16) & 0xFFFF;
        var x = 0;
        var len = buffer.length;
        while (len > 0) {
            var n = Math.min(len, 3800);
            len -= n;
            while (--n >= 0) {
                a += buffer[x++] & 0xFF;
                b += a;
            }
            a %= 65521;
            b %= 65521;
        }
        return ((b << 16) | a) >>> 0;
    }
    exports.adler32 = adler32;
});

define('libvantage/crypto/aes',["require", "exports", "./cipher"], function (require, exports, cipher_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AesMode;
    (function (AesMode) {
        AesMode["ECB"] = "ecb";
        AesMode["CBC"] = "cbc";
        AesMode["CTR"] = "ctr";
        AesMode["CFB"] = "cfb";
        AesMode["OFB"] = "ofb";
        AesMode["GMC"] = "gcm";
    })(AesMode = exports.AesMode || (exports.AesMode = {}));
    function getAesAlgorithmName(mode, keyLength) {
        return "aes-" + keyLength * 8 + "-" + mode;
    }
    function aesCBCdecrypt(data, key, iv, autopadding) {
        return cipher_1.decrypt(getAesAlgorithmName(AesMode.CBC, key.length), data, key, iv || Buffer.alloc(0x10), autopadding);
    }
    exports.aesCBCdecrypt = aesCBCdecrypt;
    function aesCBCencrypt(data, key, iv, autopadding) {
        return cipher_1.encrypt(getAesAlgorithmName(AesMode.CBC, key.length), data, key, iv || Buffer.alloc(0x10), autopadding);
    }
    exports.aesCBCencrypt = aesCBCencrypt;
    function aesGCMdecrypt(buffer, tag, key, iv, autoPadding) {
        var decipher = cipher_1.createDecipher(getAesAlgorithmName(AesMode.GMC, key.length), key, iv, autoPadding);
        decipher.setAuthTag(tag);
        return Buffer.concat([decipher.update(buffer), decipher.final()]);
    }
    exports.aesGCMdecrypt = aesGCMdecrypt;
    function aesGCMencrypt(buffer, key, iv, autoPadding) {
        var cipher = cipher_1.createCipher(getAesAlgorithmName(AesMode.GMC, key.length), key, iv, autoPadding);
        return {
            data: Buffer.concat([cipher.update(buffer), cipher.final()]),
            tag: cipher.getAuthTag()
        };
    }
    exports.aesGCMencrypt = aesGCMencrypt;
    var Aes = /** @class */ (function () {
        function Aes() {
        }
        Aes.createEncryptor = function (mode, key, iv, autoPadding) {
            if (autoPadding === void 0) { autoPadding = true; }
            var cipher = cipher_1.createCipher(getAesAlgorithmName(mode, key.length), key, iv, autoPadding);
            return new AesCryptoTransform(cipher, mode == AesMode.GMC);
        };
        Aes.createDecryptor = function (mode, key, iv, autoPadding, auth) {
            if (autoPadding === void 0) { autoPadding = true; }
            var decipher = cipher_1.createDecipher(getAesAlgorithmName(mode, key.length), key, iv, autoPadding);
            if (mode == AesMode.GMC) {
                if (auth != null) {
                    decipher.setAuthTag(auth);
                }
                else {
                    throw new Error("invalid auth tag");
                }
            }
            return new AesCryptoTransform(decipher, mode == AesMode.GMC);
        };
        return Aes;
    }());
    exports.Aes = Aes;
    var AesCryptoTransform = /** @class */ (function () {
        function AesCryptoTransform(transform, auth) {
            if (auth === void 0) { auth = true; }
            this.transform = transform;
            this.auth = auth;
        }
        AesCryptoTransform.prototype.transformBlock = function (input, inputOffset, inputCount, output, outputOffest) {
            var tempOutput = this.transform.update(input.slice(inputOffset, inputOffset + inputCount));
            return tempOutput.copy(output, outputOffest || 0);
        };
        AesCryptoTransform.prototype.transformFinalBlock = function () {
            if (this.auth && this.transform.getAuthTag) {
                // add gcm tag to end of buffer
                return Buffer.concat([this.transform.final(), this.transform.getAuthTag()]);
            }
            return this.transform.final();
        };
        return AesCryptoTransform;
    }());
    exports.AesCryptoTransform = AesCryptoTransform;
});

define('libvantage/crypto/cipher',["require", "exports", "crypto"], function (require, exports, crypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createCipher(algorithm, key, iv, autopadding) {
        if (autopadding === void 0) { autopadding = false; }
        var cipher = iv ? crypto.createCipheriv(algorithm, key, iv) : crypto.createCipher(algorithm, key);
        cipher.setAutoPadding(autopadding);
        return cipher;
    }
    exports.createCipher = createCipher;
    function createDecipher(algorithm, key, iv, autopadding) {
        if (autopadding === void 0) { autopadding = false; }
        var decipher = iv ? crypto.createDecipheriv(algorithm, key, iv) : crypto.createDecipher(algorithm, key);
        decipher.setAutoPadding(autopadding);
        return decipher;
    }
    exports.createDecipher = createDecipher;
    function encrypt(algorithm, buffer, key, iv, autopadding) {
        var cipher = createCipher(algorithm, key, iv, autopadding);
        return Buffer.concat([cipher.update(buffer), cipher.final()]);
    }
    exports.encrypt = encrypt;
    function decrypt(algorithm, buffer, key, iv, autopadding) {
        var decipher = createDecipher(algorithm, key, iv, autopadding);
        return Buffer.concat([decipher.update(buffer), decipher.final()]);
    }
    exports.decrypt = decrypt;
    function getRandom(size) {
        return crypto.randomBytes(size);
    }
    exports.getRandom = getRandom;
    var CipherType;
    (function (CipherType) {
        CipherType["TripleDES"] = "des-ede3-cbc";
        CipherType["BlowfishCBC"] = "bf-cbc";
        CipherType["BlowfishECB"] = "bf-ebc";
    })(CipherType = exports.CipherType || (exports.CipherType = {}));
    var CipherFactory = /** @class */ (function () {
        function CipherFactory() {
        }
        CipherFactory.createEncryptor = function (algorithm, key, iv, autoPadding) {
            if (autoPadding === void 0) { autoPadding = true; }
            return new CryptoTransform(createCipher(algorithm, key, iv, autoPadding));
        };
        CipherFactory.createDecryptor = function (algorithm, key, iv, autoPadding) {
            if (autoPadding === void 0) { autoPadding = true; }
            return new CryptoTransform(createDecipher(algorithm, key, iv, autoPadding));
        };
        return CipherFactory;
    }());
    exports.CipherFactory = CipherFactory;
    var CryptoTransform = /** @class */ (function () {
        function CryptoTransform(transform) {
            this.transform = transform;
        }
        CryptoTransform.prototype.transformBlock = function (input, inputOffset, inputCount, output, outputOffest) {
            var tempOutput = this.transform.update(input.slice(inputOffset, inputOffset + inputCount));
            return tempOutput.copy(output, outputOffest || 0);
        };
        CryptoTransform.prototype.transformFinalBlock = function () {
            return this.transform.final();
        };
        return CryptoTransform;
    }());
    exports.CryptoTransform = CryptoTransform;
});

define('libvantage/crypto/crc32',["require", "exports", "crc-32"], function (require, exports, CRC32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function crc32(buffer, offset, length, seed) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = -1; }
        if (length === -1) {
            length = buffer.length - offset;
        }
        if (offset !== 0) {
            buffer = buffer.slice(offset, offset + length);
        }
        return new Uint32Array([CRC32.buf(buffer, seed)])[0];
    }
    exports.crc32 = crc32;
});

define('libvantage/crypto/fnv0',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Currently only works for ASCII strings.
    function fnv0(value, init, prime) {
        for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
            var char = value_1[_i];
            init ^= char.charCodeAt(0);
            init = Math.imul(init, prime);
        }
        return init >>> 0;
    }
    exports.fnv0 = fnv0;
});

define('libvantage/crypto/hash',["require", "exports", "crypto"], function (require, exports, crypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function sha256(data) {
        return crypto.createHash('sha256').update(data).digest();
    }
    exports.sha256 = sha256;
    function sha1(data) {
        return crypto.createHash('sha1').update(data).digest();
    }
    exports.sha1 = sha1;
});

define('libvantage/crypto/des',["require", "exports", "./cipher"], function (require, exports, cipher_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function tripleDesCBCdecrypt(data, key, iv, autopadding) {
        return cipher_1.decrypt("des-ede3-cbc", data, key, iv || Buffer.alloc(8), autopadding);
    }
    exports.tripleDesCBCdecrypt = tripleDesCBCdecrypt;
    function tripleDesCBCEncrypt(data, key, iv, autopadding) {
        return cipher_1.encrypt("des-ede3-cbc", data, key, iv || Buffer.alloc(8), autopadding);
        ;
    }
    exports.tripleDesCBCEncrypt = tripleDesCBCEncrypt;
});

define('libvantage/crypto/blowfish',["require", "exports", "./cipher"], function (require, exports, cipher_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function blowfishCbcDecrypt(data, key, iv, autopadding) {
        return cipher_1.decrypt('bf-cbc', data, key, iv || Buffer.alloc(8), autopadding);
    }
    exports.blowfishCbcDecrypt = blowfishCbcDecrypt;
    function blowfishCbcEncrypt(data, key, iv, autopadding) {
        return cipher_1.encrypt('bf-cbc', data, key, iv || Buffer.alloc(8), autopadding);
    }
    exports.blowfishCbcEncrypt = blowfishCbcEncrypt;
    function blowfishEcbDecrypt(data, key, iv, autopadding) {
        return cipher_1.decrypt('bf-ecb', data, key, iv, autopadding);
    }
    exports.blowfishEcbDecrypt = blowfishEcbDecrypt;
    function blowfishEcbEncrypt(data, key, iv, autopadding) {
        return cipher_1.encrypt('bf-ecb', data, key, iv, autopadding);
    }
    exports.blowfishEcbEncrypt = blowfishEcbEncrypt;
});

define('libvantage/crypto/rsa',["require", "exports", "crypto"], function (require, exports, crypto) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function verifyRsa1Signature(signature, data, publicKey) {
        var verify = crypto.createVerify('RSA-SHA1');
        verify.update(data);
        return verify.verify(publicKey, signature);
    }
    exports.verifyRsa1Signature = verifyRsa1Signature;
    function privateKeySign(data, privateKey) {
        var sign = crypto.createSign('RSA-SHA1');
        sign.update(data);
        return sign.sign(privateKey);
    }
    exports.privateKeySign = privateKeySign;
});

define('libvantage/crypto/crypto-stream',["require", "exports", "../io/memory-stream"], function (require, exports, memory_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CryptoStreamMode;
    (function (CryptoStreamMode) {
        CryptoStreamMode[CryptoStreamMode["Read"] = 0] = "Read";
        CryptoStreamMode[CryptoStreamMode["Write"] = 1] = "Write";
    })(CryptoStreamMode = exports.CryptoStreamMode || (exports.CryptoStreamMode = {}));
    var CryptoStream = /** @class */ (function () {
        function CryptoStream(_stream, _transform, _mode) {
            this._stream = _stream;
            this._transform = _transform;
            this._mode = _mode;
            if (_mode == CryptoStreamMode.Write) {
                this._memory = memory_stream_1.MemoryStream.alloc(0x1000);
            }
        }
        CryptoStream.prototype.write = function (buffer, index, length) {
            if (this._mode == CryptoStreamMode.Read) {
                throw new Error('Invalid stream mode');
            }
            if (this._memory === null) {
                throw new Error('Stream disposed.');
            }
            var output = Buffer.alloc(length);
            var copied = this._transform.transformBlock(buffer, index, length, output);
            return this._memory.write(output, 0, copied);
        };
        CryptoStream.prototype.read = function (buffer, index, length) {
            if (this._mode == CryptoStreamMode.Write) {
                throw new Error('Invalid stream mode');
            }
            var data = Buffer.alloc(length);
            var readLength = this._stream.read(data, 0, length);
            var output = Buffer.alloc(readLength);
            var copied = this._transform.transformBlock(data, 0, readLength, output);
            var remainder = readLength - copied;
            if (remainder > 0) {
                var final = this._transform.transformFinalBlock();
                remainder = final.copy(output, copied, 0, remainder);
            }
            return output.copy(buffer, index, 0, copied + remainder);
        };
        CryptoStream.prototype.dispose = function () {
            if (this._memory === null) {
                throw new Error('Stream disposed.');
            }
            if (this._mode == CryptoStreamMode.Write) {
                var streamData = this._memory.getBuffer();
                this._stream.write(streamData, 0, streamData.length);
                var buffer = this._transform.transformFinalBlock();
                if (buffer.length > 0) {
                    this._stream.write(buffer, 0, buffer.length);
                }
            }
            this._memory = null;
        };
        CryptoStream.prototype.close = function () {
            this.dispose();
        };
        Object.defineProperty(CryptoStream.prototype, "eof", {
            get: function () {
                throw new Error("Method not supported.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CryptoStream.prototype, "length", {
            get: function () {
                return this._stream.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CryptoStream.prototype, "position", {
            get: function () {
                return this._stream.position;
            },
            set: function (offset) {
                this._stream.position = 0;
            },
            enumerable: true,
            configurable: true
        });
        CryptoStream.prototype.seek = function (offset, origin) {
            return this._stream.seek(offset, origin);
        };
        CryptoStream.prototype.readByte = function () {
            return this._stream.readByte();
        };
        return CryptoStream;
    }());
    exports.CryptoStream = CryptoStream;
});

define('libvantage/io/memory-stream',["require", "exports", "tslib", "./abstract-stream"], function (require, exports, tslib_1, abstract_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MemoryStream = /** @class */ (function (_super) {
        tslib_1.__extends(MemoryStream, _super);
        function MemoryStream(buffer) {
            var _this = _super.call(this) || this;
            _this._position = 0;
            _this._buffer = buffer || Buffer.alloc(0x10);
            _this._length = _this._buffer.length;
            return _this;
        }
        MemoryStream.alloc = function (size) {
            return new MemoryStream(Buffer.alloc(size));
        };
        MemoryStream.reserve = function (size) {
            var stream = MemoryStream.alloc(size);
            stream._length = 0;
            return stream;
        };
        MemoryStream.prototype.getBuffer = function () {
            return this._buffer.slice(0, this.length);
        };
        MemoryStream.prototype.dispose = function () {
            this._buffer = null;
        };
        Object.defineProperty(MemoryStream.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemoryStream.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (address) {
                if (address > this.length) {
                    throw new Error('Cannot seek past end of stream.');
                }
                this._position = address;
            },
            enumerable: true,
            configurable: true
        });
        MemoryStream.prototype.resize = function (size) {
            if (size > this._buffer.length) {
                this._buffer = Buffer.concat([this._buffer], size);
            }
            this._length = size;
            return this;
        };
        MemoryStream.prototype.expand = function (size) {
            var reserve = this.position + size;
            if (reserve > this._length) {
                if (reserve > this._buffer.length) {
                    this._buffer = Buffer.concat([this._buffer], Math.max(reserve, this._buffer.length * 1.5));
                }
                this._length = reserve;
            }
        };
        MemoryStream.prototype.readByte = function () {
            return this._buffer[this.position++];
        };
        MemoryStream.prototype.read = function (buffer, index, length) {
            this.position += length;
            return this._buffer.copy(buffer, index, this.position - length, this.position);
        };
        MemoryStream.prototype.write = function (buffer, index, length) {
            this.expand(length);
            var written = buffer.copy(this._buffer, this.position, index, length);
            this.position += written;
            return written;
        };
        return MemoryStream;
    }(abstract_stream_1.AbstractStream));
    exports.MemoryStream = MemoryStream;
});

define('libvantage/io/abstract-stream',["require", "exports", "./stream"], function (require, exports, stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractStream = /** @class */ (function () {
        function AbstractStream() {
        }
        Object.defineProperty(AbstractStream.prototype, "eof", {
            get: function () {
                return this.position >= this.length;
            },
            enumerable: true,
            configurable: true
        });
        AbstractStream.prototype.seek = function (offset, origin) {
            if (origin === void 0) { origin = stream_1.SeekOrigin.Begin; }
            switch (origin) {
                case stream_1.SeekOrigin.Begin:
                    this.position = offset;
                    break;
                case stream_1.SeekOrigin.End:
                    this.position = this.length - offset;
                    break;
                case stream_1.SeekOrigin.Current:
                    this.position += offset;
                    break;
            }
            return this.position;
        };
        AbstractStream.prototype.close = function () {
            this.dispose();
        };
        AbstractStream.prototype.dispose = function () {
        };
        return AbstractStream;
    }());
    exports.AbstractStream = AbstractStream;
});

define('libvantage/io/stream',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SeekOrigin;
    (function (SeekOrigin) {
        SeekOrigin["Begin"] = "begin";
        SeekOrigin["End"] = "end";
        SeekOrigin["Current"] = "current";
    })(SeekOrigin = exports.SeekOrigin || (exports.SeekOrigin = {}));
});

define('libvantage/io/index',["require", "exports", "tslib", "./stream", "./abstract-stream", "./memory-stream", "./binary-stream", "./stream-writer", "./stream-reader", "./save-stream"], function (require, exports, tslib_1, stream_1, abstract_stream_1, memory_stream_1, binary_stream_1, stream_writer_1, stream_reader_1, save_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tslib_1.__exportStar(stream_1, exports);
    tslib_1.__exportStar(abstract_stream_1, exports);
    tslib_1.__exportStar(memory_stream_1, exports);
    tslib_1.__exportStar(binary_stream_1, exports);
    tslib_1.__exportStar(stream_writer_1, exports);
    tslib_1.__exportStar(stream_reader_1, exports);
    tslib_1.__exportStar(save_stream_1, exports);
});

define('libvantage/io/binary-stream',["require", "exports", "big-integer", "./stream"], function (require, exports, bigInteger, stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Endianness;
    (function (Endianness) {
        Endianness["Little"] = "le";
        Endianness["Big"] = "be";
    })(Endianness = exports.Endianness || (exports.Endianness = {}));
    var minUInt64 = bigInteger.zero;
    var maxUInt64 = bigInteger("18446744073709551615", 10);
    var minInt64 = bigInteger('-9223372036854775808', 10);
    var maxInt64 = bigInteger('9223372036854775807', 10);
    var bigIntNegateCache = new Map([
        [8, maxUInt64.add(1)],
    ]);
    var numberBuffer = Buffer.alloc(8);
    var stringBuffer;
    var BinaryStream = /** @class */ (function () {
        function BinaryStream(_stream, endianness) {
            if (endianness === void 0) { endianness = Endianness.Little; }
            this._stream = _stream;
            this.endianness = endianness;
        }
        Object.defineProperty(BinaryStream.prototype, "baseStream", {
            get: function () {
                return this._stream;
            },
            enumerable: true,
            configurable: true
        });
        BinaryStream.prototype.dispose = function () {
            this._stream.dispose();
        };
        Object.defineProperty(BinaryStream.prototype, "endianness", {
            get: function () {
                return this._endiannessValue;
            },
            set: function (endianness) {
                this._endiannessValue = endianness;
                this._endiannessPostfix = endianness === Endianness.Big ? 'BE' : 'LE';
            },
            enumerable: true,
            configurable: true
        });
        BinaryStream.prototype.skip = function (offset) {
            this._stream.seek(offset, stream_1.SeekOrigin.Current);
            return this;
        };
        BinaryStream.prototype.readBytes = function (length) {
            var buffer = Buffer.alloc(length);
            var readBytes = this._stream.read(buffer, 0, length);
            return buffer.slice(0, readBytes);
        };
        BinaryStream.prototype.readToEnd = function () {
            return this.readBytes(this._stream.length - this._stream.position);
        };
        BinaryStream.prototype.getBuffer = function () {
            this._stream.position = 0;
            return this.readBytes(this._stream.length - this._stream.position);
        };
        BinaryStream.prototype.readNumber = function (type, size) {
            this._stream.read(numberBuffer, 0, size);
            return numberBuffer["read" + type + this._endiannessPostfix](0);
        };
        BinaryStream.prototype.readByte = function () {
            return this._stream.readByte();
        };
        BinaryStream.prototype.readBoolean = function () {
            return this.readByte() !== 0;
        };
        BinaryStream.prototype.readUInt16 = function () {
            return this.readNumber('UInt16', 2);
        };
        BinaryStream.prototype.readInt16 = function () {
            return this.readNumber('Int16', 2);
        };
        BinaryStream.prototype.readUInt32 = function () {
            return this.readNumber('UInt32', 4);
        };
        BinaryStream.prototype.readInt32 = function () {
            return this.readNumber('Int32', 4);
        };
        BinaryStream.prototype.readInt64 = function () {
            return this.readSignedBigInteger(8);
        };
        BinaryStream.prototype.readUInt64 = function () {
            return this.readUnsignedBigInteger(8);
        };
        BinaryStream.prototype.readInt64Unsafe = function () {
            return this.readInt64().toJSNumber();
        };
        BinaryStream.prototype.readUInt64Unsafe = function () {
            return this.readUInt64().toJSNumber();
        };
        BinaryStream.prototype.readSignedBigInteger = function (size) {
            var buffer = this.readBytes(size);
            if (this.endianness === Endianness.Little) {
                buffer.reverse();
            }
            var value = bigInteger(buffer.toString('hex'), 16);
            return (buffer[0] & 0x80) > 0
                ? this.setBigIntegerSign(value, size, true)
                : value;
        };
        BinaryStream.prototype.setBigIntegerSign = function (value, size, negative) {
            var negateValue = bigIntNegateCache.get(size);
            if (negateValue === undefined) {
                negateValue = bigInteger('f'.repeat(size * 2), 16).add(1);
                bigIntNegateCache.set(size, negateValue);
            }
            return value[negative ? 'subtract' : 'add'](negateValue);
        };
        BinaryStream.prototype.readUnsignedBigInteger = function (size) {
            var buffer = this.readBytes(size);
            if (this.endianness === Endianness.Little) {
                buffer.reverse();
            }
            return bigInteger(buffer.toString('hex'), 16);
        };
        BinaryStream.prototype.readFloat = function () {
            return this.readNumber('Float', 4);
        };
        BinaryStream.prototype.readDouble = function () {
            return this.readNumber('Double', 8);
        };
        BinaryStream.prototype.loop = function (type, callback) {
            var count = this["read" + type]();
            var results = [];
            while (count--) {
                results.push(callback(this));
            }
            return results;
        };
        BinaryStream.prototype.loopByte = function (callback) {
            return this.loop('Byte', callback);
        };
        BinaryStream.prototype.loopUInt16 = function (callback) {
            return this.loop('UInt16', callback);
        };
        BinaryStream.prototype.loopUInt32 = function (callback) {
            return this.loop('UInt32', callback);
        };
        BinaryStream.prototype.loopUInt64 = function (callback) {
            return this.loop('UInt64Unsafe', callback);
        };
        BinaryStream.prototype.getStringBuffer = function (length) {
            if (stringBuffer === undefined) {
                stringBuffer = Buffer.alloc(Math.min(length, 32));
            }
            else if (length > stringBuffer.length) {
                var expansion = Math.max(stringBuffer.length * 2, length) - stringBuffer.length;
                stringBuffer = Buffer.concat([stringBuffer, Buffer.alloc(expansion)], stringBuffer.length + expansion);
            }
            return stringBuffer;
        };
        BinaryStream.prototype.readString = function (encoding, bytes) {
            if (bytes === void 0) { bytes = -1; }
            if (bytes === -1) {
                return this.readCString(encoding);
            }
            var buffer = this.getStringBuffer(bytes);
            this._stream.read(buffer, 0, bytes);
            return buffer.toString(encoding);
        };
        BinaryStream.prototype.readCString = function (encoding) {
            var terminatorLength = Buffer.byteLength('\0', encoding);
            var x = 0;
            var consecutiveNullBytes = 0;
            var buffer = this.getStringBuffer(terminatorLength);
            while (true) {
                if ((buffer[x++] = this._stream.readByte()) !== 0) {
                    consecutiveNullBytes = 0;
                }
                else if (++consecutiveNullBytes === terminatorLength) {
                    return buffer.toString(encoding, 0, x - terminatorLength);
                }
                if (x === buffer.length) {
                    buffer = this.getStringBuffer(x * 2);
                }
            }
        };
        BinaryStream.prototype.writeBytes = function (value) {
            this._stream.write(value, 0, value.length);
            return this;
        };
        BinaryStream.prototype.writeNumber = function (type, value, size) {
            numberBuffer["write" + type + (size > 1 ? this._endiannessPostfix : '')](value, 0);
            this._stream.write(numberBuffer, 0, size);
            return this;
        };
        BinaryStream.prototype.writeByte = function (value) {
            return this.writeNumber('UInt8', value, 1);
        };
        BinaryStream.prototype.writeBoolean = function (flag) {
            return this.writeByte(flag ? 1 : 0);
        };
        BinaryStream.prototype.writeUInt16 = function (value) {
            return this.writeNumber('UInt16', value, 2);
        };
        BinaryStream.prototype.writeInt16 = function (value) {
            return this.writeNumber('Int16', value, 2);
        };
        BinaryStream.prototype.writeUInt32 = function (value) {
            return this.writeNumber('UInt32', value, 4);
        };
        BinaryStream.prototype.writeInt32 = function (value) {
            return this.writeNumber('Int32', value, 4);
        };
        BinaryStream.prototype.writeUInt64 = function (value) {
            return this.writeBigInteger(this.assertBigIntegerBounds(value, minUInt64, maxUInt64), 8);
        };
        BinaryStream.prototype.writeInt64 = function (value) {
            return this.writeBigInteger(this.assertBigIntegerBounds(value, minInt64, maxInt64), 8);
        };
        BinaryStream.prototype.writeBigInteger = function (value, byteLength) {
            if (byteLength === void 0) { byteLength = -1; }
            var hexString = value.toString(16);
            var negative = value.isNegative();
            if (negative) {
                value = this.setBigIntegerSign(value, (hexString.length - 1) / 2, false);
                hexString = value.toString(16);
            }
            if (byteLength >= 0) {
                var nibbleLength = byteLength * 2;
                if (hexString.length > nibbleLength) {
                    throw new Error("Cannot write BigInteger larger than " + byteLength + " bytes.");
                }
                if (hexString.length < nibbleLength) {
                    hexString = hexString.padStart(nibbleLength, negative ? 'f' : '0');
                }
            }
            var buffer = Buffer.from(hexString, 'hex');
            if (this.endianness === Endianness.Little) {
                buffer.reverse();
            }
            return this.writeBytes(buffer);
        };
        BinaryStream.prototype.assertBigIntegerBounds = function (value, min, max) {
            if (typeof value === 'number') {
                value = bigInteger(value);
            }
            if (value.lt(min)) {
                throw new Error('Cannot write integer less than minimum value.');
            }
            else if (value.gt(max)) {
                throw new Error('Cannot write integer greater than maximum value.');
            }
            return value;
        };
        BinaryStream.prototype.writeFloat = function (value) {
            return this.writeNumber('Float', value, 4);
        };
        BinaryStream.prototype.writeDouble = function (value) {
            return this.writeNumber('Double', value, 8);
        };
        BinaryStream.prototype.writeString = function (value, encoding, nullTerminate) {
            if (encoding === void 0) { encoding = 'utf8'; }
            if (nullTerminate === void 0) { nullTerminate = false; }
            if (nullTerminate) {
                value += '\0';
            }
            var buffer = new Buffer(value, encoding);
            this._stream.write(buffer, 0, buffer.length);
            return this;
        };
        return BinaryStream;
    }());
    exports.BinaryStream = BinaryStream;
});

define('libvantage/io/stream-writer',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StreamWriter = /** @class */ (function () {
        function StreamWriter(_baseStream) {
            this._baseStream = _baseStream;
        }
        StreamWriter.prototype.write = function (buffer) {
            this._baseStream.write(buffer, 0, buffer.length);
        };
        return StreamWriter;
    }());
    exports.StreamWriter = StreamWriter;
});

define('libvantage/io/stream-reader',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StreamReader = /** @class */ (function () {
        function StreamReader(_baseStream) {
            this._baseStream = _baseStream;
        }
        StreamReader.prototype.readToEnd = function () {
            var length = this._baseStream.length;
            var buffer = Buffer.alloc(length);
            var readBytes = this._baseStream.read(buffer, 0, length);
            return buffer.slice(0, readBytes);
        };
        return StreamReader;
    }());
    exports.StreamReader = StreamReader;
});

define('libvantage/io/save-stream',["require", "exports", "tslib", "../io/binary-stream"], function (require, exports, tslib_1, binary_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaveStream = /** @class */ (function (_super) {
        tslib_1.__extends(SaveStream, _super);
        function SaveStream() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SaveStream;
    }(binary_stream_1.BinaryStream));
    exports.SaveStream = SaveStream;
});

define('libvantage/compression/index',["require", "exports", "tslib", "./zlib", "./deflate-stream"], function (require, exports, tslib_1, zlib_1, deflate_stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tslib_1.__exportStar(zlib_1, exports);
    tslib_1.__exportStar(deflate_stream_1, exports);
});

define('libvantage/compression/zlib',["require", "exports", "zlib"], function (require, exports, zlib) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompressionMode;
    (function (CompressionMode) {
        CompressionMode[CompressionMode["Decompress"] = 0] = "Decompress";
        CompressionMode[CompressionMode["Compress"] = 1] = "Compress";
        CompressionMode[CompressionMode["DecompressRaw"] = 2] = "DecompressRaw";
        CompressionMode[CompressionMode["CompressRaw"] = 3] = "CompressRaw";
    })(CompressionMode = exports.CompressionMode || (exports.CompressionMode = {}));
    function zlibDecompress(buffer, options) {
        return zlib.inflateSync(buffer, options);
    }
    exports.zlibDecompress = zlibDecompress;
    function zlibCompress(buffer, options) {
        return zlib.deflateSync(buffer, options);
    }
    exports.zlibCompress = zlibCompress;
    function zlibDecompressRaw(buffer, options) {
        return zlib.inflateRawSync(buffer, options);
    }
    exports.zlibDecompressRaw = zlibDecompressRaw;
    function zlibCompressRaw(buffer, options) {
        return zlib.deflateRawSync(buffer, options);
    }
    exports.zlibCompressRaw = zlibCompressRaw;
    function zlibCreateDeflate(options) {
        return zlib.createDeflate(options);
    }
    exports.zlibCreateDeflate = zlibCreateDeflate;
    function zlibCreateInflate(options) {
        return zlib.createInflate(options);
    }
    exports.zlibCreateInflate = zlibCreateInflate;
    function zlibCreateDeflateRaw(options) {
        return zlib.createDeflateRaw(options);
    }
    exports.zlibCreateDeflateRaw = zlibCreateDeflateRaw;
    function zlibCreateInflateRaw(options) {
        return zlib.createInflateRaw(options);
    }
    exports.zlibCreateInflateRaw = zlibCreateInflateRaw;
    function createDeflate(mode, options) {
        switch (mode) {
            case CompressionMode.Compress:
                return zlibCreateDeflate(options);
            case CompressionMode.CompressRaw:
                return zlibCreateDeflateRaw(options);
            case CompressionMode.Decompress:
                return zlibCreateInflate(options);
            case CompressionMode.DecompressRaw:
                return zlibCreateInflateRaw(options);
        }
        throw Error("undefined deflate type");
    }
    exports.createDeflate = createDeflate;
    function deflate(buffer, mode, options) {
        switch (mode) {
            case CompressionMode.Compress:
                return zlibCompress(buffer, options);
            case CompressionMode.CompressRaw:
                return zlibCompressRaw(buffer, options);
            case CompressionMode.Decompress:
                return zlibDecompress(buffer, options);
            case CompressionMode.DecompressRaw:
                return zlibDecompressRaw(buffer, options);
        }
        throw Error("undefined deflate type");
    }
    exports.deflate = deflate;
});

define('libvantage/compression/deflate-stream',["require", "exports", "../io/memory-stream", "../compression/zlib"], function (require, exports, memory_stream_1, zlib_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DeflateStream = /** @class */ (function () {
        function DeflateStream(_stream, _mode, _options) {
            this._stream = _stream;
            this._mode = _mode;
            this._options = _options;
            if (_mode == zlib_1.CompressionMode.Compress || _mode == zlib_1.CompressionMode.CompressRaw) {
                this._memory = memory_stream_1.MemoryStream.reserve(8192); // only needed for compressing
            }
            this._transform = zlib_1.createDeflate(_mode, _options);
        }
        DeflateStream.prototype.write = function (buffer, index, length) {
            if (this._mode == zlib_1.CompressionMode.Decompress) {
                throw new Error('invalid stream mode');
            }
            if (this._memory === null) {
                throw new Error('Stream disposed.');
            }
            if (this._transform === null) {
                throw new Error('Invalid transform handle.');
            }
            throw new Error("not implemented");
        };
        DeflateStream.prototype.read = function (buffer, index, length) {
            if (this._mode == zlib_1.CompressionMode.Compress) {
                throw new Error('invalid stream mode');
            }
            throw new Error("not implemented");
        };
        DeflateStream.prototype.copyTo = function (stream) {
            var input = Buffer.alloc(this._stream.length);
            this.position = 0;
            this._stream.read(input, 0, input.length);
            var buffer = zlib_1.deflate(input, this._mode, this._options);
            if (buffer) {
                stream.write(buffer, 0, buffer.length);
            }
        };
        DeflateStream.prototype.dispose = function () {
            if (this._memory === null) {
                throw new Error('Stream disposed.');
            }
            if (this._mode == zlib_1.CompressionMode.Compress) {
                var streamData = this._memory.getBuffer();
                this._stream.write(streamData, 0, streamData.length);
            }
            if (this._memory) {
                if (this._memory.length != 0 && this._transform) {
                    this._transform.end();
                }
                this._memory = null;
            }
            this._transform = null;
        };
        DeflateStream.prototype.close = function () {
            this.dispose();
        };
        Object.defineProperty(DeflateStream.prototype, "eof", {
            get: function () {
                throw new Error("Method not supported.");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeflateStream.prototype, "length", {
            get: function () {
                return this._stream.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeflateStream.prototype, "position", {
            get: function () {
                return this._stream.position;
            },
            set: function (offset) {
                this._stream.position = 0;
            },
            enumerable: true,
            configurable: true
        });
        DeflateStream.prototype.seek = function (offset, origin) {
            return this._stream.seek(offset, origin);
        };
        DeflateStream.prototype.readByte = function () {
            return this._stream.readByte();
        };
        return DeflateStream;
    }());
    exports.DeflateStream = DeflateStream;
});

define('libvantage/resources/elements/numeric-element',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NumericElement = /** @class */ (function () {
        function NumericElement() {
            this.placeholder = '';
            this.min = '0';
            this.max = '100';
            this.step = '1';
        }
        Object.defineProperty(NumericElement.prototype, "validInputValue", {
            get: function () {
                return typeof this.inputValue === 'string' && this.inputValue.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumericElement.prototype, "canIncrease", {
            get: function () {
                return this.validInputValue && parseFloat(this.inputValue) < parseFloat(this.max);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumericElement.prototype, "canDecrease", {
            get: function () {
                return this.validInputValue && parseFloat(this.inputValue) > parseFloat(this.min);
            },
            enumerable: true,
            configurable: true
        });
        NumericElement.prototype.inputValueChanged = function (inputValue) {
            if (typeof inputValue === 'string' && inputValue.length !== 0 && inputValue !== 'NaN') {
                this.value = parseFloat(inputValue);
            }
        };
        NumericElement.prototype.valueChanged = function (value) {
            if (typeof value === 'string' && value.length !== 0) {
                this.inputValue = value;
            }
            else if (typeof value === 'number') {
                this.inputValue = value.toString();
            }
        };
        NumericElement.prototype.increase = function () {
            if (this.canIncrease) {
                var value = parseFloat(this.inputValue) + parseFloat(this.step.toString());
                this.inputValue = value > parseFloat(this.max) ? this.max : value.toString();
            }
        };
        NumericElement.prototype.decrease = function () {
            if (this.canDecrease) {
                var value = parseFloat(this.inputValue) - parseFloat(this.step.toString());
                this.inputValue = value < parseFloat(this.min) ? this.min : value.toString();
            }
        };
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Number)
        ], NumericElement.prototype, "value", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], NumericElement.prototype, "placeholder", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], NumericElement.prototype, "min", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], NumericElement.prototype, "max", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], NumericElement.prototype, "step", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.observable,
            tslib_1.__metadata("design:type", String)
        ], NumericElement.prototype, "inputValue", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.computedFrom('inputValue'),
            tslib_1.__metadata("design:type", Boolean),
            tslib_1.__metadata("design:paramtypes", [])
        ], NumericElement.prototype, "validInputValue", null);
        tslib_1.__decorate([
            aurelia_framework_1.computedFrom('inputValue', 'max'),
            tslib_1.__metadata("design:type", Boolean),
            tslib_1.__metadata("design:paramtypes", [])
        ], NumericElement.prototype, "canIncrease", null);
        tslib_1.__decorate([
            aurelia_framework_1.computedFrom('inputValue', 'min'),
            tslib_1.__metadata("design:type", Boolean),
            tslib_1.__metadata("design:paramtypes", [])
        ], NumericElement.prototype, "canDecrease", null);
        return NumericElement;
    }());
    exports.NumericElement = NumericElement;
});

define('zlib', [],function() { return window.vantage.nodeModules.zlib; });
/**
 * @license text 2.0.15 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.15',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('libvantage/index',["require", "exports", "tslib", "./vantage", "./crypto/index", "./io/index", "./compression/index"], function (require, exports, tslib_1, vantage_1, index_1, index_2, index_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    tslib_1.__exportStar(vantage_1, exports);
    tslib_1.__exportStar(index_1, exports);
    tslib_1.__exportStar(index_2, exports);
    tslib_1.__exportStar(index_3, exports);
    /**
     * Register the library with Aurelia.
     * @param config The Aurelia framework configuration
     */
    function configure(config) {
        config.globalResources([
            './resources/elements/v-button',
            './resources/elements/v-number',
            './resources/elements/v-selection',
            './resources/elements/v-slider',
            './resources/elements/v-switch',
            './resources/elements/v-text',
            './resources/elements/v-tree',
            './resources/elements/card',
            './resources/value-converters/array',
            './resources/value-converters/number',
            './resources/value-converters/object',
        ]);
    }
    exports.configure = configure;
});

;define('libvantage', ['libvantage/index'], function (main) { return main; });

define('text!libvantage/vantage.css', ['module'], function(module) { module.exports = "@font-face {\n  font-family: 'Montserrat';\n  font-style: normal;\n  font-weight: 700;\n  src: local(\"Montserrat Bold\"), local(\"Montserrat-Bold\"), url(data:application/font-woff2;charset=utf-8;base64,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) format(\"woff2\");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215; }\n\n@font-face {\n  font-family: 'Lato';\n  font-style: normal;\n  font-weight: 700;\n  src: local(\"Lato Bold\"), local(\"Lato-Bold\"), url(data:application/font-woff2;charset=utf-8;base64,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) format(\"woff2\");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215; }\n\n@font-face {\n  font-family: 'Lato';\n  font-style: normal;\n  font-weight: 900;\n  src: local(\"Lato Black\"), local(\"Lato-Black\"), url(data:application/font-woff2;charset=utf-8;base64,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) format(\"woff2\");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215; }\n\n@font-face {\n  font-family: 'Lato';\n  font-style: normal;\n  font-weight: 400;\n  src: local(\"Lato Regular\"), local(\"Lato-Regular\"), url(data:application/font-woff2;charset=utf-8;base64,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) format(\"woff2\");\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215; }\n\n.hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\nbody {\n  margin: 0;\n  padding: 0 0 24px 0;\n  width: 100%; }\n  body::-webkit-scrollbar {\n    background-color: #EFF1F3;\n    width: 10px;\n    box-shadow: inset 2px 2px 5px 0px rgba(0, 0, 0, 0.3); }\n  body::-webkit-scrollbar-thumb:window-inactive, body::-webkit-scrollbar-thumb {\n    background: #617282; }\n    body::-webkit-scrollbar-thumb:window-inactive:hover, body::-webkit-scrollbar-thumb:hover {\n      background: #6c7e90; }\n\n* {\n  cursor: default;\n  box-sizing: border-box;\n  -webkit-user-select: none;\n  font-family: Lato; }\n\na, img {\n  -webkit-user-drag: none; }\n\na, a *, button, button * {\n  cursor: pointer;\n  outline: none; }\n\ninput[type=text], input[type=password] {\n  cursor: initial; }\n\nheader {\n  display: block;\n  height: 40px;\n  line-height: 40px;\n  background: #31b24a;\n  opacity: 0.75;\n  padding: 0 24px;\n  margin: 24px 0;\n  font-weight: 900;\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.8);\n  letter-spacing: 2px;\n  text-transform: uppercase; }\n  header:first-child {\n    margin-top: 0; }\n\ntable {\n  table-layout: fixed;\n  font-size: 14px;\n  padding: 0;\n  border-collapse: separate;\n  border-spacing: 0; }\n  table td, table th {\n    font-size: 14px;\n    vertical-align: middle;\n    padding: 1px 0 0 24px;\n    text-align: left;\n    margin: 0; }\n    table td:last-child, table th:last-child {\n      padding-right: 24px; }\n  table thead th {\n    color: rgba(41, 86, 102, 0.5);\n    text-transform: uppercase;\n    font-weight: 900;\n    font-size: 10px;\n    letter-spacing: 2px;\n    height: 45px;\n    border-bottom: 2px solid #e9ebed; }\n  table tr td {\n    height: 45px;\n    border-bottom: 1px solid #e9ebed;\n    font-size: 12px;\n    color: #295666;\n    letter-spacing: 0.76px; }\n"; });
define('libvantage/resources/elements/card',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CardCustomElement = /** @class */ (function () {
        function CardCustomElement() {
        }
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], CardCustomElement.prototype, "label", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], CardCustomElement.prototype, "height", void 0);
        return CardCustomElement;
    }());
    exports.CardCustomElement = CardCustomElement;
});

define('text!libvantage/resources/elements/card.html', ['module'], function(module) { module.exports = "<template class=\"${label ? 'with-label' : 'without-label'}\">\r\n    <require from=\"./card.css\"></require>\r\n\r\n    <div class=\"card-wrapper\" css.bind=\"{maxHeight: height ? height : 'auto', overflowY: height ? 'auto' : 'visible'}\">\r\n    \t<label if.bind=\"label\" class=\"card-label\">${label}</label>\r\n    \t<slot></slot>\r\n    </div>\r\n</template>"; });
define('text!libvantage/resources/elements/card.css', ['module'], function(module) { module.exports = ".hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\ncard {\n  display: block;\n  position: relative; }\n  card .card-wrapper {\n    position: relative;\n    background: #fff;\n    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.16);\n    margin: 16px 24px 0 24px;\n    align-items: center;\n    display: flex;\n    padding: 21px 24px; }\n  card.with-label .card-wrapper > * {\n    margin-left: 10px; }\n  card.with-label .card-wrapper > :first-child, card.with-label .card-wrapper > :nth-child(2) {\n    margin-left: 0; }\n  card.with-label label.card-label {\n    font-weight: bold;\n    font-size: 12px;\n    color: #02394A;\n    letter-spacing: 0.5px;\n    flex: 1; }\n  card.without-label .card-wrapper {\n    overflow-y: auto;\n    overflow-x: visible;\n    display: block; }\n    card.without-label .card-wrapper::-webkit-scrollbar {\n      background-color: #EFF1F3;\n      width: 10px;\n      box-shadow: inset 2px 2px 5px 0px rgba(0, 0, 0, 0.3); }\n    card.without-label .card-wrapper::-webkit-scrollbar-thumb:window-inactive, card.without-label .card-wrapper::-webkit-scrollbar-thumb {\n      background: #617282; }\n      card.without-label .card-wrapper::-webkit-scrollbar-thumb:window-inactive:hover, card.without-label .card-wrapper::-webkit-scrollbar-thumb:hover {\n        background: #6c7e90; }\n  card table {\n    margin: -16px -24px 2px -24px;\n    width: calc(100% + 48px); }\n\nbody.disabled card:before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  background: rgba(255, 255, 255, 0.4); }\n"; });
define('libvantage/resources/elements/v-button',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VButtonCustomElement = /** @class */ (function () {
        function VButtonCustomElement() {
        }
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Boolean)
        ], VButtonCustomElement.prototype, "disabled", void 0);
        return VButtonCustomElement;
    }());
    exports.VButtonCustomElement = VButtonCustomElement;
});

define('text!libvantage/resources/elements/v-button.html', ['module'], function(module) { module.exports = "<template class=\"${disabled ? 'disabled' : ''}\">\r\n\t<require from=\"./v-button.css\"></require>\r\n\r\n\t<slot></slot>\r\n</template>"; });
define('text!libvantage/resources/elements/v-button.css', ['module'], function(module) { module.exports = ".hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis, v-button {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\nv-button {\n  display: inline-block;\n  max-width: 100%;\n  border-radius: 3px;\n  background: #39AF45;\n  height: 30px;\n  font-weight: 900;\n  font-size: 12px;\n  color: #fff;\n  letter-spacing: 0.5px;\n  line-height: 30px;\n  padding: 0 13px;\n  border: 0;\n  transition: background 0.15s;\n  cursor: pointer; }\n  v-button:hover {\n    background: #54c760; }\n  v-button.disabled {\n    pointer-events: none;\n    opacity: 0.5; }\n"; });
define('libvantage/resources/elements/v-number',["require", "exports", "tslib", "aurelia-framework", "./numeric-element"], function (require, exports, tslib_1, aurelia_framework_1, numeric_element_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VNumberCustomElement = /** @class */ (function (_super) {
        tslib_1.__extends(VNumberCustomElement, _super);
        function VNumberCustomElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Number)
        ], VNumberCustomElement.prototype, "value", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VNumberCustomElement.prototype, "placeholder", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VNumberCustomElement.prototype, "min", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VNumberCustomElement.prototype, "max", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], VNumberCustomElement.prototype, "step", void 0);
        return VNumberCustomElement;
    }(numeric_element_1.NumericElement));
    exports.VNumberCustomElement = VNumberCustomElement;
});

define('text!libvantage/resources/elements/v-number.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-number.css\"></require>\r\n\t<require from=\"../images/minus-svg.html\"></require>\r\n\t<require from=\"../images/plus-svg.html\"></require>\r\n\r\n    <button disabled.bind=\"!canDecrease\" click.delegate=\"decrease()\" class=\"decrement\">\r\n    \t<i><minus-svg></minus-svg></i>\r\n    </button>\r\n    <input type=\"number\" placeholder.bind=\"placeholder\" value.bind=\"inputValue\" min.bind=\"min\" max.bind=\"max\" step.bind=\"step\">\r\n    <button disabled.bind=\"!canIncrease\" click.delegate=\"increase()\" class=\"increment\">\r\n    \t<i><plus-svg></plus-svg></i>\r\n    </button>\r\n</template>\r\n"; });
define('text!libvantage/resources/elements/v-number.css', ['module'], function(module) { module.exports = "v-number {\n  position: relative;\n  display: inline-block; }\n  v-number input {\n    display: inline-block;\n    width: 125px;\n    height: 30px;\n    border-radius: 1.5px;\n    border: 1px solid #D4D8DC;\n    background: transparent;\n    padding: 0 30px;\n    font-size: 12.5px;\n    color: #295666;\n    letter-spacing: 0;\n    text-align: center;\n    outline: none;\n    cursor: initial; }\n    v-number input::-webkit-inner-spin-button {\n      -webkit-appearance: none;\n      opacity: 0; }\n  v-number button {\n    position: absolute;\n    top: 2px;\n    width: 26px;\n    height: 26px;\n    background: #39AF45;\n    border-radius: 2px;\n    border: 0;\n    outline: none;\n    cursor: pointer; }\n    v-number button svg {\n      width: 8px;\n      height: 8px;\n      transform: translate(0, -1px); }\n      v-number button svg * {\n        fill: #fff; }\n    v-number button:hover {\n      background: #54c760; }\n    v-number button:disabled {\n      cursor: not-allowed;\n      opacity: 0.5; }\n      v-number button:disabled i {\n        cursor: not-allowed; }\n        v-number button:disabled i * {\n          cursor: not-allowed; }\n      v-number button:disabled:hover {\n        background: #39AF45; }\n  v-number button.increment {\n    right: 2px; }\n  v-number button.decrement {\n    left: 2px; }\n"; });
define('libvantage/resources/elements/v-selection',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VSelectionCustomElement = /** @class */ (function () {
        function VSelectionCustomElement() {
            this.open = false;
        }
        VSelectionCustomElement.prototype.bind = function () {
            this.valueChanged();
        };
        VSelectionCustomElement.prototype.select = function (option) {
            this.selectedOption = option;
            this.open = false;
        };
        VSelectionCustomElement.prototype.selectedOptionChanged = function () {
            this.value = this.selectedOption ? this.selectedOption.value : null;
        };
        VSelectionCustomElement.prototype.valueChanged = function () {
            var _this = this;
            this.selectedOption = (this.options && this.options.find(function (option) { return _this.value == option.value; })) || {
                label: this.value,
                value: this.value,
            };
        };
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Object)
        ], VSelectionCustomElement.prototype, "value", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Array)
        ], VSelectionCustomElement.prototype, "options", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.observable,
            tslib_1.__metadata("design:type", Object)
        ], VSelectionCustomElement.prototype, "selectedOption", void 0);
        return VSelectionCustomElement;
    }());
    exports.VSelectionCustomElement = VSelectionCustomElement;
});

define('text!libvantage/resources/elements/v-selection.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-selection.css\"></require>\r\n\t<require from=\"../images/caret-down-svg.html\"></require>\r\n\r\n    <div class=\"select ${open ? 'open' : ''}\" close-if-click-outside.two-way=\"open\">\r\n        <div class=\"value\" click.delegate=\"open = !open\">${selectedOption.label}</div>\r\n        <div class=\"options\">\r\n            <div repeat.for=\"option of options\" click.delegate=\"select(option)\" class=\"option\">${option.label}</div>\r\n        </div>\r\n        <i class=\"select-arrow\"><caret-down-svg></caret-down-svg></i>\r\n    </div>\r\n</template>"; });
define('text!libvantage/resources/elements/v-selection.css', ['module'], function(module) { module.exports = ".hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis, v-selection .select .value, v-selection .select .option {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\nv-selection {\n  display: inline-block;\n  width: 100%;\n  max-width: 150px;\n  min-width: 75px; }\n  v-selection .select {\n    height: 30px;\n    width: 100%;\n    position: relative;\n    background: #fff; }\n    v-selection .select * {\n      cursor: pointer; }\n    v-selection .select .value, v-selection .select .option {\n      height: 30px;\n      width: 100%;\n      padding: 0 16px;\n      font-size: 12px;\n      color: #02394A;\n      letter-spacing: 0.5px;\n      line-height: 30px; }\n    v-selection .select .value {\n      padding-right: 40px;\n      border-radius: 3px;\n      transition: border-radius 0.3s;\n      border: 1px solid #c0c0c0;\n      border-radius: 3px; }\n    v-selection .select .select-arrow {\n      pointer-events: none;\n      position: absolute;\n      right: 10px;\n      top: 3px; }\n      v-selection .select .select-arrow svg * {\n        fill: #526173; }\n    v-selection .select .options {\n      border: 1px solid #c0c0c0;\n      position: absolute;\n      left: 0;\n      top: 29px;\n      z-index: 1;\n      width: 100%;\n      max-height: 200px;\n      overflow-x: hidden;\n      overflow-y: auto;\n      visibility: hidden;\n      opacity: 0;\n      border-bottom-right-radius: 3px;\n      border-bottom-left-radius: 3px;\n      transition: opacity 0.3s, visibility 0s linear 0.3s; }\n      v-selection .select .options::-webkit-scrollbar {\n        background-color: white;\n        width: 10px;\n        box-shadow: inset 2px 2px 5px 0px rgba(0, 0, 0, 0.3); }\n      v-selection .select .options::-webkit-scrollbar-thumb:window-inactive, v-selection .select .options::-webkit-scrollbar-thumb {\n        background: #c0c0c0; }\n        v-selection .select .options::-webkit-scrollbar-thumb:window-inactive:hover, v-selection .select .options::-webkit-scrollbar-thumb:hover {\n          background: #cdcdcd; }\n      v-selection .select .options .option {\n        background: #fff; }\n        v-selection .select .options .option:hover {\n          background: #efefef; }\n    v-selection .select:hover .select-arrow svg * {\n      fill: #000; }\n    v-selection .select.open .value {\n      border-bottom-left-radius: 0;\n      border-bottom-right-radius: 0; }\n    v-selection .select.open .options {\n      opacity: 1;\n      visibility: visible;\n      transition-delay: 0s; }\n"; });
define('libvantage/resources/elements/v-slider',["require", "exports", "tslib", "aurelia-framework", "./numeric-element"], function (require, exports, tslib_1, aurelia_framework_1, numeric_element_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VSliderCustomElement = /** @class */ (function (_super) {
        tslib_1.__extends(VSliderCustomElement, _super);
        function VSliderCustomElement() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.label = 'No Value';
            return _this;
        }
        VSliderCustomElement.prototype.attached = function () {
            this.refreshLabel();
        };
        VSliderCustomElement.prototype.valueChanged = function (value) {
            _super.prototype.valueChanged.call(this, value);
            this.refreshLabel();
        };
        VSliderCustomElement.prototype.inputValueChanged = function (value) {
            _super.prototype.inputValueChanged.call(this, value);
            this.refreshLabel();
        };
        VSliderCustomElement.prototype.refreshLabel = function () {
            if (this.labelElement) {
                if (!this.inputValue || this.inputValue === 'NaN') {
                    this.label = 'N/A';
                    this.labelElement.style.marginLeft = '50%';
                }
                else {
                    var min = parseFloat(this.min);
                    var max = parseFloat(this.max);
                    this.labelElement.style.marginLeft = ((parseFloat(this.inputValue) - min) / (max - min) * 100) + '%';
                    this.label = this.inputValue;
                    // Add correct precision to value string.
                    if (this.label.indexOf('.') === -1) {
                        var decimalIndex = this.step.toString().indexOf('.');
                        if (decimalIndex !== -1) {
                            this.label += '.' + '0'.repeat(this.step.toString().length - decimalIndex - 1);
                        }
                    }
                }
            }
        };
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Number)
        ], VSliderCustomElement.prototype, "value", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VSliderCustomElement.prototype, "placeholder", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VSliderCustomElement.prototype, "min", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VSliderCustomElement.prototype, "max", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", Object)
        ], VSliderCustomElement.prototype, "step", void 0);
        return VSliderCustomElement;
    }(numeric_element_1.NumericElement));
    exports.VSliderCustomElement = VSliderCustomElement;
});

define('text!libvantage/resources/elements/v-slider.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-slider.css\"></require>\r\n\r\n\t<input type=\"range\" min.bind=\"min\" max.bind=\"max\" step.bind=\"step\" value.bind=\"inputValue\">\r\n\t<div class=\"label-wrapper\">\r\n\t\t<label ref=\"labelElement\">${label}</label>\r\n\t</div>\r\n</template>"; });
define('text!libvantage/resources/elements/v-slider.css', ['module'], function(module) { module.exports = "v-slider {\n  position: relative;\n  display: inline-block;\n  width: 100%;\n  max-width: 180px; }\n  v-slider input[type=range] {\n    -webkit-appearance: none;\n    background: transparent;\n    cursor: pointer;\n    width: 100%;\n    margin: 0; }\n    v-slider input[type=range]::-webkit-slider-thumb {\n      -webkit-appearance: none;\n      width: 13px;\n      height: 13px;\n      background-color: #40AC3F;\n      border-radius: 50%;\n      margin: -5px 0 0 0;\n      padding: 0;\n      transition: background-color 0.15s; }\n      v-slider input[type=range]::-webkit-slider-thumb:hover {\n        background-color: #5cc35b;\n        cursor: url(data:application/octet-stream;base64,AAACAAEAICACAAcABQAwAQAAFgAAACgAAAAgAAAAQAAAAAEAAQAAAAAAAAEAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAfwAAAP+AAAH/gAAB/8AAA//AAAd/wAAGf+AAAH9gAADbYAAA2yAAAZsAAAGbAAAAGAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////gH///4B///8Af//+AD///AA///wAH//4AB//8AAf//AAD//5AA///gAP//4AD//8AF///AB///5A////5///8=), default; }\n      v-slider input[type=range]::-webkit-slider-thumb:active:hover {\n        cursor: url(data:application/octet-stream;base64,AAACAAEAICACAAcABQAwAQAAFgAAACgAAAAgAAAAQAAAAAEAAQAAAAAAAAEAAAAAAAAAAAAAAgAAAAAAAAAAAAAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAfwAAAP+AAAH/gAAB/8AAAH/AAAB/wAAA/0AAANsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////////////////////////////////////////////////////////////////////////////gH///4B///8Af//+AD///AA///wAH//+AB///wAf//4AH//+AD///yT/////////////////////////////8=), default; }\n    v-slider input[type=range]::-webkit-slider-runnable-track {\n      width: 100%;\n      height: 3px;\n      border-radius: 3px;\n      background: rgba(41, 86, 102, 0.25);\n      margin: 0;\n      padding: 0; }\n    v-slider input[type=range]:focus {\n      outline: none; }\n  v-slider .label-wrapper {\n    margin: 3px 7px 0 6.5px;\n    text-align: initial; }\n  v-slider label {\n    font-family: Montserrat;\n    font-weight: bold;\n    display: inline-block;\n    font-size: 10px;\n    color: #295666;\n    letter-spacing: 0.25px;\n    text-align: center;\n    transform: translate(-50%, 0); }\n"; });
define('libvantage/resources/elements/v-switch',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VSwitchCustomElement = /** @class */ (function () {
        function VSwitchCustomElement() {
        }
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Boolean)
        ], VSwitchCustomElement.prototype, "value", void 0);
        return VSwitchCustomElement;
    }());
    exports.VSwitchCustomElement = VSwitchCustomElement;
});

define('text!libvantage/resources/elements/v-switch.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-switch.css\"></require>\r\n\r\n\t<div class=\"switch ${value ? 'on' : 'off'}\" click.delegate=\"value = !value\"></div>\r\n</template>"; });
define('text!libvantage/resources/elements/v-switch.css', ['module'], function(module) { module.exports = "v-switch .switch {\n  display: flex;\n  width: 38px;\n  height: 24px;\n  border: 3px solid #39AF45;\n  border-radius: 12px;\n  position: relative;\n  transition: border-color 0.15s; }\n  v-switch .switch, v-switch .switch * {\n    cursor: pointer; }\n  v-switch .switch:before {\n    content: \"\";\n    display: block;\n    width: 15px;\n    height: 15px;\n    position: absolute;\n    left: 2px;\n    top: 2px;\n    background: #39AF45;\n    border-radius: 7.5px;\n    transition: left 0.15s, background-color 0.15s; }\n  v-switch .switch.on:before {\n    left: 15px; }\n  v-switch .switch:hover {\n    border-color: #54c760; }\n    v-switch .switch:hover:before {\n      background-color: #54c760; }\n"; });
define('libvantage/resources/elements/v-text',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VTextCustomElement = /** @class */ (function () {
        function VTextCustomElement() {
        }
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", String)
        ], VTextCustomElement.prototype, "value", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VTextCustomElement.prototype, "placeholder", void 0);
        tslib_1.__decorate([
            aurelia_framework_1.bindable,
            tslib_1.__metadata("design:type", String)
        ], VTextCustomElement.prototype, "style", void 0);
        return VTextCustomElement;
    }());
    exports.VTextCustomElement = VTextCustomElement;
});

define('text!libvantage/resources/elements/v-text.html', ['module'], function(module) { module.exports = "<template bindable=\"value\">\r\n\t<require from=\"./v-text.css\"></require>\r\n\r\n\t<input type=\"text\" css.bind=\"style\" placeholder.bind=\"placeholder || ''\" value.bind=\"value\">\r\n</template>"; });
define('text!libvantage/resources/elements/v-text.css', ['module'], function(module) { module.exports = "v-text input {\n  display: inline-block;\n  height: 30px;\n  max-width: 150px;\n  color: #02394A;\n  border: 1px solid rgba(0, 0, 0, 0.25);\n  border-radius: 3px;\n  padding: 0 12px;\n  outline: none; }\n"; });
define('libvantage/resources/elements/v-tree-node',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VTreeNodeCustomElement = /** @class */ (function () {
        function VTreeNodeCustomElement() {
            this.expanded = false;
        }
        VTreeNodeCustomElement.prototype.toggle = function () {
            this.expanded = !this.expanded;
        };
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Object)
        ], VTreeNodeCustomElement.prototype, "node", void 0);
        return VTreeNodeCustomElement;
    }());
    exports.VTreeNodeCustomElement = VTreeNodeCustomElement;
});

define('text!libvantage/resources/elements/v-tree-node.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-tree-node.css\"></require>\r\n\t<require from=\"../images/minus-svg.html\"></require>\r\n\t<require from=\"../images/plus-svg.html\"></require>\r\n\r\n\t<div class=\"node ${expanded ? 'expanded' : ''} ${node.nodes.length ? 'expandable' : ''}\">\r\n\t\t<div class=\"node-wrapper\">\r\n\t\t\t<div class=\"icon\" if.bind=\"node.nodes.length\" click.delegate=\"toggle()\">\r\n\t\t\t\t<i if.bind=\"!expanded\"><plus-svg></plus-svg></i>\r\n\t\t\t\t<i if.bind=\"expanded\"><minus-svg></minus-svg></i>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div class=\"name\" click.delegate=\"toggle()\">${node.name}</div>\r\n\r\n\t\t\t<div class=\"component\" if.bind=\"node.component\">\r\n\t\t\t\t<v-button\r\n\t\t\t\t\tif.bind=\"node.component.type == 'button'\"\r\n\t\t\t\t\tdisabled.bind=\"node.component.disabled\"\r\n\t\t\t\t\tclick.delegate=\"node.component.callback()\">${node.component.label}</v-button>\r\n\r\n\t\t\t\t<v-number\r\n\t\t\t\t\tif.bind=\"node.component.type == 'number'\"\r\n\t\t\t\t\tvalue.bind=\"node.component.value\"\r\n\t\t\t\t\tmin.bind=\"node.component.min\"\r\n\t\t\t\t\tmax.bind=\"node.component.max\"\r\n\t\t\t\t\tplaceholder=\"node.component.placeholder\"\r\n\t\t\t\t\tstep.bind=\"node.component.step\"></v-number>\r\n\r\n\t\t\t\t<v-selection\r\n\t\t\t\t\tif.bind=\"node.component.type == 'selection'\"\r\n\t\t\t\t\tvalue.bind=\"node.component.value\"\r\n\t\t\t\t\toptions.bind=\"node.component.options\"></v-selection>\r\n\r\n\t\t\t\t<v-slider\r\n\t\t\t\t\tif.bind=\"node.component.type == 'slider'\"\r\n\t\t\t\t\tvalue.bind=\"node.component.value\"\r\n\t\t\t\t\tmin.bind=\"node.component.min\"\r\n\t\t\t\t\tmax.bind=\"node.component.max\"\r\n\t\t\t\t\tstep.bind=\"node.component.step\"></v-slider>\r\n\r\n\t\t\t\t<v-switch\r\n\t\t\t\t\tif.bind=\"node.component.type == 'switch'\"\r\n\t\t\t\t\tvalue.bind=\"node.component.value\"></v-switch>\r\n\r\n\t\t\t\t<v-text\r\n\t\t\t\t\tif.bind=\"node.component.type == 'text'\"\r\n\t\t\t\t\tvalue.bind=\"node.component.value\"\r\n\t\t\t\t\ttype=\"text\"></v-text>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\r\n\t\t<div class=\"nodes\">\r\n\t\t\t<div class=\"nodes-wrapper\">\r\n\t\t\t\t<v-tree-node repeat.for=\"node of node.nodes\" node.bind=\"node\"></v-tree-node>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</template>"; });
define('text!libvantage/resources/elements/v-tree-node.css', ['module'], function(module) { module.exports = ".hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis, v-tree-node .node .node-wrapper .name {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\nv-tree-node {\n  display: block; }\n  v-tree-node .node .node-wrapper {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    height: 30px;\n    margin: 3px 0; }\n    v-tree-node .node .node-wrapper .icon {\n      flex: 0;\n      padding-right: 24px;\n      display: inline-block;\n      width: 42px;\n      height: 18px; }\n      v-tree-node .node .node-wrapper .icon svg {\n        width: 18px;\n        height: 18px; }\n        v-tree-node .node .node-wrapper .icon svg * {\n          fill: #295666; }\n    v-tree-node .node .node-wrapper .name {\n      flex: 1;\n      font-size: 12px;\n      line-height: 30px;\n      color: #295666;\n      letter-spacing: 0.76px; }\n    v-tree-node .node .node-wrapper .component {\n      flex: 0;\n      min-width: 150px;\n      text-align: right; }\n  v-tree-node .node > .nodes {\n    max-height: 0px;\n    padding-left: 42px;\n    overflow: hidden;\n    opacity: 0;\n    transition: max-height 0.5s cubic-bezier(0, 1, 0, 1), opacity 0.5s linear; }\n  v-tree-node .node.expandable > .node-wrapper .icon, v-tree-node .node.expandable > .node-wrapper .icon *, v-tree-node .node.expandable > .node-wrapper .name, v-tree-node .node.expandable > .node-wrapper .name * {\n    cursor: pointer; }\n  v-tree-node .node.expandable > .node-wrapper:hover .icon svg * {\n    fill: black; }\n  v-tree-node .node.expandable > .node-wrapper:hover .name {\n    color: black; }\n  v-tree-node .node:not(.expandable) {\n    padding-left: 42px; }\n  v-tree-node .node.expandable.expanded > .node-wrapper .name {\n    color: #39AF45; }\n  v-tree-node .node.expandable.expanded > .node-wrapper .icon svg * {\n    fill: #39AF45; }\n  v-tree-node .node.expandable.expanded > .nodes {\n    max-height: 1000px;\n    opacity: 1;\n    overflow: visible;\n    transition-timing-function: ease-in; }\n"; });
define('libvantage/resources/elements/v-tree',["require", "exports", "tslib", "aurelia-framework"], function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VTreeCustomElement = /** @class */ (function () {
        function VTreeCustomElement() {
        }
        VTreeCustomElement.prototype.filterNodesRecursive = function (predicate, nodes, matches) {
            var _this = this;
            if (nodes) {
                nodes.forEach(function (node) {
                    if (predicate(node)) {
                        matches.push(node);
                    }
                    _this.filterNodesRecursive(predicate, nodes, matches);
                });
            }
            return matches;
        };
        VTreeCustomElement.prototype.filterNodes = function (predicate) {
            return this.filterNodesRecursive(predicate, this.nodes, []);
        };
        VTreeCustomElement.prototype.findNodeRecursive = function (predicate, nodes) {
            if (!nodes) {
                return null;
            }
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                if (predicate(node)) {
                    return node;
                }
                var match = this.findNodeRecursive(predicate, node.nodes);
                if (match) {
                    return match;
                }
            }
            return null;
        };
        VTreeCustomElement.prototype.findNode = function (predicate) {
            return this.findNodeRecursive(predicate, this.nodes);
        };
        VTreeCustomElement.prototype.findNodeById = function (id) {
            return this.findNode(function (n) { return n.id === id; });
        };
        VTreeCustomElement.prototype.findNodeByPathRecursive = function (nodes, path) {
            if (!path || !path.length || !nodes) {
                return null;
            }
            var currentId = path.shift();
            var node = nodes.find(function (n) { return n.id === currentId; });
            if (!node) {
                return null;
            }
            if (!path.length) {
                return node;
            }
            for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                var node_1 = nodes_2[_i];
                var match = this.findNodeByPathRecursive(node_1.nodes, path);
                if (match) {
                    return match;
                }
            }
            return null;
        };
        VTreeCustomElement.prototype.findNodeByPath = function (path) {
            return this.findNodeByPathRecursive(this.nodes, typeof path === 'string' ? path.split('.') : path);
        };
        tslib_1.__decorate([
            aurelia_framework_1.bindable({ defaultBindingMode: aurelia_framework_1.bindingMode.twoWay }),
            tslib_1.__metadata("design:type", Array)
        ], VTreeCustomElement.prototype, "nodes", void 0);
        return VTreeCustomElement;
    }());
    exports.VTreeCustomElement = VTreeCustomElement;
});

define('text!libvantage/resources/elements/v-tree.html', ['module'], function(module) { module.exports = "<template>\r\n\t<require from=\"./v-tree.css\"></require>\r\n\t<require from=\"./v-tree-node\"></require>\r\n\r\n\t<v-tree-node repeat.for=\"node of nodes\" node.bind=\"node\"></v-tree-node>\r\n</template>"; });
define('text!libvantage/resources/elements/v-tree.css', ['module'], function(module) { module.exports = ".hide {\n  display: none !important; }\n\n.clearfix:after {\n  content: \"\";\n  display: block;\n  clear: both; }\n\n.ellipsis {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden; }\n\nv-tree::-webkit-scrollbar {\n  background-color: #EFF1F3;\n  width: 10px;\n  box-shadow: inset 2px 2px 5px 0px rgba(0, 0, 0, 0.3); }\n\nv-tree::-webkit-scrollbar-thumb:window-inactive, v-tree::-webkit-scrollbar-thumb {\n  background: #617282; }\n  v-tree::-webkit-scrollbar-thumb:window-inactive:hover, v-tree::-webkit-scrollbar-thumb:hover {\n    background: #6c7e90; }\n"; });
define('libvantage/resources/value-converters/array',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PluckValueConverter = /** @class */ (function () {
        function PluckValueConverter() {
        }
        PluckValueConverter.prototype.toView = function (value, prop, def) {
            return value ? value.map(function (v) { return v.hasOwnProperty(prop) ? v[prop] : def; }) : [];
        };
        return PluckValueConverter;
    }());
    exports.PluckValueConverter = PluckValueConverter;
    var TakeValueConverter = /** @class */ (function () {
        function TakeValueConverter() {
        }
        TakeValueConverter.prototype.toView = function (value, count) {
            return value && value.length != 0 ? value.slice(0, count) : [];
        };
        return TakeValueConverter;
    }());
    exports.TakeValueConverter = TakeValueConverter;
    var SortValueConverter = /** @class */ (function () {
        function SortValueConverter() {
        }
        SortValueConverter.prototype.toView = function (value, prop) {
            if (!value || value.length === 0) {
                return [];
            }
            if (!prop) {
                return value.sort();
            }
            if (typeof value[0][prop] === 'number') {
                return value.sort(function (a, b) { return a[prop] > b[prop] ? 1 : (a[prop] < b[prop] ? -1 : 0); });
            }
            return value.sort(function (a, b) { return a[prop] && b[prop] ? a[prop].toString().localeCompare(b[prop].toString()) : 0; });
        };
        return SortValueConverter;
    }());
    exports.SortValueConverter = SortValueConverter;
});

define('libvantage/resources/value-converters/number',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FormatNumberValueConverter = /** @class */ (function () {
        function FormatNumberValueConverter() {
        }
        FormatNumberValueConverter.prototype.toView = function (value) {
            return value.toString().replace(/(\d)(?=(\d{3})+$)/g, '$1,');
        };
        FormatNumberValueConverter.prototype.fromView = function (value) {
            return parseFloat(value.replace(/,/, ''));
        };
        return FormatNumberValueConverter;
    }());
    exports.FormatNumberValueConverter = FormatNumberValueConverter;
    var sizeStrings = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB', 'WTF'];
    var ByteFormatValueConverter = /** @class */ (function () {
        function ByteFormatValueConverter() {
        }
        ByteFormatValueConverter.prototype.toView = function (value, fractionDigits) {
            if (fractionDigits === void 0) { fractionDigits = 2; }
            if (value === 0) {
                return "0 " + sizeStrings[0];
            }
            var x = Math.floor(Math.log(value) / Math.log(1024));
            return parseFloat((value / Math.pow(1024, x)).toFixed(fractionDigits)) + ' ' + sizeStrings[x];
        };
        return ByteFormatValueConverter;
    }());
    exports.ByteFormatValueConverter = ByteFormatValueConverter;
});

define('libvantage/resources/value-converters/object',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ObjectKeysValueConverter = /** @class */ (function () {
        function ObjectKeysValueConverter() {
        }
        ObjectKeysValueConverter.prototype.toView = function (value) {
            return value ? Object.getOwnPropertyNames(value).filter(function (k) { return !k.startsWith('__'); }) : [];
        };
        return ObjectKeysValueConverter;
    }());
    exports.ObjectKeysValueConverter = ObjectKeysValueConverter;
});

define('text!libvantage/resources/images/caret-down-svg.html', ['module'], function(module) { module.exports = "<template>\r\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\t<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n\t<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0\" y=\"0\" width=\"10\" height=\"6\" viewBox=\"0, 0, 10, 6\">\r\n\t  <g id=\"Vantage\">\r\n\t    <path d=\"M1.502,0 L0,1.386 L5,6 L10,1.386 L8.498,0 L5,3.228 z\" fill=\"#FFFFFF\" fill-opacity=\"0.5\"/>\r\n\t  </g>\r\n\t</svg>\r\n</template>\r\n"; });
define('text!libvantage/resources/images/minus-svg.html', ['module'], function(module) { module.exports = "<template>\r\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\t<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n\t<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0\" y=\"0\" width=\"11\" height=\"11\" viewBox=\"0, 0, 11, 11\">\r\n\t  <g id=\"Vantage\">\r\n\t    <path d=\"M0.339,5.996 C0.475,6.132 0.631,6.21 0.825,6.21 L4.813,6.186 L6.175,6.185 L10.184,6.182 C10.573,6.181 10.884,5.87 10.865,5.5 C10.865,5.111 10.554,4.8 10.185,4.82 L6.177,4.823 L4.815,4.825 L0.807,4.828 C0.437,4.809 0.125,5.121 0.125,5.51 C0.125,5.704 0.203,5.86 0.339,5.996 z\" fill=\"#FFFFFF\" id=\"Fill-2\"/>\r\n\t  </g>\r\n\t</svg>\r\n</template>\r\n"; });
define('text!libvantage/resources/images/plus-svg.html', ['module'], function(module) { module.exports = "<template>\r\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\t<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n\t<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0\" y=\"0\" width=\"11\" height=\"11\" viewBox=\"0, 0, 11, 11\">\r\n\t  <g id=\"Vantage\">\r\n\t    <path d=\"M0.139,5.505 C0.138,5.699 0.216,5.854 0.352,5.99 C0.487,6.125 0.642,6.203 0.837,6.202 L4.818,6.172 L4.808,10.173 C4.807,10.368 4.885,10.523 5.02,10.658 C5.156,10.794 5.311,10.871 5.505,10.871 C5.894,10.87 6.206,10.558 6.187,10.189 L6.178,6.169 L10.179,6.158 C10.567,6.157 10.879,5.845 10.86,5.477 C10.861,5.088 10.551,4.778 10.182,4.799 L6.181,4.809 L6.192,0.808 C6.193,0.42 5.882,0.109 5.514,0.13 C5.125,0.131 4.813,0.443 4.832,0.812 L4.822,4.813 L0.82,4.823 C0.452,4.804 0.14,5.116 0.139,5.505 L0.139,5.505 z\" fill=\"#FFFFFF\" id=\"Fill-2\"/>\r\n\t  </g>\r\n\t</svg>\r\n</template>\r\n"; });
function _aureliaConfigureModuleLoader(){requirejs.config({"baseUrl":"src/","paths":{"root":"src","tslib":"..\\node_modules\\tslib\\tslib","aurelia-binding":"..\\node_modules\\aurelia-binding\\dist\\amd\\aurelia-binding","aurelia-bootstrapper":"..\\node_modules\\aurelia-bootstrapper\\dist\\amd\\aurelia-bootstrapper","aurelia-dependency-injection":"..\\node_modules\\aurelia-dependency-injection\\dist\\amd\\aurelia-dependency-injection","aurelia-event-aggregator":"..\\node_modules\\aurelia-event-aggregator\\dist\\amd\\aurelia-event-aggregator","aurelia-framework":"..\\node_modules\\aurelia-framework\\dist\\amd\\aurelia-framework","aurelia-loader":"..\\node_modules\\aurelia-loader\\dist\\amd\\aurelia-loader","aurelia-loader-default":"..\\node_modules\\aurelia-loader-default\\dist\\amd\\aurelia-loader-default","aurelia-logging":"..\\node_modules\\aurelia-logging\\dist\\amd\\aurelia-logging","aurelia-logging-console":"..\\node_modules\\aurelia-logging-console\\dist\\amd\\aurelia-logging-console","aurelia-metadata":"..\\node_modules\\aurelia-metadata\\dist\\amd\\aurelia-metadata","aurelia-pal":"..\\node_modules\\aurelia-pal\\dist\\amd\\aurelia-pal","aurelia-pal-browser":"..\\node_modules\\aurelia-pal-browser\\dist\\amd\\aurelia-pal-browser","aurelia-path":"..\\node_modules\\aurelia-path\\dist\\amd\\aurelia-path","aurelia-polyfills":"..\\node_modules\\aurelia-polyfills\\dist\\amd\\aurelia-polyfills","aurelia-task-queue":"..\\node_modules\\aurelia-task-queue\\dist\\amd\\aurelia-task-queue","aurelia-templating":"..\\node_modules\\aurelia-templating\\dist\\amd\\aurelia-templating","aurelia-templating-binding":"..\\node_modules\\aurelia-templating-binding\\dist\\amd\\aurelia-templating-binding","aurelia-templating-resources":"..\\node_modules\\aurelia-templating-resources\\dist\\amd\\aurelia-templating-resources","big-integer":"..\\node_modules\\big-integer\\BigInteger","crc-32":"..\\node_modules\\crc-32\\crc32","crypto":"../aurelia_project/native/crypto","zlib":"../aurelia_project/native/zlib","text":"..\\node_modules\\text\\text","editor-bundle":"../scripts/editor-bundle"},"packages":[{"name":"file-saver","location":"../node_modules/file-saver","main":"FileSaver.min"},{"name":"aurelia-templating-resources","location":"../node_modules/aurelia-templating-resources/dist/amd","main":"aurelia-templating-resources"},{"name":"libvantage","location":"../node_modules/libvantage/dist","main":"index"}],"stubModules":[],"shim":{},"bundles":{"editor-bundle":["editor","environment","file-utils","main","savedata"]}})}